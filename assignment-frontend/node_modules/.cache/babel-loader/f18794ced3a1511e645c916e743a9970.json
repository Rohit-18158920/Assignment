{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, KeyCodes, elementContains, findScrollableParent, getParent, getDocument, getWindow, isElementTabbable, css, initializeComponentRef, FocusRects } from '../../Utilities';\nimport { SelectionMode } from './interfaces'; // Selection definitions:\n//\n// Anchor index: the point from which a range selection starts.\n// Focus index: the point from which layout movement originates from.\n//\n// These two can differ. Tests:\n//\n// If you start at index 5\n// Shift click to index 10\n//    The focus is 10, the anchor is 5.\n// If you shift click at index 0\n//    The anchor remains at 5, the items between 0 and 5 are selected and everything else is cleared.\n// If you click index 8\n//    The anchor and focus are set to 8.\n\nvar SELECTION_DISABLED_ATTRIBUTE_NAME = 'data-selection-disabled';\nvar SELECTION_INDEX_ATTRIBUTE_NAME = 'data-selection-index';\nvar SELECTION_TOGGLE_ATTRIBUTE_NAME = 'data-selection-toggle';\nvar SELECTION_INVOKE_ATTRIBUTE_NAME = 'data-selection-invoke';\nvar SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME = 'data-selection-touch-invoke';\nvar SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME = 'data-selection-all-toggle';\nvar SELECTION_SELECT_ATTRIBUTE_NAME = 'data-selection-select';\n/**\n * {@docCategory Selection}\n */\n\nvar SelectionZone =\n/** @class */\nfunction (_super) {\n  __extends(SelectionZone, _super);\n\n  function SelectionZone(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    /**\n     * In some cases, the consuming scenario requires to set focus on a row without having SelectionZone\n     * react to the event. Note that focus events in IE \\<= 11 will occur asynchronously after .focus() has\n     * been called on an element, so we need a flag to store the idea that we will bypass the \"next\"\n     * focus event that occurs. This method does that.\n     */\n\n    _this.ignoreNextFocus = function () {\n      _this._handleNextFocus(false);\n    };\n\n    _this._onSelectionChange = function () {\n      var selection = _this.props.selection;\n      var isModal = selection.isModal && selection.isModal();\n\n      _this.setState({\n        isModal: isModal\n      });\n    };\n\n    _this._onMouseDownCapture = function (ev) {\n      var target = ev.target;\n\n      if (document.activeElement !== target && !elementContains(document.activeElement, target)) {\n        _this.ignoreNextFocus();\n\n        return;\n      }\n\n      if (!elementContains(target, _this._root.current)) {\n        return;\n      }\n\n      while (target !== _this._root.current) {\n        if (_this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n          _this.ignoreNextFocus();\n\n          break;\n        }\n\n        target = getParent(target);\n      }\n    };\n    /**\n     * When we focus an item, for single/multi select scenarios, we should try to select it immediately\n     * as long as the focus did not originate from a mouse down/touch event. For those cases, we handle them\n     * specially.\n     */\n\n\n    _this._onFocus = function (ev) {\n      var target = ev.target;\n      var selection = _this.props.selection;\n      var isToggleModifierPressed = _this._isCtrlPressed || _this._isMetaPressed;\n\n      var selectionMode = _this._getSelectionMode();\n\n      if (_this._shouldHandleFocus && selectionMode !== SelectionMode.none) {\n        var isToggle = _this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME);\n\n        var itemRoot = _this._findItemRoot(target);\n\n        if (!isToggle && itemRoot) {\n          var index = _this._getItemIndex(itemRoot);\n\n          if (isToggleModifierPressed) {\n            // set anchor only.\n            selection.setIndexSelected(index, selection.isIndexSelected(index), true);\n\n            if (_this.props.enterModalOnTouch && _this._isTouch && selection.setModal) {\n              selection.setModal(true);\n\n              _this._setIsTouch(false);\n            }\n          } else {\n            if (_this.props.isSelectedOnFocus) {\n              _this._onItemSurfaceClick(ev, index);\n            }\n          }\n        }\n      }\n\n      _this._handleNextFocus(false);\n    };\n\n    _this._onMouseDown = function (ev) {\n      _this._updateModifiers(ev);\n\n      var target = ev.target;\n\n      var itemRoot = _this._findItemRoot(target); // No-op if selection is disabled\n\n\n      if (_this._isSelectionDisabled(target)) {\n        return;\n      }\n\n      while (target !== _this._root.current) {\n        if (_this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n          break;\n        } else if (itemRoot) {\n          if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n            break;\n          } else if (_this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n            break;\n          } else if ((target === itemRoot || _this._shouldAutoSelect(target)) && !_this._isShiftPressed && !_this._isCtrlPressed && !_this._isMetaPressed) {\n            _this._onInvokeMouseDown(ev, _this._getItemIndex(itemRoot));\n\n            break;\n          } else if (_this.props.disableAutoSelectOnInputElements && (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT')) {\n            return;\n          }\n        }\n\n        target = getParent(target);\n      }\n    };\n\n    _this._onTouchStartCapture = function (ev) {\n      _this._setIsTouch(true);\n    };\n\n    _this._onClick = function (ev) {\n      var _a = _this.props.enableTouchInvocationTarget,\n          enableTouchInvocationTarget = _a === void 0 ? false : _a;\n\n      _this._updateModifiers(ev);\n\n      var target = ev.target;\n\n      var itemRoot = _this._findItemRoot(target);\n\n      var isSelectionDisabled = _this._isSelectionDisabled(target);\n\n      while (target !== _this._root.current) {\n        if (_this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n          if (!isSelectionDisabled) {\n            _this._onToggleAllClick(ev);\n          }\n\n          break;\n        } else if (itemRoot) {\n          var index = _this._getItemIndex(itemRoot);\n\n          if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n            if (!isSelectionDisabled) {\n              if (_this._isShiftPressed) {\n                _this._onItemSurfaceClick(ev, index);\n              } else {\n                _this._onToggleClick(ev, index);\n              }\n            }\n\n            break;\n          } else if (_this._isTouch && enableTouchInvocationTarget && _this._hasAttribute(target, SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME) || _this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n            // Items should be invokable even if selection is disabled.\n            _this._onInvokeClick(ev, index);\n\n            break;\n          } else if (target === itemRoot) {\n            if (!isSelectionDisabled) {\n              _this._onItemSurfaceClick(ev, index);\n            }\n\n            break;\n          } else if (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT') {\n            return;\n          }\n        }\n\n        target = getParent(target);\n      }\n    };\n\n    _this._onContextMenu = function (ev) {\n      var target = ev.target;\n      var _a = _this.props,\n          onItemContextMenu = _a.onItemContextMenu,\n          selection = _a.selection;\n\n      if (onItemContextMenu) {\n        var itemRoot = _this._findItemRoot(target);\n\n        if (itemRoot) {\n          var index = _this._getItemIndex(itemRoot);\n\n          _this._onInvokeMouseDown(ev, index);\n\n          var skipPreventDefault = onItemContextMenu(selection.getItems()[index], index, ev.nativeEvent); // In order to keep back compat, if the value here is undefined, then we should still\n          // call preventDefault(). Only in the case where true is explicitly returned should\n          // the call be skipped.\n\n          if (!skipPreventDefault) {\n            ev.preventDefault();\n          }\n        }\n      }\n    };\n    /**\n     * In multi selection, if you double click within an item's root (but not within the invoke element or\n     * input elements), we should execute the invoke handler.\n     */\n\n\n    _this._onDoubleClick = function (ev) {\n      var target = ev.target;\n      var onItemInvoked = _this.props.onItemInvoked;\n\n      var itemRoot = _this._findItemRoot(target);\n\n      if (itemRoot && onItemInvoked && !_this._isInputElement(target)) {\n        var index = _this._getItemIndex(itemRoot);\n\n        while (target !== _this._root.current) {\n          if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME) || _this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n            break;\n          } else if (target === itemRoot) {\n            _this._onInvokeClick(ev, index);\n\n            break;\n          }\n\n          target = getParent(target);\n        }\n\n        target = getParent(target);\n      }\n    };\n\n    _this._onKeyDownCapture = function (ev) {\n      _this._updateModifiers(ev);\n\n      _this._handleNextFocus(true);\n    };\n\n    _this._onKeyDown = function (ev) {\n      _this._updateModifiers(ev);\n\n      var target = ev.target;\n\n      var isSelectionDisabled = _this._isSelectionDisabled(target);\n\n      var selection = _this.props.selection;\n      var isSelectAllKey = ev.which === KeyCodes.a && (_this._isCtrlPressed || _this._isMetaPressed);\n      var isClearSelectionKey = ev.which === KeyCodes.escape; // Ignore key downs from input elements.\n\n      if (_this._isInputElement(target)) {\n        // A key was pressed while an item in this zone was focused.\n        return;\n      }\n\n      var selectionMode = _this._getSelectionMode(); // If ctrl-a is pressed, select all (if all are not already selected.)\n\n\n      if (isSelectAllKey && selectionMode === SelectionMode.multiple && !selection.isAllSelected()) {\n        if (!isSelectionDisabled) {\n          selection.setAllSelected(true);\n        }\n\n        ev.stopPropagation();\n        ev.preventDefault();\n        return;\n      } // If escape is pressed, clear selection (if any are selected.)\n\n\n      if (isClearSelectionKey && selection.getSelectedCount() > 0) {\n        if (!isSelectionDisabled) {\n          selection.setAllSelected(false);\n        }\n\n        ev.stopPropagation();\n        ev.preventDefault();\n        return;\n      }\n\n      var itemRoot = _this._findItemRoot(target); // If a key was pressed within an item, we should treat \"enters\" as invokes and \"space\" as toggle\n\n\n      if (itemRoot) {\n        var index = _this._getItemIndex(itemRoot);\n\n        while (target !== _this._root.current) {\n          if (_this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n            // For toggle elements, assuming they are rendered as buttons, they will generate a click event,\n            // so we can no-op for any keydowns in this case.\n            break;\n          } else if (_this._shouldAutoSelect(target)) {\n            if (!isSelectionDisabled) {\n              // If the event went to an element which should trigger auto-select, select it and then let\n              // the default behavior kick in.\n              _this._onInvokeMouseDown(ev, index);\n            }\n\n            break;\n          } else if ((ev.which === KeyCodes.enter || ev.which === KeyCodes.space) && (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT')) {\n            return false;\n          } else if (target === itemRoot) {\n            if (ev.which === KeyCodes.enter) {\n              // Items should be invokable even if selection is disabled.\n              _this._onInvokeClick(ev, index);\n\n              ev.preventDefault();\n              return;\n            } else if (ev.which === KeyCodes.space) {\n              if (!isSelectionDisabled) {\n                _this._onToggleClick(ev, index);\n              }\n\n              ev.preventDefault();\n              return;\n            }\n\n            break;\n          }\n\n          target = getParent(target);\n        }\n      }\n    };\n\n    _this._events = new EventGroup(_this);\n    _this._async = new Async(_this);\n    initializeComponentRef(_this);\n    var selection = _this.props.selection; // Reflect the initial modal state of selection into the state.\n\n    var isModal = selection.isModal && selection.isModal();\n    _this.state = {\n      isModal: isModal\n    };\n    return _this;\n  }\n\n  SelectionZone.getDerivedStateFromProps = function (nextProps, prevState) {\n    var isModal = nextProps.selection.isModal && nextProps.selection.isModal();\n    return __assign(__assign({}, prevState), {\n      isModal: isModal\n    });\n  };\n\n  SelectionZone.prototype.componentDidMount = function () {\n    var win = getWindow(this._root.current); // Track the latest modifier keys globally.\n\n    this._events.on(win, 'keydown, keyup', this._updateModifiers, true);\n\n    this._events.on(document, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n\n    this._events.on(document.body, 'touchstart', this._onTouchStartCapture, true);\n\n    this._events.on(document.body, 'touchend', this._onTouchStartCapture, true); // Subscribe to the selection to keep modal state updated.\n\n\n    this._events.on(this.props.selection, 'change', this._onSelectionChange);\n  };\n\n  SelectionZone.prototype.render = function () {\n    var isModal = this.state.isModal;\n    return React.createElement(\"div\", {\n      className: css('ms-SelectionZone', this.props.className, {\n        'ms-SelectionZone--modal': !!isModal\n      }),\n      ref: this._root,\n      onKeyDown: this._onKeyDown,\n      onMouseDown: this._onMouseDown,\n      onKeyDownCapture: this._onKeyDownCapture,\n      onClick: this._onClick,\n      role: \"presentation\",\n      onDoubleClick: this._onDoubleClick,\n      onContextMenu: this._onContextMenu,\n      onMouseDownCapture: this._onMouseDownCapture,\n      onFocusCapture: this._onFocus,\n      \"data-selection-is-modal\": isModal ? true : undefined\n    }, this.props.children, React.createElement(FocusRects, null));\n  };\n\n  SelectionZone.prototype.componentDidUpdate = function (previousProps) {\n    var selection = this.props.selection;\n\n    if (selection !== previousProps.selection) {\n      // Whenever selection changes, update the subscripton to keep modal state updated.\n      this._events.off(previousProps.selection);\n\n      this._events.on(selection, 'change', this._onSelectionChange);\n    }\n  };\n\n  SelectionZone.prototype.componentWillUnmount = function () {\n    this._events.dispose();\n\n    this._async.dispose();\n  };\n\n  SelectionZone.prototype._isSelectionDisabled = function (target) {\n    if (this._getSelectionMode() === SelectionMode.none) {\n      return true;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTION_DISABLED_ATTRIBUTE_NAME)) {\n        return true;\n      }\n\n      target = getParent(target);\n    }\n\n    return false;\n  };\n\n  SelectionZone.prototype._onToggleAllClick = function (ev) {\n    var selection = this.props.selection;\n\n    var selectionMode = this._getSelectionMode();\n\n    if (selectionMode === SelectionMode.multiple) {\n      selection.toggleAllSelected();\n      ev.stopPropagation();\n      ev.preventDefault();\n    }\n  };\n\n  SelectionZone.prototype._onToggleClick = function (ev, index) {\n    var selection = this.props.selection;\n\n    var selectionMode = this._getSelectionMode();\n\n    selection.setChangeEvents(false);\n\n    if (this.props.enterModalOnTouch && this._isTouch && !selection.isIndexSelected(index) && selection.setModal) {\n      selection.setModal(true);\n\n      this._setIsTouch(false);\n    }\n\n    if (selectionMode === SelectionMode.multiple) {\n      selection.toggleIndexSelected(index);\n    } else if (selectionMode === SelectionMode.single) {\n      var isSelected = selection.isIndexSelected(index);\n      var isModal = selection.isModal && selection.isModal();\n      selection.setAllSelected(false);\n      selection.setIndexSelected(index, !isSelected, true);\n\n      if (isModal && selection.setModal) {\n        // Since the above call to setAllSelected(false) clears modal state,\n        // restore it. This occurs because the SelectionMode of the Selection\n        // may differ from the SelectionZone.\n        selection.setModal(true);\n      }\n    } else {\n      selection.setChangeEvents(true);\n      return;\n    }\n\n    selection.setChangeEvents(true);\n    ev.stopPropagation(); // NOTE: ev.preventDefault is not called for toggle clicks, because this will kill the browser behavior\n    // for checkboxes if you use a checkbox for the toggle.\n  };\n\n  SelectionZone.prototype._onInvokeClick = function (ev, index) {\n    var _a = this.props,\n        selection = _a.selection,\n        onItemInvoked = _a.onItemInvoked;\n\n    if (onItemInvoked) {\n      onItemInvoked(selection.getItems()[index], index, ev.nativeEvent);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n\n  SelectionZone.prototype._onItemSurfaceClick = function (ev, index) {\n    var selection = this.props.selection;\n    var isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;\n\n    var selectionMode = this._getSelectionMode();\n\n    if (selectionMode === SelectionMode.multiple) {\n      if (this._isShiftPressed && !this._isTabPressed) {\n        selection.selectToIndex(index, !isToggleModifierPressed);\n      } else if (isToggleModifierPressed) {\n        selection.toggleIndexSelected(index);\n      } else {\n        this._clearAndSelectIndex(index);\n      }\n    } else if (selectionMode === SelectionMode.single) {\n      this._clearAndSelectIndex(index);\n    }\n  };\n\n  SelectionZone.prototype._onInvokeMouseDown = function (ev, index) {\n    var selection = this.props.selection; // Only do work if item is not selected.\n\n    if (selection.isIndexSelected(index)) {\n      return;\n    }\n\n    this._clearAndSelectIndex(index);\n  };\n  /**\n   * To avoid high startup cost of traversing the DOM on component mount,\n   * defer finding the scrollable parent until a click interaction.\n   *\n   * The styles will probably already calculated since we're running in a click handler,\n   * so this is less likely to cause layout thrashing then doing it in mount.\n   */\n\n\n  SelectionZone.prototype._findScrollParentAndTryClearOnEmptyClick = function (ev) {\n    var scrollParent = findScrollableParent(this._root.current); // unbind this handler and replace binding with a binding on the actual scrollable parent\n\n    this._events.off(document, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n\n    this._events.on(scrollParent, 'click', this._tryClearOnEmptyClick); // If we clicked inside the scrollable parent, call through to the handler on this click.\n\n\n    if (scrollParent && ev.target instanceof Node && scrollParent.contains(ev.target) || scrollParent === ev.target) {\n      this._tryClearOnEmptyClick(ev);\n    }\n  };\n\n  SelectionZone.prototype._tryClearOnEmptyClick = function (ev) {\n    if (!this.props.selectionPreservedOnEmptyClick && this._isNonHandledClick(ev.target)) {\n      this.props.selection.setAllSelected(false);\n    }\n  };\n\n  SelectionZone.prototype._clearAndSelectIndex = function (index) {\n    var selection = this.props.selection;\n    var isAlreadySingleSelected = selection.getSelectedCount() === 1 && selection.isIndexSelected(index);\n\n    if (!isAlreadySingleSelected) {\n      var isModal = selection.isModal && selection.isModal();\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n      selection.setIndexSelected(index, true, true);\n\n      if (isModal || this.props.enterModalOnTouch && this._isTouch) {\n        if (selection.setModal) {\n          selection.setModal(true);\n        }\n\n        if (this._isTouch) {\n          this._setIsTouch(false);\n        }\n      }\n\n      selection.setChangeEvents(true);\n    }\n  };\n  /**\n   * We need to track the modifier key states so that when focus events occur, which do not contain\n   * modifier states in the Event object, we know how to behave.\n   */\n\n\n  SelectionZone.prototype._updateModifiers = function (ev) {\n    this._isShiftPressed = ev.shiftKey;\n    this._isCtrlPressed = ev.ctrlKey;\n    this._isMetaPressed = ev.metaKey;\n    var keyCode = ev.keyCode;\n    this._isTabPressed = keyCode ? keyCode === KeyCodes.tab : false;\n  };\n\n  SelectionZone.prototype._findItemRoot = function (target) {\n    var selection = this.props.selection;\n\n    while (target !== this._root.current) {\n      var indexValue = target.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME);\n      var index = Number(indexValue);\n\n      if (indexValue !== null && index >= 0 && index < selection.getItems().length) {\n        break;\n      }\n\n      target = getParent(target);\n    }\n\n    if (target === this._root.current) {\n      return undefined;\n    }\n\n    return target;\n  };\n\n  SelectionZone.prototype._getItemIndex = function (itemRoot) {\n    return Number(itemRoot.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME));\n  };\n\n  SelectionZone.prototype._shouldAutoSelect = function (element) {\n    return this._hasAttribute(element, SELECTION_SELECT_ATTRIBUTE_NAME);\n  };\n\n  SelectionZone.prototype._hasAttribute = function (element, attributeName) {\n    var isToggle = false;\n\n    while (!isToggle && element !== this._root.current) {\n      isToggle = element.getAttribute(attributeName) === 'true';\n      element = getParent(element);\n    }\n\n    return isToggle;\n  };\n\n  SelectionZone.prototype._isInputElement = function (element) {\n    return element.tagName === 'INPUT' || element.tagName === 'TEXTAREA';\n  };\n\n  SelectionZone.prototype._isNonHandledClick = function (element) {\n    var doc = getDocument();\n\n    if (doc && element) {\n      while (element && element !== doc.documentElement) {\n        if (isElementTabbable(element)) {\n          return false;\n        }\n\n        element = getParent(element);\n      }\n    }\n\n    return true;\n  };\n\n  SelectionZone.prototype._handleNextFocus = function (handleFocus) {\n    var _this = this;\n\n    if (this._shouldHandleFocusTimeoutId) {\n      this._async.clearTimeout(this._shouldHandleFocusTimeoutId);\n\n      this._shouldHandleFocusTimeoutId = undefined;\n    }\n\n    this._shouldHandleFocus = handleFocus;\n\n    if (handleFocus) {\n      this._async.setTimeout(function () {\n        _this._shouldHandleFocus = false;\n      }, 100);\n    }\n  };\n\n  SelectionZone.prototype._setIsTouch = function (isTouch) {\n    var _this = this;\n\n    if (this._isTouchTimeoutId) {\n      this._async.clearTimeout(this._isTouchTimeoutId);\n\n      this._isTouchTimeoutId = undefined;\n    }\n\n    this._isTouch = true;\n\n    if (isTouch) {\n      this._async.setTimeout(function () {\n        _this._isTouch = false;\n      }, 300);\n    }\n  };\n\n  SelectionZone.prototype._getSelectionMode = function () {\n    var selection = this.props.selection;\n    var _a = this.props.selectionMode,\n        selectionMode = _a === void 0 ? selection ? selection.mode : SelectionMode.none : _a;\n    return selectionMode;\n  };\n\n  SelectionZone.defaultProps = {\n    isSelectedOnFocus: true,\n    selectionMode: SelectionMode.multiple\n  };\n  return SelectionZone;\n}(React.Component);\n\nexport { SelectionZone };","map":{"version":3,"sources":["utilities/selection/SelectionZone.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  EventGroup,\n  KeyCodes,\n  elementContains,\n  findScrollableParent,\n  getParent,\n  getDocument,\n  getWindow,\n  isElementTabbable,\n  css,\n  initializeComponentRef,\n  FocusRects,\n} from '../../Utilities';\nimport { ISelection, SelectionMode, IObjectWithKey } from './interfaces';\n\n// Selection definitions:\n//\n// Anchor index: the point from which a range selection starts.\n// Focus index: the point from which layout movement originates from.\n//\n// These two can differ. Tests:\n//\n// If you start at index 5\n// Shift click to index 10\n//    The focus is 10, the anchor is 5.\n// If you shift click at index 0\n//    The anchor remains at 5, the items between 0 and 5 are selected and everything else is cleared.\n// If you click index 8\n//    The anchor and focus are set to 8.\n\nconst SELECTION_DISABLED_ATTRIBUTE_NAME = 'data-selection-disabled';\nconst SELECTION_INDEX_ATTRIBUTE_NAME = 'data-selection-index';\nconst SELECTION_TOGGLE_ATTRIBUTE_NAME = 'data-selection-toggle';\nconst SELECTION_INVOKE_ATTRIBUTE_NAME = 'data-selection-invoke';\nconst SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME = 'data-selection-touch-invoke';\nconst SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME = 'data-selection-all-toggle';\nconst SELECTION_SELECT_ATTRIBUTE_NAME = 'data-selection-select';\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionZone {\n  /**\n   * Method to ignore subsequent focus.\n   */\n  ignoreNextFocus: () => void;\n}\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionZoneProps extends React.ClassAttributes<SelectionZone> {\n  /**\n   * Reference to the component interface.\n   */\n  componentRef?: () => void;\n  /**\n   * Required {@link ISelection} instance bound to the {@link SelectionZone}.\n   */\n  selection: ISelection;\n  /**\n   * @deprecated No longer in use, focus is now managed by {@link FocusZone}.\n   */\n  layout?: {};\n  /**\n   * The mode of Selection, where the value is one of\n   * 'none', 'single', or 'multiple'.\n   *\n   * @defaultvalue {@link SelectionMode.multiple}\n   */\n  selectionMode?: SelectionMode;\n  /**\n   * If true, selection is preserved on outer click.\n   */\n  selectionPreservedOnEmptyClick?: boolean;\n  /**\n   * If true, disables automatic selection on input elements.\n   */\n  disableAutoSelectOnInputElements?: boolean;\n  /**\n   * If true, modal selection is enabled on touch event.\n   */\n  enterModalOnTouch?: boolean;\n  /**\n   * Determines whether elements with the attribute `data-selection-touch-invoke` should be used as invocation targets\n   * for an item if the user is using touch.\n   *\n   * @defaultvalue false\n   */\n  enableTouchInvocationTarget?: boolean;\n  /**\n   * Determines if an item is selected on focus.\n   *\n   * @defaultvalue true\n   */\n  isSelectedOnFocus?: boolean;\n  /**\n   * Optional callback for when an item is\n   * invoked via ENTER or double-click.\n   */\n  onItemInvoked?: (item?: IObjectWithKey, index?: number, ev?: Event) => void;\n  /**\n   * Optional callback for when an\n   * item's contextual menu action occurs.\n   */\n  onItemContextMenu?: (item?: any, index?: number, ev?: Event) => void | boolean;\n  /**\n   * Additional CSS class(es) to apply to the SelectionZone.\n   */\n  className?: string;\n}\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionZoneState {\n  isModal: boolean | undefined;\n}\n\n/**\n * {@docCategory Selection}\n */\nexport class SelectionZone extends React.Component<ISelectionZoneProps, ISelectionZoneState> {\n  public static defaultProps = {\n    isSelectedOnFocus: true,\n    selectionMode: SelectionMode.multiple,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _root = React.createRef<HTMLDivElement>();\n  private _isCtrlPressed: boolean;\n  private _isShiftPressed: boolean;\n  private _isMetaPressed: boolean;\n  private _isTabPressed: boolean;\n  private _shouldHandleFocus: boolean;\n  private _shouldHandleFocusTimeoutId: number | undefined;\n  private _isTouch: boolean;\n  private _isTouchTimeoutId: number | undefined;\n\n  public static getDerivedStateFromProps(\n    nextProps: ISelectionZoneProps,\n    prevState: ISelectionZoneState,\n  ): ISelectionZoneState {\n    const isModal = nextProps.selection.isModal && nextProps.selection.isModal();\n\n    return {\n      ...prevState,\n      isModal,\n    };\n  }\n\n  constructor(props: ISelectionZoneProps) {\n    super(props);\n\n    this._events = new EventGroup(this);\n    this._async = new Async(this);\n    initializeComponentRef(this);\n\n    const { selection } = this.props;\n\n    // Reflect the initial modal state of selection into the state.\n    const isModal = selection.isModal && selection.isModal();\n\n    this.state = {\n      isModal,\n    };\n  }\n\n  public componentDidMount(): void {\n    const win = getWindow(this._root.current);\n\n    // Track the latest modifier keys globally.\n    this._events.on(win, 'keydown, keyup', this._updateModifiers, true);\n    this._events.on(document, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n    this._events.on(document.body, 'touchstart', this._onTouchStartCapture, true);\n    this._events.on(document.body, 'touchend', this._onTouchStartCapture, true);\n\n    // Subscribe to the selection to keep modal state updated.\n    this._events.on(this.props.selection, 'change', this._onSelectionChange);\n  }\n\n  public render(): JSX.Element {\n    const { isModal } = this.state;\n\n    return (\n      <div\n        className={css('ms-SelectionZone', this.props.className, {\n          'ms-SelectionZone--modal': !!isModal,\n        })}\n        ref={this._root}\n        onKeyDown={this._onKeyDown}\n        onMouseDown={this._onMouseDown}\n        onKeyDownCapture={this._onKeyDownCapture}\n        onClick={this._onClick}\n        role=\"presentation\"\n        onDoubleClick={this._onDoubleClick}\n        onContextMenu={this._onContextMenu}\n        onMouseDownCapture={this._onMouseDownCapture}\n        onFocusCapture={this._onFocus}\n        data-selection-is-modal={isModal ? true : undefined}\n      >\n        {this.props.children}\n        <FocusRects />\n      </div>\n    );\n  }\n\n  public componentDidUpdate(previousProps: ISelectionZoneProps): void {\n    const { selection } = this.props;\n\n    if (selection !== previousProps.selection) {\n      // Whenever selection changes, update the subscripton to keep modal state updated.\n      this._events.off(previousProps.selection);\n      this._events.on(selection, 'change', this._onSelectionChange);\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._events.dispose();\n    this._async.dispose();\n  }\n\n  /**\n   * In some cases, the consuming scenario requires to set focus on a row without having SelectionZone\n   * react to the event. Note that focus events in IE \\<= 11 will occur asynchronously after .focus() has\n   * been called on an element, so we need a flag to store the idea that we will bypass the \"next\"\n   * focus event that occurs. This method does that.\n   */\n  public ignoreNextFocus = (): void => {\n    this._handleNextFocus(false);\n  };\n\n  private _onSelectionChange = (): void => {\n    const { selection } = this.props;\n\n    const isModal = selection.isModal && selection.isModal();\n\n    this.setState({\n      isModal,\n    });\n  };\n\n  private _onMouseDownCapture = (ev: React.MouseEvent<HTMLElement>): void => {\n    let target = ev.target as HTMLElement;\n\n    if (document.activeElement !== target && !elementContains(document.activeElement as HTMLElement, target)) {\n      this.ignoreNextFocus();\n      return;\n    }\n\n    if (!elementContains(target, this._root.current)) {\n      return;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n        this.ignoreNextFocus();\n        break;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  /**\n   * When we focus an item, for single/multi select scenarios, we should try to select it immediately\n   * as long as the focus did not originate from a mouse down/touch event. For those cases, we handle them\n   * specially.\n   */\n  private _onFocus = (ev: React.FocusEvent<HTMLElement>): void => {\n    const target = ev.target as HTMLElement;\n    const { selection } = this.props;\n    const isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;\n\n    const selectionMode = this._getSelectionMode();\n\n    if (this._shouldHandleFocus && selectionMode !== SelectionMode.none) {\n      const isToggle = this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME);\n      const itemRoot = this._findItemRoot(target);\n\n      if (!isToggle && itemRoot) {\n        const index = this._getItemIndex(itemRoot);\n\n        if (isToggleModifierPressed) {\n          // set anchor only.\n          selection.setIndexSelected(index, selection.isIndexSelected(index), true);\n          if (this.props.enterModalOnTouch && this._isTouch && selection.setModal) {\n            selection.setModal(true);\n            this._setIsTouch(false);\n          }\n        } else {\n          if (this.props.isSelectedOnFocus) {\n            this._onItemSurfaceClick(ev, index);\n          }\n        }\n      }\n    }\n\n    this._handleNextFocus(false);\n  };\n\n  private _onMouseDown = (ev: React.MouseEvent<HTMLElement>): void => {\n    this._updateModifiers(ev);\n\n    let target = ev.target as HTMLElement;\n    const itemRoot = this._findItemRoot(target);\n\n    // No-op if selection is disabled\n    if (this._isSelectionDisabled(target)) {\n      return;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n        break;\n      } else if (itemRoot) {\n        if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n          break;\n        } else if (this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {\n          break;\n        } else if (\n          (target === itemRoot || this._shouldAutoSelect(target)) &&\n          !this._isShiftPressed &&\n          !this._isCtrlPressed &&\n          !this._isMetaPressed\n        ) {\n          this._onInvokeMouseDown(ev, this._getItemIndex(itemRoot));\n          break;\n        } else if (\n          this.props.disableAutoSelectOnInputElements &&\n          (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT')\n        ) {\n          return;\n        }\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  private _onTouchStartCapture = (ev: React.TouchEvent<HTMLElement>): void => {\n    this._setIsTouch(true);\n  };\n\n  private _onClick = (ev: React.MouseEvent<HTMLElement>): void => {\n    const { enableTouchInvocationTarget = false } = this.props;\n\n    this._updateModifiers(ev);\n\n    let target = ev.target as HTMLElement;\n    const itemRoot = this._findItemRoot(target);\n\n    const isSelectionDisabled = this._isSelectionDisabled(target);\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {\n        if (!isSelectionDisabled) {\n          this._onToggleAllClick(ev);\n        }\n        break;\n      } else if (itemRoot) {\n        const index = this._getItemIndex(itemRoot);\n\n        if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n          if (!isSelectionDisabled) {\n            if (this._isShiftPressed) {\n              this._onItemSurfaceClick(ev, index);\n            } else {\n              this._onToggleClick(ev, index);\n            }\n          }\n          break;\n        } else if (\n          (this._isTouch &&\n            enableTouchInvocationTarget &&\n            this._hasAttribute(target, SELECTION_INVOKE_TOUCH_ATTRIBUTE_NAME)) ||\n          this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)\n        ) {\n          // Items should be invokable even if selection is disabled.\n          this._onInvokeClick(ev, index);\n          break;\n        } else if (target === itemRoot) {\n          if (!isSelectionDisabled) {\n            this._onItemSurfaceClick(ev, index);\n          }\n          break;\n        } else if (target.tagName === 'A' || target.tagName === 'BUTTON' || target.tagName === 'INPUT') {\n          return;\n        }\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  private _onContextMenu = (ev: React.MouseEvent<HTMLElement>): void => {\n    const target = ev.target as HTMLElement;\n\n    const { onItemContextMenu, selection } = this.props;\n    if (onItemContextMenu) {\n      const itemRoot = this._findItemRoot(target);\n\n      if (itemRoot) {\n        const index = this._getItemIndex(itemRoot);\n\n        this._onInvokeMouseDown(ev, index);\n\n        const skipPreventDefault = onItemContextMenu(selection.getItems()[index], index, ev.nativeEvent);\n\n        // In order to keep back compat, if the value here is undefined, then we should still\n        // call preventDefault(). Only in the case where true is explicitly returned should\n        // the call be skipped.\n        if (!skipPreventDefault) {\n          ev.preventDefault();\n        }\n      }\n    }\n  };\n\n  private _isSelectionDisabled(target: HTMLElement): boolean {\n    if (this._getSelectionMode() === SelectionMode.none) {\n      return true;\n    }\n\n    while (target !== this._root.current) {\n      if (this._hasAttribute(target, SELECTION_DISABLED_ATTRIBUTE_NAME)) {\n        return true;\n      }\n      target = getParent(target) as HTMLElement;\n    }\n\n    return false;\n  }\n\n  /**\n   * In multi selection, if you double click within an item's root (but not within the invoke element or\n   * input elements), we should execute the invoke handler.\n   */\n  private _onDoubleClick = (ev: React.MouseEvent<HTMLElement>): void => {\n    let target = ev.target as HTMLElement;\n\n    const { onItemInvoked } = this.props;\n    const itemRoot = this._findItemRoot(target);\n\n    if (itemRoot && onItemInvoked && !this._isInputElement(target)) {\n      const index = this._getItemIndex(itemRoot);\n\n      while (target !== this._root.current) {\n        if (\n          this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME) ||\n          this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)\n        ) {\n          break;\n        } else if (target === itemRoot) {\n          this._onInvokeClick(ev, index);\n          break;\n        }\n\n        target = getParent(target) as HTMLElement;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n  };\n\n  private _onKeyDownCapture = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    this._updateModifiers(ev);\n\n    this._handleNextFocus(true);\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean | undefined => {\n    this._updateModifiers(ev);\n\n    let target = ev.target as HTMLElement;\n\n    const isSelectionDisabled = this._isSelectionDisabled(target);\n\n    const { selection } = this.props;\n    const isSelectAllKey = ev.which === KeyCodes.a && (this._isCtrlPressed || this._isMetaPressed);\n    const isClearSelectionKey = ev.which === KeyCodes.escape;\n\n    // Ignore key downs from input elements.\n    if (this._isInputElement(target)) {\n      // A key was pressed while an item in this zone was focused.\n      return;\n    }\n\n    const selectionMode = this._getSelectionMode();\n\n    // If ctrl-a is pressed, select all (if all are not already selected.)\n    if (isSelectAllKey && selectionMode === SelectionMode.multiple && !selection.isAllSelected()) {\n      if (!isSelectionDisabled) {\n        selection.setAllSelected(true);\n      }\n      ev.stopPropagation();\n      ev.preventDefault();\n      return;\n    }\n\n    // If escape is pressed, clear selection (if any are selected.)\n    if (isClearSelectionKey && selection.getSelectedCount() > 0) {\n      if (!isSelectionDisabled) {\n        selection.setAllSelected(false);\n      }\n      ev.stopPropagation();\n      ev.preventDefault();\n      return;\n    }\n\n    const itemRoot = this._findItemRoot(target);\n\n    // If a key was pressed within an item, we should treat \"enters\" as invokes and \"space\" as toggle\n    if (itemRoot) {\n      const index = this._getItemIndex(itemRoot);\n\n      while (target !== this._root.current) {\n        if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {\n          // For toggle elements, assuming they are rendered as buttons, they will generate a click event,\n          // so we can no-op for any keydowns in this case.\n          break;\n        } else if (this._shouldAutoSelect(target)) {\n          if (!isSelectionDisabled) {\n            // If the event went to an element which should trigger auto-select, select it and then let\n            // the default behavior kick in.\n            this._onInvokeMouseDown(ev, index);\n          }\n          break;\n        } else if (\n          (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) &&\n          (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT')\n        ) {\n          return false;\n        } else if (target === itemRoot) {\n          if (ev.which === KeyCodes.enter) {\n            // Items should be invokable even if selection is disabled.\n            this._onInvokeClick(ev, index);\n            ev.preventDefault();\n            return;\n          } else if (ev.which === KeyCodes.space) {\n            if (!isSelectionDisabled) {\n              this._onToggleClick(ev, index);\n            }\n            ev.preventDefault();\n            return;\n          }\n          break;\n        }\n\n        target = getParent(target) as HTMLElement;\n      }\n    }\n  };\n\n  private _onToggleAllClick(ev: React.MouseEvent<HTMLElement>): void {\n    const { selection } = this.props;\n\n    const selectionMode = this._getSelectionMode();\n\n    if (selectionMode === SelectionMode.multiple) {\n      selection.toggleAllSelected();\n      ev.stopPropagation();\n      ev.preventDefault();\n    }\n  }\n\n  private _onToggleClick(ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>, index: number): void {\n    const { selection } = this.props;\n\n    const selectionMode = this._getSelectionMode();\n\n    selection.setChangeEvents(false);\n\n    if (this.props.enterModalOnTouch && this._isTouch && !selection.isIndexSelected(index) && selection.setModal) {\n      selection.setModal(true);\n      this._setIsTouch(false);\n    }\n\n    if (selectionMode === SelectionMode.multiple) {\n      selection.toggleIndexSelected(index);\n    } else if (selectionMode === SelectionMode.single) {\n      const isSelected = selection.isIndexSelected(index);\n      const isModal = selection.isModal && selection.isModal();\n      selection.setAllSelected(false);\n      selection.setIndexSelected(index, !isSelected, true);\n      if (isModal && selection.setModal) {\n        // Since the above call to setAllSelected(false) clears modal state,\n        // restore it. This occurs because the SelectionMode of the Selection\n        // may differ from the SelectionZone.\n        selection.setModal(true);\n      }\n    } else {\n      selection.setChangeEvents(true);\n      return;\n    }\n\n    selection.setChangeEvents(true);\n\n    ev.stopPropagation();\n\n    // NOTE: ev.preventDefault is not called for toggle clicks, because this will kill the browser behavior\n    // for checkboxes if you use a checkbox for the toggle.\n  }\n\n  private _onInvokeClick(ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>, index: number): void {\n    const { selection, onItemInvoked } = this.props;\n\n    if (onItemInvoked) {\n      onItemInvoked(selection.getItems()[index], index, ev.nativeEvent);\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  }\n\n  private _onItemSurfaceClick(ev: React.SyntheticEvent<HTMLElement>, index: number): void {\n    const { selection } = this.props;\n    const isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;\n\n    const selectionMode = this._getSelectionMode();\n\n    if (selectionMode === SelectionMode.multiple) {\n      if (this._isShiftPressed && !this._isTabPressed) {\n        selection.selectToIndex(index, !isToggleModifierPressed);\n      } else if (isToggleModifierPressed) {\n        selection.toggleIndexSelected(index);\n      } else {\n        this._clearAndSelectIndex(index);\n      }\n    } else if (selectionMode === SelectionMode.single) {\n      this._clearAndSelectIndex(index);\n    }\n  }\n\n  private _onInvokeMouseDown(\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    index: number,\n  ): void {\n    const { selection } = this.props;\n\n    // Only do work if item is not selected.\n    if (selection.isIndexSelected(index)) {\n      return;\n    }\n\n    this._clearAndSelectIndex(index);\n  }\n\n  /**\n   * To avoid high startup cost of traversing the DOM on component mount,\n   * defer finding the scrollable parent until a click interaction.\n   *\n   * The styles will probably already calculated since we're running in a click handler,\n   * so this is less likely to cause layout thrashing then doing it in mount.\n   */\n  private _findScrollParentAndTryClearOnEmptyClick(ev: MouseEvent) {\n    const scrollParent = findScrollableParent(this._root.current) as HTMLElement;\n    // unbind this handler and replace binding with a binding on the actual scrollable parent\n    this._events.off(document, 'click', this._findScrollParentAndTryClearOnEmptyClick);\n    this._events.on(scrollParent, 'click', this._tryClearOnEmptyClick);\n\n    // If we clicked inside the scrollable parent, call through to the handler on this click.\n    if ((scrollParent && ev.target instanceof Node && scrollParent.contains(ev.target)) || scrollParent === ev.target) {\n      this._tryClearOnEmptyClick(ev);\n    }\n  }\n\n  private _tryClearOnEmptyClick(ev: MouseEvent): void {\n    if (!this.props.selectionPreservedOnEmptyClick && this._isNonHandledClick(ev.target as HTMLElement)) {\n      this.props.selection.setAllSelected(false);\n    }\n  }\n\n  private _clearAndSelectIndex(index: number): void {\n    const { selection } = this.props;\n    const isAlreadySingleSelected = selection.getSelectedCount() === 1 && selection.isIndexSelected(index);\n\n    if (!isAlreadySingleSelected) {\n      const isModal = selection.isModal && selection.isModal();\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n      selection.setIndexSelected(index, true, true);\n      if (isModal || (this.props.enterModalOnTouch && this._isTouch)) {\n        if (selection.setModal) {\n          selection.setModal(true);\n        }\n        if (this._isTouch) {\n          this._setIsTouch(false);\n        }\n      }\n      selection.setChangeEvents(true);\n    }\n  }\n\n  /**\n   * We need to track the modifier key states so that when focus events occur, which do not contain\n   * modifier states in the Event object, we know how to behave.\n   */\n  private _updateModifiers(ev: React.KeyboardEvent<HTMLElement> | React.MouseEvent<HTMLElement>): void {\n    this._isShiftPressed = ev.shiftKey;\n    this._isCtrlPressed = ev.ctrlKey;\n    this._isMetaPressed = ev.metaKey;\n\n    const keyCode = (ev as React.KeyboardEvent<HTMLElement>).keyCode;\n    this._isTabPressed = keyCode ? keyCode === KeyCodes.tab : false;\n  }\n\n  private _findItemRoot(target: HTMLElement): HTMLElement | undefined {\n    const { selection } = this.props;\n\n    while (target !== this._root.current) {\n      const indexValue = target.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME);\n      const index = Number(indexValue);\n\n      if (indexValue !== null && index >= 0 && index < selection.getItems().length) {\n        break;\n      }\n\n      target = getParent(target) as HTMLElement;\n    }\n\n    if (target === this._root.current) {\n      return undefined;\n    }\n\n    return target;\n  }\n\n  private _getItemIndex(itemRoot: HTMLElement): number {\n    return Number(itemRoot.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME));\n  }\n\n  private _shouldAutoSelect(element: HTMLElement): boolean {\n    return this._hasAttribute(element, SELECTION_SELECT_ATTRIBUTE_NAME);\n  }\n\n  private _hasAttribute(element: HTMLElement, attributeName: string): boolean {\n    let isToggle = false;\n\n    while (!isToggle && element !== this._root.current) {\n      isToggle = element.getAttribute(attributeName) === 'true';\n      element = getParent(element) as HTMLElement;\n    }\n\n    return isToggle;\n  }\n\n  private _isInputElement(element: HTMLElement): boolean {\n    return element.tagName === 'INPUT' || element.tagName === 'TEXTAREA';\n  }\n\n  private _isNonHandledClick(element: HTMLElement): boolean {\n    const doc = getDocument();\n\n    if (doc && element) {\n      while (element && element !== doc.documentElement) {\n        if (isElementTabbable(element)) {\n          return false;\n        }\n\n        element = getParent(element) as HTMLElement;\n      }\n    }\n\n    return true;\n  }\n\n  private _handleNextFocus(handleFocus: boolean): void {\n    if (this._shouldHandleFocusTimeoutId) {\n      this._async.clearTimeout(this._shouldHandleFocusTimeoutId);\n      this._shouldHandleFocusTimeoutId = undefined;\n    }\n\n    this._shouldHandleFocus = handleFocus;\n\n    if (handleFocus) {\n      this._async.setTimeout(() => {\n        this._shouldHandleFocus = false;\n      }, 100);\n    }\n  }\n\n  private _setIsTouch(isTouch: boolean): void {\n    if (this._isTouchTimeoutId) {\n      this._async.clearTimeout(this._isTouchTimeoutId);\n      this._isTouchTimeoutId = undefined;\n    }\n\n    this._isTouch = true;\n\n    if (isTouch) {\n      this._async.setTimeout(() => {\n        this._isTouch = false;\n      }, 300);\n    }\n  }\n\n  private _getSelectionMode(): SelectionMode {\n    const { selection } = this.props;\n\n    const { selectionMode = selection ? selection.mode : SelectionMode.none } = this.props;\n\n    return selectionMode;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}