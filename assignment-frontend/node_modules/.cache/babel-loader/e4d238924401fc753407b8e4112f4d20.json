{"ast":null,"code":"import { EventGroup, getDocument } from '../../Utilities';\nvar MOUSEDOWN_PRIMARY_BUTTON = 0; // for mouse down event we are using ev.button property, 0 means left button\n\nvar MOUSEMOVE_PRIMARY_BUTTON = 1; // for mouse move event we are using ev.buttons property, 1 means left button\n\nvar DragDropHelper =\n/** @class */\nfunction () {\n  function DragDropHelper(params) {\n    this._selection = params.selection;\n    this._dragEnterCounts = {};\n    this._activeTargets = {};\n    this._lastId = 0; // To make this class cheap to create, which allows simplifying some logic elsewhere,\n    // only initialize the event group and global event handlers as needed.\n\n    this._initialized = false;\n  }\n\n  DragDropHelper.prototype.dispose = function () {\n    if (this._events) {\n      this._events.dispose();\n    }\n  };\n\n  DragDropHelper.prototype.subscribe = function (root, events, dragDropOptions) {\n    var _this = this;\n\n    if (!this._initialized) {\n      this._events = new EventGroup(this);\n      var doc = getDocument(); // clear drag data when mouse up, use capture event to ensure it will be run\n\n      if (doc) {\n        this._events.on(doc.body, 'mouseup', this._onMouseUp.bind(this), true);\n\n        this._events.on(doc, 'mouseup', this._onDocumentMouseUp.bind(this), true);\n      }\n\n      this._initialized = true;\n    }\n\n    var _a = dragDropOptions.key,\n        key = _a === void 0 ? \"\" + ++this._lastId : _a;\n    var handlers = [];\n    var onDragStart;\n    var onDragLeave;\n    var onDragEnter;\n    var onDragEnd;\n    var onDrop;\n    var onDragOver;\n    var onMouseDown;\n    var isDraggable;\n    var isDroppable;\n    var activeTarget;\n\n    if (dragDropOptions && root) {\n      var eventMap = dragDropOptions.eventMap,\n          context = dragDropOptions.context,\n          updateDropState_1 = dragDropOptions.updateDropState;\n      var dragDropTarget = {\n        root: root,\n        options: dragDropOptions,\n        key: key\n      };\n      isDraggable = this._isDraggable(dragDropTarget);\n      isDroppable = this._isDroppable(dragDropTarget);\n\n      if (isDraggable || isDroppable) {\n        if (eventMap) {\n          for (var _i = 0, eventMap_1 = eventMap; _i < eventMap_1.length; _i++) {\n            var event_1 = eventMap_1[_i];\n            var handler = {\n              callback: event_1.callback.bind(null, context),\n              eventName: event_1.eventName\n            };\n            handlers.push(handler);\n\n            this._events.on(root, handler.eventName, handler.callback);\n          }\n        }\n      }\n\n      if (isDroppable) {\n        // If the target is droppable, wire up global event listeners to track drop-related events.\n        onDragLeave = function (event) {\n          if (!event.isHandled) {\n            event.isHandled = true;\n            _this._dragEnterCounts[key]--;\n\n            if (_this._dragEnterCounts[key] === 0) {\n              updateDropState_1(false\n              /* isDropping */\n              , event);\n            }\n          }\n        };\n\n        onDragEnter = function (event) {\n          event.preventDefault(); // needed for IE\n\n          if (!event.isHandled) {\n            event.isHandled = true;\n            _this._dragEnterCounts[key]++;\n\n            if (_this._dragEnterCounts[key] === 1) {\n              updateDropState_1(true\n              /* isDropping */\n              , event);\n            }\n          }\n        };\n\n        onDragEnd = function (event) {\n          _this._dragEnterCounts[key] = 0;\n          updateDropState_1(false\n          /* isDropping */\n          , event);\n        };\n\n        onDrop = function (event) {\n          _this._dragEnterCounts[key] = 0;\n          updateDropState_1(false\n          /* isDropping */\n          , event);\n\n          if (dragDropOptions.onDrop) {\n            dragDropOptions.onDrop(dragDropOptions.context.data, event);\n          }\n        };\n\n        onDragOver = function (event) {\n          event.preventDefault();\n\n          if (dragDropOptions.onDragOver) {\n            dragDropOptions.onDragOver(dragDropOptions.context.data, event);\n          }\n        };\n\n        this._dragEnterCounts[key] = 0; // dragenter and dragleave will be fired when hover to the child element\n        // but we only want to change state when enter or leave the current element\n        // use the count to ensure it.\n\n        events.on(root, 'dragenter', onDragEnter);\n        events.on(root, 'dragleave', onDragLeave);\n        events.on(root, 'dragend', onDragEnd);\n        events.on(root, 'drop', onDrop);\n        events.on(root, 'dragover', onDragOver);\n      }\n\n      if (isDraggable) {\n        // If the target is draggable, wire up local event listeners for mouse events.\n        onMouseDown = this._onMouseDown.bind(this, dragDropTarget);\n        onDragEnd = this._onDragEnd.bind(this, dragDropTarget); // We need to add in data so that on Firefox we show the ghost element when dragging\n\n        onDragStart = function (event) {\n          var options = dragDropOptions;\n\n          if (options && options.onDragStart) {\n            options.onDragStart(options.context.data, options.context.index, _this._selection.getSelection(), event);\n          }\n\n          _this._isDragging = true;\n\n          if (event.dataTransfer) {\n            event.dataTransfer.setData('id', root.id);\n          }\n        };\n\n        events.on(root, 'dragstart', onDragStart);\n        events.on(root, 'mousedown', onMouseDown);\n        events.on(root, 'dragend', onDragEnd);\n      }\n\n      activeTarget = {\n        target: dragDropTarget,\n        dispose: function () {\n          if (_this._activeTargets[key] === activeTarget) {\n            delete _this._activeTargets[key];\n          }\n\n          if (root) {\n            for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {\n              var handler = handlers_1[_i];\n\n              _this._events.off(root, handler.eventName, handler.callback);\n            }\n\n            if (isDroppable) {\n              events.off(root, 'dragenter', onDragEnter);\n              events.off(root, 'dragleave', onDragLeave);\n              events.off(root, 'dragend', onDragEnd);\n              events.off(root, 'dragover', onDragOver);\n              events.off(root, 'drop', onDrop);\n            }\n\n            if (isDraggable) {\n              events.off(root, 'dragstart', onDragStart);\n              events.off(root, 'mousedown', onMouseDown);\n              events.off(root, 'dragend', onDragEnd);\n            }\n          }\n        }\n      };\n      this._activeTargets[key] = activeTarget;\n    }\n\n    return {\n      key: key,\n      dispose: function () {\n        if (activeTarget) {\n          activeTarget.dispose();\n        }\n      }\n    };\n  };\n\n  DragDropHelper.prototype.unsubscribe = function (root, key) {\n    var activeTarget = this._activeTargets[key];\n\n    if (activeTarget) {\n      activeTarget.dispose();\n    }\n  };\n\n  DragDropHelper.prototype._onDragEnd = function (target, event) {\n    var options = target.options;\n\n    if (options.onDragEnd) {\n      options.onDragEnd(options.context.data, event);\n    }\n  };\n  /**\n   * clear drag data when mouse up on body\n   */\n\n\n  DragDropHelper.prototype._onMouseUp = function (event) {\n    this._isDragging = false;\n\n    if (this._dragData) {\n      for (var _i = 0, _a = Object.keys(this._activeTargets); _i < _a.length; _i++) {\n        var key = _a[_i];\n        var activeTarget = this._activeTargets[key];\n\n        if (activeTarget.target.root) {\n          this._events.off(activeTarget.target.root, 'mousemove');\n\n          this._events.off(activeTarget.target.root, 'mouseleave');\n        }\n      }\n\n      if (this._dragData.dropTarget) {\n        // raise dragleave event to let dropTarget know it need to remove dropping style\n        EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n        EventGroup.raise(this._dragData.dropTarget.root, 'drop');\n      }\n    }\n\n    this._dragData = null;\n  };\n  /**\n   * clear drag data when mouse up outside of the document\n   */\n\n\n  DragDropHelper.prototype._onDocumentMouseUp = function (event) {\n    var doc = getDocument();\n\n    if (doc && event.target === doc.documentElement) {\n      this._onMouseUp(event);\n    }\n  };\n  /**\n   * when mouse move over a new drop target while dragging some items,\n   * fire dragleave on the old target and fire dragenter to the new target\n   * The target will handle style change on dragenter and dragleave events.\n   */\n\n\n  DragDropHelper.prototype._onMouseMove = function (target, event) {\n    var // use buttons property here since ev.button in some edge case is not updating well during the move.\n    // but firefox doesn't support it, so we set the default value when it is not defined.\n    _a = event.buttons,\n        // use buttons property here since ev.button in some edge case is not updating well during the move.\n    // but firefox doesn't support it, so we set the default value when it is not defined.\n    buttons = _a === void 0 ? MOUSEMOVE_PRIMARY_BUTTON : _a;\n\n    if (this._dragData && buttons !== MOUSEMOVE_PRIMARY_BUTTON) {\n      // cancel mouse down event and return early when the primary button is not pressed\n      this._onMouseUp(event);\n\n      return;\n    }\n\n    var root = target.root,\n        key = target.key;\n\n    if (this._isDragging) {\n      if (this._isDroppable(target)) {\n        // we can have nested drop targets in the DOM, like a folder inside a group. In that case, when we drag into\n        // the inner target (folder), we first set dropTarget to the inner element. But the same event is bubbled to the\n        // outer target too, and we need to prevent the outer one from taking over.\n        // So, check if the last dropTarget is not a child of the current.\n        if (this._dragData) {\n          if (this._dragData.dropTarget && this._dragData.dropTarget.key !== key && !this._isChild(root, this._dragData.dropTarget.root)) {\n            if (this._dragEnterCounts[this._dragData.dropTarget.key] > 0) {\n              EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n              EventGroup.raise(root, 'dragenter');\n              this._dragData.dropTarget = target;\n            }\n          }\n        }\n      }\n    }\n  };\n  /**\n   * when mouse leave a target while dragging some items, fire dragleave to the target\n   */\n\n\n  DragDropHelper.prototype._onMouseLeave = function (target, event) {\n    if (this._isDragging) {\n      if (this._dragData && this._dragData.dropTarget && this._dragData.dropTarget.key === target.key) {\n        EventGroup.raise(target.root, 'dragleave');\n        this._dragData.dropTarget = undefined;\n      }\n    }\n  };\n  /**\n   * when mouse down on a draggable item, we start to track dragdata.\n   */\n\n\n  DragDropHelper.prototype._onMouseDown = function (target, event) {\n    if (event.button !== MOUSEDOWN_PRIMARY_BUTTON) {\n      // Ignore anything except the primary button.\n      return;\n    }\n\n    if (this._isDraggable(target)) {\n      this._dragData = {\n        clientX: event.clientX,\n        clientY: event.clientY,\n        eventTarget: event.target,\n        dragTarget: target\n      };\n\n      for (var _i = 0, _a = Object.keys(this._activeTargets); _i < _a.length; _i++) {\n        var key = _a[_i];\n        var activeTarget = this._activeTargets[key];\n\n        if (activeTarget.target.root) {\n          this._events.on(activeTarget.target.root, 'mousemove', this._onMouseMove.bind(this, activeTarget.target));\n\n          this._events.on(activeTarget.target.root, 'mouseleave', this._onMouseLeave.bind(this, activeTarget.target));\n        }\n      }\n    } else {\n      this._dragData = null;\n    }\n  };\n  /**\n   * determine whether the child target is a descendant of the parent\n   */\n\n\n  DragDropHelper.prototype._isChild = function (parentElement, childElement) {\n    while (childElement && childElement.parentElement) {\n      if (childElement.parentElement === parentElement) {\n        return true;\n      }\n\n      childElement = childElement.parentElement;\n    }\n\n    return false;\n  };\n\n  DragDropHelper.prototype._isDraggable = function (target) {\n    var options = target.options;\n    return !!(options.canDrag && options.canDrag(options.context.data));\n  };\n\n  DragDropHelper.prototype._isDroppable = function (target) {\n    // TODO: take the drag item into consideration to prevent dragging an item into the same group\n    var options = target.options;\n    var dragContext = this._dragData && this._dragData.dragTarget ? this._dragData.dragTarget.options.context : undefined;\n    return !!(options.canDrop && options.canDrop(options.context, dragContext));\n  };\n\n  return DragDropHelper;\n}();\n\nexport { DragDropHelper };","map":{"version":3,"sources":["utilities/dragdrop/DragDropHelper.tsx"],"names":[],"mappings":"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","sourcesContent":["import { EventGroup, getDocument } from '../../Utilities';\nimport { IDragDropHelper, IDragDropTarget, IDragDropOptions, IDragDropEvent, IDragDropContext } from './interfaces';\nimport { ISelection } from '../../utilities/selection/interfaces';\n\nconst MOUSEDOWN_PRIMARY_BUTTON = 0; // for mouse down event we are using ev.button property, 0 means left button\nconst MOUSEMOVE_PRIMARY_BUTTON = 1; // for mouse move event we are using ev.buttons property, 1 means left button\n\nexport interface IDragDropHelperParams {\n  selection: ISelection;\n  minimumPixelsForDrag?: number;\n}\n\nexport class DragDropHelper implements IDragDropHelper {\n  private _dragEnterCounts: { [key: string]: number };\n  private _isDragging: boolean;\n  private _dragData: {\n    eventTarget: EventTarget | null;\n    clientX: number;\n    clientY: number;\n    dataTransfer?: DataTransfer;\n    dropTarget?: IDragDropTarget;\n    dragTarget?: IDragDropTarget;\n  } | null;\n  private _selection: ISelection;\n  private _activeTargets: {\n    [key: string]: {\n      target: IDragDropTarget;\n      dispose: () => void;\n    };\n  };\n  private _events: EventGroup;\n  private _lastId: number;\n  private _initialized: boolean;\n\n  constructor(params: IDragDropHelperParams) {\n    this._selection = params.selection;\n    this._dragEnterCounts = {};\n    this._activeTargets = {};\n    this._lastId = 0;\n    // To make this class cheap to create, which allows simplifying some logic elsewhere,\n    // only initialize the event group and global event handlers as needed.\n    this._initialized = false;\n  }\n\n  public dispose(): void {\n    if (this._events) {\n      this._events.dispose();\n    }\n  }\n\n  public subscribe(\n    root: HTMLElement,\n    events: EventGroup,\n    dragDropOptions: IDragDropOptions,\n  ): {\n    key: string;\n    dispose(): void;\n  } {\n    if (!this._initialized) {\n      this._events = new EventGroup(this);\n\n      const doc = getDocument();\n\n      // clear drag data when mouse up, use capture event to ensure it will be run\n      if (doc) {\n        this._events.on(doc.body, 'mouseup', this._onMouseUp.bind(this), true);\n        this._events.on(doc, 'mouseup', this._onDocumentMouseUp.bind(this), true);\n      }\n\n      this._initialized = true;\n    }\n\n    const { key = `${++this._lastId}` } = dragDropOptions;\n\n    const handlers: {\n      callback: (context: IDragDropContext, event?: any) => void;\n      eventName: string;\n    }[] = [];\n\n    let onDragStart: (event: DragEvent) => void;\n    let onDragLeave: (event: DragEvent) => void;\n    let onDragEnter: (event: DragEvent) => void;\n    let onDragEnd: (event: DragEvent) => void;\n    let onDrop: (event: DragEvent) => void;\n    let onDragOver: (event: DragEvent) => void;\n    let onMouseDown: (event: MouseEvent) => void;\n\n    let isDraggable: boolean;\n    let isDroppable: boolean;\n\n    let activeTarget: {\n      target: IDragDropTarget;\n      dispose: () => void;\n    };\n\n    if (dragDropOptions && root) {\n      const { eventMap, context, updateDropState } = dragDropOptions;\n\n      const dragDropTarget: IDragDropTarget = {\n        root: root,\n        options: dragDropOptions,\n        key: key,\n      };\n\n      isDraggable = this._isDraggable(dragDropTarget);\n      isDroppable = this._isDroppable(dragDropTarget);\n\n      if (isDraggable || isDroppable) {\n        if (eventMap) {\n          for (const event of eventMap) {\n            const handler = {\n              callback: event.callback.bind(null, context),\n              eventName: event.eventName,\n            };\n\n            handlers.push(handler);\n\n            this._events.on(root, handler.eventName, handler.callback);\n          }\n        }\n      }\n\n      if (isDroppable) {\n        // If the target is droppable, wire up global event listeners to track drop-related events.\n        onDragLeave = (event: DragEvent) => {\n          if (!(event as IDragDropEvent).isHandled) {\n            (event as IDragDropEvent).isHandled = true;\n            this._dragEnterCounts[key]--;\n            if (this._dragEnterCounts[key] === 0) {\n              updateDropState(false /* isDropping */, event);\n            }\n          }\n        };\n\n        onDragEnter = (event: DragEvent) => {\n          event.preventDefault(); // needed for IE\n          if (!(event as IDragDropEvent).isHandled) {\n            (event as IDragDropEvent).isHandled = true;\n            this._dragEnterCounts[key]++;\n            if (this._dragEnterCounts[key] === 1) {\n              updateDropState(true /* isDropping */, event);\n            }\n          }\n        };\n\n        onDragEnd = (event: DragEvent) => {\n          this._dragEnterCounts[key] = 0;\n          updateDropState(false /* isDropping */, event);\n        };\n\n        onDrop = (event: DragEvent) => {\n          this._dragEnterCounts[key] = 0;\n          updateDropState(false /* isDropping */, event);\n\n          if (dragDropOptions.onDrop) {\n            dragDropOptions.onDrop(dragDropOptions.context.data, event);\n          }\n        };\n\n        onDragOver = (event: DragEvent) => {\n          event.preventDefault();\n          if (dragDropOptions.onDragOver) {\n            dragDropOptions.onDragOver(dragDropOptions.context.data, event);\n          }\n        };\n\n        this._dragEnterCounts[key] = 0;\n\n        // dragenter and dragleave will be fired when hover to the child element\n        // but we only want to change state when enter or leave the current element\n        // use the count to ensure it.\n        events.on(root, 'dragenter', onDragEnter);\n        events.on(root, 'dragleave', onDragLeave);\n        events.on(root, 'dragend', onDragEnd);\n        events.on(root, 'drop', onDrop);\n        events.on(root, 'dragover', onDragOver);\n      }\n\n      if (isDraggable) {\n        // If the target is draggable, wire up local event listeners for mouse events.\n        onMouseDown = this._onMouseDown.bind(this, dragDropTarget);\n        onDragEnd = this._onDragEnd.bind(this, dragDropTarget);\n\n        // We need to add in data so that on Firefox we show the ghost element when dragging\n        onDragStart = (event: DragEvent) => {\n          const options = dragDropOptions;\n          if (options && options.onDragStart) {\n            options.onDragStart(options.context.data, options.context.index, this._selection.getSelection(), event);\n          }\n          this._isDragging = true;\n          if (event.dataTransfer) {\n            event.dataTransfer.setData('id', root.id);\n          }\n        };\n\n        events.on(root, 'dragstart', onDragStart);\n        events.on(root, 'mousedown', onMouseDown);\n        events.on(root, 'dragend', onDragEnd);\n      }\n\n      activeTarget = {\n        target: dragDropTarget,\n        dispose: () => {\n          if (this._activeTargets[key] === activeTarget) {\n            delete this._activeTargets[key];\n          }\n\n          if (root) {\n            for (const handler of handlers) {\n              this._events.off(root, handler.eventName, handler.callback);\n            }\n\n            if (isDroppable) {\n              events.off(root, 'dragenter', onDragEnter);\n              events.off(root, 'dragleave', onDragLeave);\n              events.off(root, 'dragend', onDragEnd);\n              events.off(root, 'dragover', onDragOver);\n              events.off(root, 'drop', onDrop);\n            }\n\n            if (isDraggable) {\n              events.off(root, 'dragstart', onDragStart);\n              events.off(root, 'mousedown', onMouseDown);\n              events.off(root, 'dragend', onDragEnd);\n            }\n          }\n        },\n      };\n\n      this._activeTargets[key] = activeTarget;\n    }\n\n    return {\n      key: key,\n      dispose: () => {\n        if (activeTarget) {\n          activeTarget.dispose();\n        }\n      },\n    };\n  }\n\n  public unsubscribe(root: HTMLElement, key: string): void {\n    const activeTarget = this._activeTargets[key];\n\n    if (activeTarget) {\n      activeTarget.dispose();\n    }\n  }\n\n  private _onDragEnd(target: IDragDropTarget, event: DragEvent): void {\n    const { options } = target;\n    if (options.onDragEnd) {\n      options.onDragEnd(options.context.data, event);\n    }\n  }\n\n  /**\n   * clear drag data when mouse up on body\n   */\n  private _onMouseUp(event: MouseEvent): void {\n    this._isDragging = false;\n    if (this._dragData) {\n      for (const key of Object.keys(this._activeTargets)) {\n        const activeTarget = this._activeTargets[key];\n\n        if (activeTarget.target.root) {\n          this._events.off(activeTarget.target.root, 'mousemove');\n          this._events.off(activeTarget.target.root, 'mouseleave');\n        }\n      }\n\n      if (this._dragData.dropTarget) {\n        // raise dragleave event to let dropTarget know it need to remove dropping style\n        EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n        EventGroup.raise(this._dragData.dropTarget.root, 'drop');\n      }\n    }\n    this._dragData = null;\n  }\n\n  /**\n   * clear drag data when mouse up outside of the document\n   */\n  private _onDocumentMouseUp(event: MouseEvent): void {\n    const doc = getDocument();\n\n    if (doc && event.target === doc.documentElement) {\n      this._onMouseUp(event);\n    }\n  }\n\n  /**\n   * when mouse move over a new drop target while dragging some items,\n   * fire dragleave on the old target and fire dragenter to the new target\n   * The target will handle style change on dragenter and dragleave events.\n   */\n  private _onMouseMove(target: IDragDropTarget, event: MouseEvent): void {\n    const {\n      // use buttons property here since ev.button in some edge case is not updating well during the move.\n      // but firefox doesn't support it, so we set the default value when it is not defined.\n      buttons = MOUSEMOVE_PRIMARY_BUTTON,\n    } = event;\n\n    if (this._dragData && buttons !== MOUSEMOVE_PRIMARY_BUTTON) {\n      // cancel mouse down event and return early when the primary button is not pressed\n      this._onMouseUp(event);\n      return;\n    }\n\n    const { root, key } = target;\n    if (this._isDragging) {\n      if (this._isDroppable(target)) {\n        // we can have nested drop targets in the DOM, like a folder inside a group. In that case, when we drag into\n        // the inner target (folder), we first set dropTarget to the inner element. But the same event is bubbled to the\n        // outer target too, and we need to prevent the outer one from taking over.\n        // So, check if the last dropTarget is not a child of the current.\n\n        if (this._dragData) {\n          if (\n            this._dragData.dropTarget &&\n            this._dragData.dropTarget.key !== key &&\n            !this._isChild(root, this._dragData.dropTarget.root)\n          ) {\n            if (this._dragEnterCounts[this._dragData.dropTarget.key] > 0) {\n              EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n              EventGroup.raise(root, 'dragenter');\n              this._dragData.dropTarget = target;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * when mouse leave a target while dragging some items, fire dragleave to the target\n   */\n  private _onMouseLeave(target: IDragDropTarget, event: MouseEvent): void {\n    if (this._isDragging) {\n      if (this._dragData && this._dragData.dropTarget && this._dragData.dropTarget.key === target.key) {\n        EventGroup.raise(target.root, 'dragleave');\n        this._dragData.dropTarget = undefined;\n      }\n    }\n  }\n\n  /**\n   * when mouse down on a draggable item, we start to track dragdata.\n   */\n  private _onMouseDown(target: IDragDropTarget, event: MouseEvent): void {\n    if (event.button !== MOUSEDOWN_PRIMARY_BUTTON) {\n      // Ignore anything except the primary button.\n      return;\n    }\n\n    if (this._isDraggable(target)) {\n      this._dragData = {\n        clientX: event.clientX,\n        clientY: event.clientY,\n        eventTarget: event.target,\n        dragTarget: target,\n      };\n\n      for (const key of Object.keys(this._activeTargets)) {\n        const activeTarget = this._activeTargets[key];\n        if (activeTarget.target.root) {\n          this._events.on(activeTarget.target.root, 'mousemove', this._onMouseMove.bind(this, activeTarget.target));\n          this._events.on(activeTarget.target.root, 'mouseleave', this._onMouseLeave.bind(this, activeTarget.target));\n        }\n      }\n    } else {\n      this._dragData = null;\n    }\n  }\n\n  /**\n   * determine whether the child target is a descendant of the parent\n   */\n  private _isChild(parentElement: HTMLElement, childElement: HTMLElement): boolean {\n    while (childElement && childElement.parentElement) {\n      if (childElement.parentElement === parentElement) {\n        return true;\n      }\n      childElement = childElement.parentElement;\n    }\n    return false;\n  }\n\n  private _isDraggable(target: IDragDropTarget): boolean {\n    const { options } = target;\n    return !!(options.canDrag && options.canDrag(options.context.data));\n  }\n\n  private _isDroppable(target: IDragDropTarget): boolean {\n    // TODO: take the drag item into consideration to prevent dragging an item into the same group\n    const { options } = target;\n    const dragContext =\n      this._dragData && this._dragData.dragTarget ? this._dragData.dragTarget.options.context : undefined;\n    return !!(options.canDrop && options.canDrop(options.context, dragContext));\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}