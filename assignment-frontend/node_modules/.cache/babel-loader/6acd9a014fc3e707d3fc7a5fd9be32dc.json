{"ast":null,"code":"import { __assign, __decorate, __extends, __spreadArrays } from \"tslib\";\nimport * as React from 'react';\nimport { ContextualMenuItemType } from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, FocusZoneTabbableElements } from '../../FocusZone';\nimport { divProperties, getNativeProps, shallowCompare, warnDeprecations, Async, EventGroup, assign, classNamesFunction, css, getDocument, getFirstFocusable, getId, getLastFocusable, getRTL, getWindow, KeyCodes, shouldWrapFocus, isIOS, isMac, initializeComponentRef, memoizeFunction } from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { Callout } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport { ContextualMenuSplitButton, ContextualMenuButton, ContextualMenuAnchor } from './ContextualMenuItemWrapper/index';\nimport { concatStyleSetsWithProps } from '../../Styling';\nimport { getItemStyles } from './ContextualMenu.classNames';\nvar getClassNames = classNamesFunction();\nvar getContextualMenuItemClassNames = classNamesFunction();\nexport function getSubmenuItems(item) {\n  return item.subMenuProps ? item.subMenuProps.items : item.items;\n}\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\n\nexport function canAnyMenuItemsCheck(items) {\n  return items.some(function (item) {\n    if (item.canCheck) {\n      return true;\n    } // If the item is a section, check if any of the items in the section can check.\n\n\n    if (item.sectionProps && item.sectionProps.items.some(function (submenuItem) {\n      return submenuItem.canCheck === true;\n    })) {\n      return true;\n    }\n\n    return false;\n  });\n}\nvar NavigationIdleDelay = 250;\n/* ms */\n\nvar COMPONENT_NAME = 'ContextualMenu';\n\nvar _getMenuItemStylesFunction = memoizeFunction(function () {\n  var styles = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    styles[_i] = arguments[_i];\n  }\n\n  return function (styleProps) {\n    return concatStyleSetsWithProps.apply(void 0, __spreadArrays([styleProps, getItemStyles], styles));\n  };\n});\n\nvar ContextualMenuBase =\n/** @class */\nfunction (_super) {\n  __extends(ContextualMenuBase, _super);\n\n  function ContextualMenuBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._mounted = false;\n\n    _this.dismiss = function (ev, dismissAll) {\n      var onDismiss = _this.props.onDismiss;\n\n      if (onDismiss) {\n        onDismiss(ev, dismissAll);\n      }\n    };\n\n    _this._tryFocusPreviousActiveElement = function (options) {\n      if (_this.props.onRestoreFocus) {\n        _this.props.onRestoreFocus(options);\n      } else {\n        if (options && options.containsFocus && _this._previousActiveElement) {\n          // Make sure that the focus method actually exists\n          // In some cases the object might exist but not be a real element.\n          // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n          if (_this._previousActiveElement.focus) {\n            _this._previousActiveElement.focus();\n          }\n        }\n      }\n    };\n\n    _this._onRenderMenuList = function (menuListProps, defaultRender) {\n      var indexCorrection = 0;\n      var items = menuListProps.items,\n          totalItemCount = menuListProps.totalItemCount,\n          hasCheckmarks = menuListProps.hasCheckmarks,\n          hasIcons = menuListProps.hasIcons,\n          role = menuListProps.role;\n      return React.createElement(\"ul\", {\n        className: _this._classNames.list,\n        onKeyDown: _this._onKeyDown,\n        onKeyUp: _this._onKeyUp,\n        role: role !== null && role !== void 0 ? role : 'menu'\n      }, items.map(function (item, index) {\n        var menuItem = _this._renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks, hasIcons);\n\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          var indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          indexCorrection += indexIncrease;\n        }\n\n        return menuItem;\n      }));\n    };\n    /**\n     * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n     * cause the menu items to always re-render because the component update is based on shallow comparison.\n     */\n\n\n    _this._renderMenuItem = function (item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n      var _a;\n\n      var renderedItems = [];\n      var iconProps = item.iconProps || {\n        iconName: 'None'\n      };\n      var getItemClassNames = item.getItemClassNames,\n          // eslint-disable-line deprecation/deprecation\n      itemProps = item.itemProps;\n      var styles = itemProps ? itemProps.styles : undefined; // We only send a dividerClassName when the item to be rendered is a divider.\n      // For all other cases, the default divider style is used.\n\n      var dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n      var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : ''; // eslint-disable-next-line deprecation/deprecation\n\n      var itemClassNames; // IContextualMenuItem#getItemClassNames for backwards compatibility\n      // otherwise uses mergeStyles for class names.\n\n      if (getItemClassNames) {\n        itemClassNames = getItemClassNames(_this.props.theme, isItemDisabled(item), _this.state.expandedMenuItemKey === item.key, !!getIsChecked(item), !!item.href, iconProps.iconName !== 'None', item.className, dividerClassName, iconProps.className, subMenuIconClassName, item.primaryDisabled);\n      } else {\n        var itemStyleProps = {\n          theme: _this.props.theme,\n          disabled: isItemDisabled(item),\n          expanded: _this.state.expandedMenuItemKey === item.key,\n          checked: !!getIsChecked(item),\n          isAnchorLink: !!item.href,\n          knownIcon: iconProps.iconName !== 'None',\n          itemClassName: item.className,\n          dividerClassName: dividerClassName,\n          iconClassName: iconProps.className,\n          subMenuClassName: subMenuIconClassName,\n          primaryDisabled: item.primaryDisabled\n        }; // We need to generate default styles then override if styles are provided\n        // since the ContextualMenu currently handles item classNames.\n\n        itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a = _this._classNames.subComponentStyles) === null || _a === void 0 ? void 0 : _a.menuItem, styles), itemStyleProps);\n      } // eslint-disable-next-line deprecation/deprecation\n\n\n      if (item.text === '-' || item.name === '-') {\n        item.itemType = ContextualMenuItemType.Divider;\n      }\n\n      switch (item.itemType) {\n        case ContextualMenuItemType.Divider:\n          renderedItems.push(_this._renderSeparator(index, itemClassNames));\n          break;\n\n        case ContextualMenuItemType.Header:\n          renderedItems.push(_this._renderSeparator(index, itemClassNames));\n\n          var headerItem = _this._renderHeaderMenuItem(item, itemClassNames, index, hasCheckmarks, hasIcons);\n\n          renderedItems.push(_this._renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n          break;\n\n        case ContextualMenuItemType.Section:\n          renderedItems.push(_this._renderSectionItem(item, itemClassNames, index, hasCheckmarks, hasIcons));\n          break;\n\n        default:\n          var menuItem = _this._renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n\n          renderedItems.push(_this._renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n          break;\n      } // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n      // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n\n\n      return React.createElement(React.Fragment, {\n        key: item.key\n      }, renderedItems);\n    };\n\n    _this._defaultMenuItemRenderer = function (item) {\n      var index = item.index,\n          focusableElementIndex = item.focusableElementIndex,\n          totalItemCount = item.totalItemCount,\n          hasCheckmarks = item.hasCheckmarks,\n          hasIcons = item.hasIcons;\n      return _this._renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    };\n\n    _this._onKeyDown = function (ev) {\n      // Take note if we are processing an alt (option) or meta (command) keydown.\n      // See comment in _shouldHandleKeyUp for reasoning.\n      _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev); // On Mac, pressing escape dismisses all levels of native context menus\n\n      var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n      return _this._keyHandler(ev, _this._shouldHandleKeyDown, dismissAllMenus);\n    };\n\n    _this._shouldHandleKeyDown = function (ev) {\n      return ev.which === KeyCodes.escape || _this._shouldCloseSubMenu(ev) || ev.which === KeyCodes.up && (ev.altKey || ev.metaKey);\n    };\n\n    _this._onMenuFocusCapture = function (ev) {\n      if (_this.props.delayUpdateFocusOnHover) {\n        _this._shouldUpdateFocusOnMouseEvent = true;\n      }\n    };\n\n    _this._onKeyUp = function (ev) {\n      return _this._keyHandler(ev, _this._shouldHandleKeyUp, true\n      /* dismissAllMenus */\n      );\n    };\n    /**\n     * We close the menu on key up only if ALL of the following are true:\n     * - Most recent key down was alt or meta (command)\n     * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n     *   expand/collapse the menu)\n     * - We're not on a Mac (or iOS)\n     *\n     * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n     * closing any open context menus. There is not a similar behavior on Macs.\n     */\n\n\n    _this._shouldHandleKeyUp = function (ev) {\n      var keyPressIsAltOrMetaAlone = _this._lastKeyDownWasAltOrMeta && _this._isAltOrMeta(ev);\n\n      _this._lastKeyDownWasAltOrMeta = false;\n      return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n    };\n    /**\n     * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n     * if so, stops event propagation and dismisses menu(s).\n     * @param ev - The keyboard event.\n     * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n     * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n     * Only does anything if `shouldHandleKey` returns true.\n     * @returns Whether the event was handled.\n     */\n\n\n    _this._keyHandler = function (ev, shouldHandleKey, dismissAllMenus) {\n      var handled = false;\n\n      if (shouldHandleKey(ev)) {\n        _this._focusingPreviousElement = true;\n\n        _this.dismiss(ev, dismissAllMenus);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n        handled = true;\n      }\n\n      return handled;\n    };\n    /**\n     * Checks if the submenu should be closed\n     */\n\n\n    _this._shouldCloseSubMenu = function (ev) {\n      var submenuCloseKey = getRTL(_this.props.theme) ? KeyCodes.right : KeyCodes.left;\n\n      if (ev.which !== submenuCloseKey || !_this.props.isSubMenu) {\n        return false;\n      }\n\n      return _this._adjustedFocusZoneProps.direction === FocusZoneDirection.vertical || !!_this._adjustedFocusZoneProps.checkForNoWrap && !shouldWrapFocus(ev.target, 'data-no-horizontal-wrap');\n    };\n\n    _this._onMenuKeyDown = function (ev) {\n      // Mark as handled if onKeyDown returns true (for handling collapse cases)\n      // or if we are attempting to expand a submenu\n      var handled = _this._onKeyDown(ev);\n\n      if (handled || !_this._host) {\n        return;\n      } // If we have a modifier key being pressed, we do not want to move focus.\n      // Otherwise, handle up and down keys.\n\n\n      var hasModifier = !!(ev.altKey || ev.metaKey);\n      var isUp = ev.which === KeyCodes.up;\n      var isDown = ev.which === KeyCodes.down;\n\n      if (!hasModifier && (isUp || isDown)) {\n        var elementToFocus = isUp ? getLastFocusable(_this._host, _this._host.lastChild, true) : getFirstFocusable(_this._host, _this._host.firstChild, true);\n\n        if (elementToFocus) {\n          elementToFocus.focus();\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n    /**\n     * Scroll handler for the callout to make sure the mouse events\n     * for updating focus are not interacting during scroll\n     */\n\n\n    _this._onScroll = function () {\n      if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== undefined) {\n        _this._async.clearTimeout(_this._scrollIdleTimeoutId);\n\n        _this._scrollIdleTimeoutId = undefined;\n      } else {\n        _this._isScrollIdle = false;\n      }\n\n      _this._scrollIdleTimeoutId = _this._async.setTimeout(function () {\n        _this._isScrollIdle = true;\n      }, NavigationIdleDelay);\n    };\n\n    _this._onItemMouseEnterBase = function (item, ev, target) {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      }\n\n      _this._updateFocusOnMouseEvent(item, ev, target);\n    };\n\n    _this._onItemMouseMoveBase = function (item, ev, target) {\n      var targetElement = ev.currentTarget; // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n\n      if (_this._shouldUpdateFocusOnMouseEvent) {\n        _this._gotMouseMove = true;\n      } else {\n        return;\n      }\n\n      if (!_this._isScrollIdle || _this._enterTimerId !== undefined || targetElement === _this._targetWindow.document.activeElement) {\n        return;\n      }\n\n      _this._updateFocusOnMouseEvent(item, ev, target);\n    };\n\n    _this._onMouseItemLeave = function (item, ev) {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      }\n\n      if (_this._enterTimerId !== undefined) {\n        _this._async.clearTimeout(_this._enterTimerId);\n\n        _this._enterTimerId = undefined;\n      }\n\n      if (_this.state.expandedMenuItemKey !== undefined) {\n        return;\n      }\n      /**\n       * IE11 focus() method forces parents to scroll to top of element.\n       * Edge and IE expose a setActive() function for focusable divs that\n       * sets the page focus but does not scroll the parent element.\n       */\n\n\n      if (_this._host.setActive) {\n        try {\n          _this._host.setActive();\n        } catch (e) {\n          /* no-op */\n        }\n      } else {\n        _this._host.focus();\n      }\n    };\n\n    _this._onItemMouseDown = function (item, ev) {\n      if (item.onMouseDown) {\n        item.onMouseDown(item, ev);\n      }\n    };\n\n    _this._onItemClick = function (item, ev) {\n      _this._onItemClickBase(item, ev, ev.currentTarget);\n    };\n\n    _this._onItemClickBase = function (item, ev, target) {\n      var items = getSubmenuItems(item); // Cancel a async menu item hover timeout action from being taken and instead\n      // just trigger the click event instead.\n\n      _this._cancelSubMenuTimer();\n\n      if (!hasSubmenu(item) && (!items || !items.length)) {\n        // This is an item without a menu. Click it.\n        _this._executeItemClick(item, ev);\n      } else {\n        if (item.key !== _this.state.expandedMenuItemKey) {\n          // This has a collapsed sub menu. Expand it.\n          _this.setState({\n            // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n            // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n            // between a real click event and a keypress event (detail should be the number of mouse clicks).\n            // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n            // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n            // and \"\" for pressing \"Enter\" with Narrator on.\n            expandedByMouseClick: ev.nativeEvent.detail !== 0 || ev.nativeEvent.pointerType === 'mouse'\n          });\n\n          _this._onItemSubMenuExpand(item, target);\n        }\n      }\n\n      ev.stopPropagation();\n      ev.preventDefault();\n    };\n\n    _this._onAnchorClick = function (item, ev) {\n      _this._executeItemClick(item, ev);\n\n      ev.stopPropagation();\n    };\n\n    _this._executeItemClick = function (item, ev) {\n      if (item.disabled || item.isDisabled) {\n        return;\n      }\n\n      var dismiss = false;\n\n      if (item.onClick) {\n        dismiss = !!item.onClick(ev, item);\n      } else if (_this.props.onItemClick) {\n        dismiss = !!_this.props.onItemClick(ev, item);\n      }\n\n      if (dismiss || !ev.defaultPrevented) {\n        _this.dismiss(ev, true); // This should be removed whenever possible.\n        // This ensures that the hidden dismissal action maintains the same behavior.\n        // If the menu is being dismissed then the previously focused element should\n        // get focused since the dismiss was triggered by a user click on an item\n        // Rather than focus being lost.\n\n\n        _this._focusingPreviousElement = true;\n      }\n    };\n\n    _this._onItemKeyDown = function (item, ev) {\n      var openKey = getRTL(_this.props.theme) ? KeyCodes.left : KeyCodes.right;\n\n      if (!item.disabled && (ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {\n        _this.setState({\n          expandedByMouseClick: false\n        });\n\n        _this._onItemSubMenuExpand(item, ev.currentTarget);\n\n        ev.preventDefault();\n      }\n    }; // Cancel a async menu item hover timeout action from being taken and instead\n    // do new upcoming behavior\n\n\n    _this._cancelSubMenuTimer = function () {\n      if (_this._enterTimerId !== undefined) {\n        _this._async.clearTimeout(_this._enterTimerId);\n\n        _this._enterTimerId = undefined;\n      }\n    };\n\n    _this._onItemSubMenuExpand = function (item, target) {\n      if (_this.state.expandedMenuItemKey !== item.key) {\n        if (_this.state.expandedMenuItemKey) {\n          _this._onSubMenuDismiss();\n        } // Focus the target to ensure when we close it, we're focusing on the correct element.\n\n\n        target.focus();\n\n        _this.setState({\n          expandedMenuItemKey: item.key,\n          submenuTarget: target\n        });\n      }\n    };\n    /**\n     * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n     * after the component is unmounted. The _mounted property is added to prevent\n     * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n     * code.\n     */\n\n\n    _this._onSubMenuDismiss = function (ev, dismissAll) {\n      if (dismissAll) {\n        _this.dismiss(ev, dismissAll);\n      } else if (_this._mounted) {\n        _this.setState({\n          dismissedMenuItemKey: _this.state.expandedMenuItemKey,\n          expandedMenuItemKey: undefined,\n          submenuTarget: undefined\n        });\n      }\n    };\n\n    _this._getSubMenuId = function (item) {\n      var subMenuId = _this.state.subMenuId;\n\n      if (item.subMenuProps && item.subMenuProps.id) {\n        subMenuId = item.subMenuProps.id;\n      }\n\n      return subMenuId;\n    };\n\n    _this._onPointerAndTouchEvent = function (ev) {\n      _this._cancelSubMenuTimer();\n    };\n\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    initializeComponentRef(_this);\n    warnDeprecations(COMPONENT_NAME, props, {\n      getMenuClassNames: 'styles'\n    });\n    _this.state = {\n      contextualMenuItems: undefined,\n      subMenuId: getId('ContextualMenu')\n    };\n    _this._id = props.id || getId('ContextualMenu');\n    _this._focusingPreviousElement = false;\n    _this._isScrollIdle = true;\n    _this._shouldUpdateFocusOnMouseEvent = !_this.props.delayUpdateFocusOnHover;\n    _this._gotMouseMove = false;\n    return _this;\n  }\n\n  ContextualMenuBase.prototype.shouldComponentUpdate = function (newProps, newState) {\n    if (!newProps.shouldUpdateWhenHidden && this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  };\n\n  ContextualMenuBase.prototype.UNSAFE_componentWillUpdate = function (newProps) {\n    if (newProps.target !== this.props.target) {\n      var newTarget = newProps.target;\n\n      this._setTargetWindowAndElement(newTarget);\n    }\n\n    if (this._isHidden(newProps) !== this._isHidden(this.props)) {\n      if (this._isHidden(newProps)) {\n        this._onMenuClosed();\n      } else {\n        this._onMenuOpened();\n\n        this._previousActiveElement = this._targetWindow ? this._targetWindow.document.activeElement : undefined;\n      }\n    }\n\n    if (newProps.delayUpdateFocusOnHover !== this.props.delayUpdateFocusOnHover) {\n      // update shouldUpdateFocusOnMouseEvent to follow what was passed in\n      this._shouldUpdateFocusOnMouseEvent = !newProps.delayUpdateFocusOnHover; // If shouldUpdateFocusOnMouseEvent is false, we need to reset gotMouseMove to false\n\n      this._gotMouseMove = this._shouldUpdateFocusOnMouseEvent && this._gotMouseMove;\n    }\n  }; // Invoked once, both on the client and server, immediately before the initial rendering occurs.\n\n\n  ContextualMenuBase.prototype.UNSAFE_componentWillMount = function () {\n    var target = this.props.target;\n\n    this._setTargetWindowAndElement(target);\n\n    if (!this.props.hidden) {\n      this._previousActiveElement = this._targetWindow ? this._targetWindow.document.activeElement : undefined;\n    }\n  }; // Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.\n\n\n  ContextualMenuBase.prototype.componentDidMount = function () {\n    if (!this.props.hidden) {\n      this._onMenuOpened();\n    }\n\n    this._mounted = true;\n  }; // Invoked immediately before a component is unmounted from the DOM.\n\n\n  ContextualMenuBase.prototype.componentWillUnmount = function () {\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._events.dispose();\n\n    this._async.dispose();\n\n    this._mounted = false;\n  };\n\n  ContextualMenuBase.prototype.render = function () {\n    var _this = this;\n\n    var isBeakVisible = this.props.isBeakVisible;\n    var _a = this.props,\n        items = _a.items,\n        labelElementId = _a.labelElementId,\n        id = _a.id,\n        className = _a.className,\n        beakWidth = _a.beakWidth,\n        directionalHint = _a.directionalHint,\n        directionalHintForRTL = _a.directionalHintForRTL,\n        alignTargetEdge = _a.alignTargetEdge,\n        gapSpace = _a.gapSpace,\n        coverTarget = _a.coverTarget,\n        ariaLabel = _a.ariaLabel,\n        doNotLayer = _a.doNotLayer,\n        target = _a.target,\n        bounds = _a.bounds,\n        useTargetWidth = _a.useTargetWidth,\n        useTargetAsMinWidth = _a.useTargetAsMinWidth,\n        directionalHintFixed = _a.directionalHintFixed,\n        shouldFocusOnMount = _a.shouldFocusOnMount,\n        shouldFocusOnContainer = _a.shouldFocusOnContainer,\n        title = _a.title,\n        styles = _a.styles,\n        theme = _a.theme,\n        calloutProps = _a.calloutProps,\n        _b = _a.onRenderSubMenu,\n        onRenderSubMenu = _b === void 0 ? this._onRenderSubMenu : _b,\n        _c = _a.onRenderMenuList,\n        onRenderMenuList = _c === void 0 ? this._onRenderMenuList : _c,\n        focusZoneProps = _a.focusZoneProps,\n        // eslint-disable-next-line deprecation/deprecation\n    getMenuClassNames = _a.getMenuClassNames;\n    this._classNames = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    var hasIcons = itemsHaveIcons(items);\n\n    function itemsHaveIcons(contextualMenuItems) {\n      for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {\n        var item = contextualMenuItems_1[_i];\n\n        if (item.iconProps) {\n          return true;\n        }\n\n        if (item.itemType === ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    this._adjustedFocusZoneProps = __assign(__assign({}, focusZoneProps), {\n      direction: this._getFocusZoneDirection()\n    });\n    var hasCheckmarks = canAnyMenuItemsCheck(items);\n    var submenuProps = this.state.expandedMenuItemKey && this.props.hidden !== true ? this._getSubmenuProps() : null;\n    isBeakVisible = isBeakVisible === undefined ? this.props.responsiveMode <= ResponsiveMode.medium : isBeakVisible;\n    /**\n     * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n     */\n\n    var contextMenuStyle;\n    var targetAsHtmlElement = this._target;\n\n    if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n      var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n      var targetWidth = targetBoundingRect.width - 2;\n      /* Accounts for 1px border */\n\n      if (useTargetWidth) {\n        contextMenuStyle = {\n          width: targetWidth\n        };\n      } else if (useTargetAsMinWidth) {\n        contextMenuStyle = {\n          minWidth: targetWidth\n        };\n      }\n    } // The menu should only return if items were provided, if no items were provided then it should not appear.\n\n\n    if (items && items.length > 0) {\n      var totalItemCount = 0;\n\n      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {\n        var item = items_1[_i];\n\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          totalItemCount += itemCount;\n        }\n      }\n\n      var calloutStyles = this._classNames.subComponentStyles ? this._classNames.subComponentStyles.callout : undefined;\n      return React.createElement(Callout, __assign({\n        styles: calloutStyles,\n        onRestoreFocus: this._tryFocusPreviousActiveElement\n      }, calloutProps, {\n        target: target,\n        isBeakVisible: isBeakVisible,\n        beakWidth: beakWidth,\n        directionalHint: directionalHint,\n        directionalHintForRTL: directionalHintForRTL,\n        gapSpace: gapSpace,\n        coverTarget: coverTarget,\n        doNotLayer: doNotLayer,\n        className: css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className),\n        setInitialFocus: shouldFocusOnMount,\n        onDismiss: this.props.onDismiss,\n        onScroll: this._onScroll,\n        bounds: bounds,\n        directionalHintFixed: directionalHintFixed,\n        alignTargetEdge: alignTargetEdge,\n        hidden: this.props.hidden\n      }), React.createElement(\"div\", {\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": labelElementId,\n        style: contextMenuStyle,\n        ref: function (host) {\n          return _this._host = host;\n        },\n        id: id,\n        className: this._classNames.container,\n        tabIndex: shouldFocusOnContainer ? 0 : -1,\n        onKeyDown: this._onMenuKeyDown,\n        onKeyUp: this._onKeyUp,\n        onFocusCapture: this._onMenuFocusCapture\n      }, title && React.createElement(\"div\", {\n        className: this._classNames.title\n      }, \" \", title, \" \"), items && items.length ? React.createElement(FocusZone, __assign({\n        className: this._classNames.root,\n        isCircularNavigation: true,\n        handleTabKey: FocusZoneTabbableElements.all\n      }, this._adjustedFocusZoneProps), onRenderMenuList({\n        items: items,\n        totalItemCount: totalItemCount,\n        hasCheckmarks: hasCheckmarks,\n        hasIcons: hasIcons,\n        defaultMenuItemRenderer: this._defaultMenuItemRenderer\n      }, this._onRenderMenuList)) : null, submenuProps && onRenderSubMenu(submenuProps, this._onRenderSubMenu)));\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Return whether the contextual menu is hidden.\n   * Undefined value for hidden is equivalent to hidden being false.\n   * @param props - Props for the component\n   */\n\n\n  ContextualMenuBase.prototype._isHidden = function (props) {\n    return !!props.hidden;\n  };\n\n  ContextualMenuBase.prototype._onMenuOpened = function () {\n    this._events.on(this._targetWindow, 'resize', this.dismiss);\n\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n    this.props.onMenuOpened && this.props.onMenuOpened(this.props);\n  };\n\n  ContextualMenuBase.prototype._onMenuClosed = function () {\n    this._events.off(this._targetWindow, 'resize', this.dismiss); // This is kept for backwards compatability with hidden for right now.\n    // This preserves the way that this behaved in the past\n    // TODO find a better way to handle this by using the same conventions that\n    // Popup uses to determine if focus is contained when dismissal occurs\n\n\n    this._tryFocusPreviousActiveElement({\n      containsFocus: this._focusingPreviousElement,\n      documentContainsFocus: this._targetWindow.document.hasFocus(),\n      originalElement: this._previousActiveElement\n    });\n\n    this._focusingPreviousElement = false;\n\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover; // We need to dismiss any submenu related state properties,\n    // so that when the menu is shown again, the submenu is collapsed\n\n    this.setState({\n      expandedByMouseClick: undefined,\n      dismissedMenuItemKey: undefined,\n      expandedMenuItemKey: undefined,\n      submenuTarget: undefined\n    });\n  };\n  /**\n   * Gets the focusZoneDirection by using the arrowDirection if specified,\n   * the direction specificed in the focusZoneProps, or defaults to FocusZoneDirection.vertical\n   */\n\n\n  ContextualMenuBase.prototype._getFocusZoneDirection = function () {\n    var focusZoneProps = this.props.focusZoneProps;\n    return focusZoneProps && focusZoneProps.direction !== undefined ? focusZoneProps.direction : FocusZoneDirection.vertical;\n  };\n\n  ContextualMenuBase.prototype._onRenderSubMenu = function (subMenuProps, defaultRender) {\n    throw Error('ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' + 'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.');\n  };\n\n  ContextualMenuBase.prototype._renderSectionItem = function (sectionItem, // eslint-disable-next-line deprecation/deprecation\n  menuClassNames, index, hasCheckmarks, hasIcons) {\n    var _this = this;\n\n    var _a;\n\n    var sectionProps = sectionItem.sectionProps;\n\n    if (!sectionProps) {\n      return;\n    }\n\n    var headerItem;\n    var groupProps;\n\n    if (sectionProps.title) {\n      var headerContextualMenuItem = undefined;\n      var ariaLabellledby = '';\n\n      if (typeof sectionProps.title === 'string') {\n        // Since title is a user-facing string, it needs to be stripped\n        // of whitespace in order to build a valid element ID\n        var id = this._id + sectionProps.title.replace(/\\s/g, '');\n        headerContextualMenuItem = {\n          key: \"section-\" + sectionProps.title + \"-title\",\n          itemType: ContextualMenuItemType.Header,\n          text: sectionProps.title,\n          id: id\n        };\n        ariaLabellledby = id;\n      } else {\n        headerContextualMenuItem = sectionProps.title;\n        ariaLabellledby = this._id + ((_a = sectionProps.title.text) === null || _a === void 0 ? void 0 : _a.replace(/\\s/g, ''));\n      }\n\n      if (headerContextualMenuItem) {\n        groupProps = {\n          role: 'group',\n          'aria-labelledby': ariaLabellledby\n        };\n        headerItem = this._renderHeaderMenuItem(headerContextualMenuItem, menuClassNames, index, hasCheckmarks, hasIcons);\n      }\n    }\n\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      return React.createElement(\"li\", {\n        role: \"presentation\",\n        key: sectionProps.key || sectionItem.key || \"section-\" + index\n      }, React.createElement(\"div\", __assign({}, groupProps), React.createElement(\"ul\", {\n        className: this._classNames.list,\n        role: \"menu\"\n      }, sectionProps.topDivider && this._renderSeparator(index, menuClassNames, true, true), headerItem && this._renderListItem(headerItem, sectionItem.key || index, menuClassNames, sectionItem.title), sectionProps.items.map(function (contextualMenuItem, itemsIndex) {\n        return _this._renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, sectionProps.items.length, hasCheckmarks, hasIcons);\n      }), sectionProps.bottomDivider && this._renderSeparator(index, menuClassNames, false, true))));\n    }\n  };\n\n  ContextualMenuBase.prototype._renderListItem = function (content, key, classNames, // eslint-disable-line deprecation/deprecation\n  title) {\n    return React.createElement(\"li\", {\n      role: \"presentation\",\n      title: title,\n      key: key,\n      className: classNames.item\n    }, content);\n  };\n\n  ContextualMenuBase.prototype._renderSeparator = function (index, classNames, // eslint-disable-line deprecation/deprecation\n  top, fromSection) {\n    if (fromSection || index > 0) {\n      return React.createElement(\"li\", {\n        role: \"separator\",\n        key: 'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom'),\n        className: classNames.divider,\n        \"aria-hidden\": \"true\"\n      });\n    }\n\n    return null;\n  };\n\n  ContextualMenuBase.prototype._renderNormalItem = function (item, classNames, // eslint-disable-line deprecation/deprecation\n  index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    if (item.onRender) {\n      return item.onRender(__assign({\n        'aria-posinset': focusableElementIndex + 1,\n        'aria-setsize': totalItemCount\n      }, item), this.dismiss);\n    }\n\n    if (item.href) {\n      return this._renderAnchorMenuItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    }\n\n    if (item.split && hasSubmenu(item)) {\n      return this._renderSplitButton(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n    }\n\n    return this._renderButtonItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n  };\n\n  ContextualMenuBase.prototype._renderHeaderMenuItem = function (item, // eslint-disable-next-line deprecation/deprecation\n  classNames, index, hasCheckmarks, hasIcons) {\n    var _a = this.props.contextualMenuItemAs,\n        ChildrenRenderer = _a === void 0 ? ContextualMenuItem : _a;\n    var itemProps = item.itemProps,\n        id = item.id;\n    var divHtmlProperties = itemProps && getNativeProps(itemProps, divProperties);\n    return (// eslint-disable-next-line deprecation/deprecation\n      React.createElement(\"div\", __assign({\n        id: id,\n        className: this._classNames.header\n      }, divHtmlProperties, {\n        style: item.style\n      }), React.createElement(ChildrenRenderer, __assign({\n        item: item,\n        classNames: classNames,\n        index: index,\n        onCheckmarkClick: hasCheckmarks ? this._onItemClick : undefined,\n        hasIcons: hasIcons\n      }, itemProps)))\n    );\n  };\n\n  ContextualMenuBase.prototype._renderAnchorMenuItem = function (item, // eslint-disable-next-line deprecation/deprecation\n  classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuAnchor, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onAnchorClick,\n      onItemKeyDown: this._onItemKeyDown,\n      getSubMenuId: this._getSubMenuId,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss\n    });\n  };\n\n  ContextualMenuBase.prototype._renderButtonItem = function (item, // eslint-disable-next-line deprecation/deprecation\n  classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuButton, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onItemClick,\n      onItemClickBase: this._onItemClickBase,\n      onItemKeyDown: this._onItemKeyDown,\n      getSubMenuId: this._getSubMenuId,\n      expandedMenuItemKey: expandedMenuItemKey,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss\n    });\n  };\n\n  ContextualMenuBase.prototype._renderSplitButton = function (item, // eslint-disable-next-line deprecation/deprecation\n  classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {\n    var contextualMenuItemAs = this.props.contextualMenuItemAs;\n    var expandedMenuItemKey = this.state.expandedMenuItemKey;\n    return React.createElement(ContextualMenuSplitButton, {\n      item: item,\n      classNames: classNames,\n      index: index,\n      focusableElementIndex: focusableElementIndex,\n      totalItemCount: totalItemCount,\n      hasCheckmarks: hasCheckmarks,\n      hasIcons: hasIcons,\n      contextualMenuItemAs: contextualMenuItemAs,\n      onItemMouseEnter: this._onItemMouseEnterBase,\n      onItemMouseLeave: this._onMouseItemLeave,\n      onItemMouseMove: this._onItemMouseMoveBase,\n      onItemMouseDown: this._onItemMouseDown,\n      executeItemClick: this._executeItemClick,\n      onItemClick: this._onItemClick,\n      onItemClickBase: this._onItemClickBase,\n      onItemKeyDown: this._onItemKeyDown,\n      openSubMenu: this._onItemSubMenuExpand,\n      dismissSubMenu: this._onSubMenuDismiss,\n      dismissMenu: this.dismiss,\n      expandedMenuItemKey: expandedMenuItemKey,\n      onTap: this._onPointerAndTouchEvent\n    });\n  };\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n\n\n  ContextualMenuBase.prototype._isAltOrMeta = function (ev) {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  };\n\n  ContextualMenuBase.prototype._shouldIgnoreMouseEvent = function () {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  };\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n\n\n  ContextualMenuBase.prototype._updateFocusOnMouseEvent = function (item, ev, target) {\n    var _this = this;\n\n    var targetElement = target ? target : ev.currentTarget;\n    var _a = this.props.subMenuHoverDelay,\n        timeoutDuration = _a === void 0 ? NavigationIdleDelay : _a;\n\n    if (item.key === this.state.expandedMenuItemKey) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n\n      this._enterTimerId = undefined;\n    } // If the menu is not expanded we can update focus without any delay\n\n\n    if (this.state.expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    } // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n\n\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      this._enterTimerId = this._async.setTimeout(function () {\n        targetElement.focus();\n\n        _this.setState({\n          expandedByMouseClick: true\n        });\n\n        _this._onItemSubMenuExpand(item, targetElement);\n\n        _this._enterTimerId = undefined;\n      }, timeoutDuration);\n    } else {\n      this._enterTimerId = this._async.setTimeout(function () {\n        _this._onSubMenuDismiss(ev);\n\n        targetElement.focus();\n        _this._enterTimerId = undefined;\n      }, timeoutDuration);\n    }\n  };\n\n  ContextualMenuBase.prototype._getSubmenuProps = function () {\n    var _a = this.state,\n        submenuTarget = _a.submenuTarget,\n        expandedMenuItemKey = _a.expandedMenuItemKey;\n\n    var item = this._findItemByKey(expandedMenuItemKey);\n\n    var submenuProps = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item),\n        target: submenuTarget,\n        onDismiss: this._onSubMenuDismiss,\n        isSubMenu: true,\n        id: this.state.subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: this.state.expandedByMouseClick,\n        directionalHint: getRTL(this.props.theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: this.props.className,\n        gapSpace: 0,\n        isBeakVisible: false\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n    }\n\n    return submenuProps;\n  };\n\n  ContextualMenuBase.prototype._findItemByKey = function (key) {\n    var items = this.props.items;\n    return this._findItemByKeyFromItems(key, items);\n  };\n  /**\n   * Returns the item that mathes a given key if any.\n   * @param key - The key of the item to match\n   * @param items - The items to look for the key\n   */\n\n\n  ContextualMenuBase.prototype._findItemByKeyFromItems = function (key, items) {\n    for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {\n      var item = items_2[_i];\n\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n        var match = this._findItemByKeyFromItems(key, item.sectionProps.items);\n\n        if (match) {\n          return match;\n        }\n      } else if (item.key && item.key === key) {\n        return item;\n      }\n    }\n  };\n\n  ContextualMenuBase.prototype._setTargetWindowAndElement = function (target) {\n    var currentElement = this._host;\n\n    if (target) {\n      if (typeof target === 'string') {\n        var currentDoc = getDocument(currentElement);\n        this._target = currentDoc ? currentDoc.querySelector(target) : null;\n        this._targetWindow = getWindow(currentElement); // Cast to any prevents error about stopPropagation always existing\n      } else if (target.stopPropagation) {\n        this._targetWindow = getWindow(target.target);\n        this._target = target;\n      } else if ( // eslint-disable-next-line deprecation/deprecation\n      (target.left !== undefined || target.x !== undefined) && ( // eslint-disable-next-line deprecation/deprecation\n      target.top !== undefined || target.y !== undefined)) {\n        this._targetWindow = getWindow(currentElement);\n        this._target = target;\n      } else if (target.current !== undefined) {\n        this._target = target.current;\n        this._targetWindow = getWindow(this._target);\n      } else {\n        var targetElement = target;\n        this._targetWindow = getWindow(targetElement);\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement);\n    }\n  }; // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\n\n\n  ContextualMenuBase.defaultProps = {\n    items: [],\n    shouldFocusOnMount: true,\n    gapSpace: 0,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n    beakWidth: 16\n  };\n  ContextualMenuBase = __decorate([withResponsiveMode], ContextualMenuBase);\n  return ContextualMenuBase;\n}(React.Component);\n\nexport { ContextualMenuBase };","map":{"version":3,"sources":["components/ContextualMenu/ContextualMenu.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  IContextualMenuProps,\n  IContextualMenuItem,\n  ContextualMenuItemType,\n  IContextualMenuListProps,\n  IContextualMenuStyleProps,\n  IContextualMenuStyles,\n  IContextualMenuItemRenderProps,\n} from './ContextualMenu.types';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { FocusZone, FocusZoneDirection, IFocusZoneProps, FocusZoneTabbableElements } from '../../FocusZone';\nimport { IMenuItemClassNames, IContextualMenuClassNames } from './ContextualMenu.classNames';\nimport {\n  divProperties,\n  getNativeProps,\n  shallowCompare,\n  warnDeprecations,\n  Async,\n  EventGroup,\n  assign,\n  classNamesFunction,\n  css,\n  getDocument,\n  getFirstFocusable,\n  getId,\n  getLastFocusable,\n  getRTL,\n  getWindow,\n  IRenderFunction,\n  Point,\n  KeyCodes,\n  shouldWrapFocus,\n  IStyleFunctionOrObject,\n  isIOS,\n  isMac,\n  initializeComponentRef,\n  memoizeFunction,\n} from '../../Utilities';\nimport { hasSubmenu, getIsChecked, isItemDisabled } from '../../utilities/contextualMenu/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { Callout, ICalloutContentStyleProps, ICalloutContentStyles } from '../../Callout';\nimport { ContextualMenuItem } from './ContextualMenuItem';\nimport {\n  ContextualMenuSplitButton,\n  ContextualMenuButton,\n  ContextualMenuAnchor,\n} from './ContextualMenuItemWrapper/index';\nimport { IProcessedStyleSet, concatStyleSetsWithProps } from '../../Styling';\nimport { IContextualMenuItemStyleProps, IContextualMenuItemStyles } from './ContextualMenuItem.types';\nimport { getItemStyles } from './ContextualMenu.classNames';\nimport { Target } from '@uifabric/react-hooks';\n\nconst getClassNames = classNamesFunction<IContextualMenuStyleProps, IContextualMenuStyles>();\nconst getContextualMenuItemClassNames = classNamesFunction<IContextualMenuItemStyleProps, IContextualMenuItemStyles>();\n\nexport interface IContextualMenuState {\n  expandedMenuItemKey?: string;\n  /** True if the menu was expanded by mouse click OR hover (as opposed to by keyboard) */\n  expandedByMouseClick?: boolean;\n  dismissedMenuItemKey?: string;\n  contextualMenuItems?: IContextualMenuItem[];\n  contextualMenuTarget?: Element;\n  submenuTarget?: Element;\n  positions?: any;\n  slideDirectionalClassName?: string;\n  subMenuId?: string;\n  submenuDirection?: DirectionalHint;\n}\n\nexport function getSubmenuItems(item: IContextualMenuItem): IContextualMenuItem[] | undefined {\n  return item.subMenuProps ? item.subMenuProps.items : item.items;\n}\n\n/**\n * Returns true if a list of menu items can contain a checkbox\n */\nexport function canAnyMenuItemsCheck(items: IContextualMenuItem[]): boolean {\n  return items.some(item => {\n    if (item.canCheck) {\n      return true;\n    }\n\n    // If the item is a section, check if any of the items in the section can check.\n    if (item.sectionProps && item.sectionProps.items.some(submenuItem => submenuItem.canCheck === true)) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nconst NavigationIdleDelay = 250; /* ms */\n\nconst COMPONENT_NAME = 'ContextualMenu';\n\nconst _getMenuItemStylesFunction = memoizeFunction(\n  (\n    ...styles: (IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> | undefined)[]\n  ): IStyleFunctionOrObject<IContextualMenuItemStyleProps, IContextualMenuItemStyles> => {\n    return (styleProps: IContextualMenuItemStyleProps) =>\n      concatStyleSetsWithProps(styleProps, getItemStyles, ...styles);\n  },\n);\n\n@withResponsiveMode\nexport class ContextualMenuBase extends React.Component<IContextualMenuProps, IContextualMenuState> {\n  // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.\n  public static defaultProps: IContextualMenuProps = {\n    items: [],\n    shouldFocusOnMount: true,\n    gapSpace: 0,\n    directionalHint: DirectionalHint.bottomAutoEdge,\n    beakWidth: 16,\n  };\n\n  private _async: Async;\n  private _events: EventGroup;\n  private _id: string;\n  private _host: HTMLElement;\n  private _previousActiveElement: HTMLElement | undefined;\n  private _enterTimerId: number | undefined;\n  private _targetWindow: Window;\n  private _target: Element | MouseEvent | Point | null;\n  private _isScrollIdle: boolean;\n  private _scrollIdleTimeoutId: number | undefined;\n  /** True if the most recent keydown event was for alt (option) or meta (command). */\n  private _lastKeyDownWasAltOrMeta: boolean | undefined;\n  private _shouldUpdateFocusOnMouseEvent: boolean;\n  private _gotMouseMove: boolean;\n  private _mounted = false;\n  private _focusingPreviousElement: boolean;\n\n  private _adjustedFocusZoneProps: IFocusZoneProps;\n\n  // eslint-disable-next-line deprecation/deprecation\n  private _classNames: IProcessedStyleSet<IContextualMenuStyles> | IContextualMenuClassNames;\n\n  constructor(props: IContextualMenuProps) {\n    super(props);\n\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n    initializeComponentRef(this);\n\n    warnDeprecations(COMPONENT_NAME, props, {\n      getMenuClassNames: 'styles',\n    });\n\n    this.state = {\n      contextualMenuItems: undefined,\n      subMenuId: getId('ContextualMenu'),\n    };\n\n    this._id = props.id || getId('ContextualMenu');\n    this._focusingPreviousElement = false;\n    this._isScrollIdle = true;\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n  }\n\n  public dismiss = (ev?: any, dismissAll?: boolean) => {\n    const { onDismiss } = this.props;\n\n    if (onDismiss) {\n      onDismiss(ev, dismissAll);\n    }\n  };\n\n  public shouldComponentUpdate(newProps: IContextualMenuProps, newState: IContextualMenuState): boolean {\n    if (!newProps.shouldUpdateWhenHidden && this.props.hidden && newProps.hidden) {\n      // Do not update when hidden.\n      return false;\n    }\n\n    return !shallowCompare(this.props, newProps) || !shallowCompare(this.state, newState);\n  }\n\n  public UNSAFE_componentWillUpdate(newProps: IContextualMenuProps): void {\n    if (newProps.target !== this.props.target) {\n      const newTarget = newProps.target;\n      this._setTargetWindowAndElement(newTarget!);\n    }\n\n    if (this._isHidden(newProps) !== this._isHidden(this.props)) {\n      if (this._isHidden(newProps)) {\n        this._onMenuClosed();\n      } else {\n        this._onMenuOpened();\n        this._previousActiveElement = this._targetWindow\n          ? (this._targetWindow.document.activeElement as HTMLElement)\n          : undefined;\n      }\n    }\n    if (newProps.delayUpdateFocusOnHover !== this.props.delayUpdateFocusOnHover) {\n      // update shouldUpdateFocusOnMouseEvent to follow what was passed in\n      this._shouldUpdateFocusOnMouseEvent = !newProps.delayUpdateFocusOnHover;\n\n      // If shouldUpdateFocusOnMouseEvent is false, we need to reset gotMouseMove to false\n      this._gotMouseMove = this._shouldUpdateFocusOnMouseEvent && this._gotMouseMove;\n    }\n  }\n\n  // Invoked once, both on the client and server, immediately before the initial rendering occurs.\n  public UNSAFE_componentWillMount() {\n    const target = this.props.target;\n    this._setTargetWindowAndElement(target!);\n    if (!this.props.hidden) {\n      this._previousActiveElement = this._targetWindow\n        ? (this._targetWindow.document.activeElement as HTMLElement)\n        : undefined;\n    }\n  }\n\n  // Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.\n  public componentDidMount(): void {\n    if (!this.props.hidden) {\n      this._onMenuOpened();\n    }\n\n    this._mounted = true;\n  }\n\n  // Invoked immediately before a component is unmounted from the DOM.\n  public componentWillUnmount() {\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._events.dispose();\n    this._async.dispose();\n    this._mounted = false;\n  }\n\n  public render(): JSX.Element | null {\n    let { isBeakVisible } = this.props;\n\n    const {\n      items,\n      labelElementId,\n      id,\n      className,\n      beakWidth,\n      directionalHint,\n      directionalHintForRTL,\n      alignTargetEdge,\n      gapSpace,\n      coverTarget,\n      ariaLabel,\n      doNotLayer,\n      target,\n      bounds,\n      useTargetWidth,\n      useTargetAsMinWidth,\n      directionalHintFixed,\n      shouldFocusOnMount,\n      shouldFocusOnContainer,\n      title,\n      styles,\n      theme,\n      calloutProps,\n      onRenderSubMenu = this._onRenderSubMenu,\n      onRenderMenuList = this._onRenderMenuList,\n      focusZoneProps,\n      // eslint-disable-next-line deprecation/deprecation\n      getMenuClassNames,\n    } = this.props;\n\n    this._classNames = getMenuClassNames\n      ? getMenuClassNames(theme!, className)\n      : getClassNames(styles, {\n          theme: theme!,\n          className: className,\n        });\n\n    const hasIcons = itemsHaveIcons(items);\n\n    function itemsHaveIcons(contextualMenuItems: IContextualMenuItem[]): boolean {\n      for (const item of contextualMenuItems) {\n        if (item.iconProps) {\n          return true;\n        }\n\n        if (\n          item.itemType === ContextualMenuItemType.Section &&\n          item.sectionProps &&\n          itemsHaveIcons(item.sectionProps.items)\n        ) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    this._adjustedFocusZoneProps = { ...focusZoneProps, direction: this._getFocusZoneDirection() };\n\n    const hasCheckmarks = canAnyMenuItemsCheck(items);\n    const submenuProps = this.state.expandedMenuItemKey && this.props.hidden !== true ? this._getSubmenuProps() : null;\n\n    isBeakVisible = isBeakVisible === undefined ? this.props.responsiveMode! <= ResponsiveMode.medium : isBeakVisible;\n    /**\n     * When useTargetWidth is true, get the width of the target element and apply it for the context menu container\n     */\n    let contextMenuStyle;\n    const targetAsHtmlElement = this._target as HTMLElement;\n    if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {\n      const targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();\n      const targetWidth = targetBoundingRect.width - 2; /* Accounts for 1px border */\n\n      if (useTargetWidth) {\n        contextMenuStyle = {\n          width: targetWidth,\n        };\n      } else if (useTargetAsMinWidth) {\n        contextMenuStyle = {\n          minWidth: targetWidth,\n        };\n      }\n    }\n\n    // The menu should only return if items were provided, if no items were provided then it should not appear.\n    if (items && items.length > 0) {\n      let totalItemCount = 0;\n      for (const item of items) {\n        if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n          const itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n          totalItemCount += itemCount;\n        }\n      }\n\n      const calloutStyles = this._classNames.subComponentStyles\n        ? (this._classNames.subComponentStyles.callout as IStyleFunctionOrObject<\n            ICalloutContentStyleProps,\n            ICalloutContentStyles\n          >)\n        : undefined;\n\n      return (\n        <Callout\n          styles={calloutStyles}\n          onRestoreFocus={this._tryFocusPreviousActiveElement}\n          {...calloutProps}\n          target={target}\n          isBeakVisible={isBeakVisible}\n          beakWidth={beakWidth}\n          directionalHint={directionalHint}\n          directionalHintForRTL={directionalHintForRTL}\n          gapSpace={gapSpace}\n          coverTarget={coverTarget}\n          doNotLayer={doNotLayer}\n          className={css('ms-ContextualMenu-Callout', calloutProps && calloutProps.className)}\n          setInitialFocus={shouldFocusOnMount}\n          onDismiss={this.props.onDismiss}\n          onScroll={this._onScroll}\n          bounds={bounds}\n          directionalHintFixed={directionalHintFixed}\n          alignTargetEdge={alignTargetEdge}\n          hidden={this.props.hidden}\n        >\n          <div\n            aria-label={ariaLabel}\n            aria-labelledby={labelElementId}\n            style={contextMenuStyle}\n            ref={(host: HTMLDivElement) => (this._host = host)}\n            id={id}\n            className={this._classNames.container}\n            tabIndex={shouldFocusOnContainer ? 0 : -1}\n            onKeyDown={this._onMenuKeyDown}\n            onKeyUp={this._onKeyUp}\n            onFocusCapture={this._onMenuFocusCapture}\n          >\n            {title && <div className={this._classNames.title}> {title} </div>}\n            {items && items.length ? (\n              <FocusZone\n                className={this._classNames.root}\n                isCircularNavigation={true}\n                handleTabKey={FocusZoneTabbableElements.all}\n                {...this._adjustedFocusZoneProps}\n              >\n                {onRenderMenuList(\n                  {\n                    items,\n                    totalItemCount,\n                    hasCheckmarks,\n                    hasIcons,\n                    defaultMenuItemRenderer: this._defaultMenuItemRenderer,\n                  },\n                  this._onRenderMenuList,\n                )}\n              </FocusZone>\n            ) : null}\n            {submenuProps && onRenderSubMenu(submenuProps, this._onRenderSubMenu)}\n          </div>\n        </Callout>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Return whether the contextual menu is hidden.\n   * Undefined value for hidden is equivalent to hidden being false.\n   * @param props - Props for the component\n   */\n  private _isHidden(props: IContextualMenuProps) {\n    return !!props.hidden;\n  }\n\n  private _onMenuOpened() {\n    this._events.on(this._targetWindow, 'resize', this.dismiss);\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n    this._gotMouseMove = false;\n    this.props.onMenuOpened && this.props.onMenuOpened(this.props);\n  }\n\n  private _onMenuClosed() {\n    this._events.off(this._targetWindow, 'resize', this.dismiss);\n\n    // This is kept for backwards compatability with hidden for right now.\n    // This preserves the way that this behaved in the past\n    // TODO find a better way to handle this by using the same conventions that\n    // Popup uses to determine if focus is contained when dismissal occurs\n    this._tryFocusPreviousActiveElement({\n      containsFocus: this._focusingPreviousElement,\n      documentContainsFocus: this._targetWindow.document.hasFocus(),\n      originalElement: this._previousActiveElement,\n    });\n\n    this._focusingPreviousElement = false;\n\n    if (this.props.onMenuDismissed) {\n      this.props.onMenuDismissed(this.props);\n    }\n\n    this._shouldUpdateFocusOnMouseEvent = !this.props.delayUpdateFocusOnHover;\n\n    // We need to dismiss any submenu related state properties,\n    // so that when the menu is shown again, the submenu is collapsed\n    this.setState({\n      expandedByMouseClick: undefined,\n      dismissedMenuItemKey: undefined,\n      expandedMenuItemKey: undefined,\n      submenuTarget: undefined,\n    });\n  }\n\n  private _tryFocusPreviousActiveElement = (options: {\n    containsFocus: boolean;\n    documentContainsFocus: boolean;\n    originalElement: HTMLElement | Window | undefined;\n  }) => {\n    if (this.props.onRestoreFocus) {\n      this.props.onRestoreFocus(options);\n    } else {\n      if (options && options.containsFocus && this._previousActiveElement) {\n        // Make sure that the focus method actually exists\n        // In some cases the object might exist but not be a real element.\n        // This is primarily for IE 11 and should be removed once IE 11 is no longer in use.\n        if (this._previousActiveElement.focus) {\n          this._previousActiveElement.focus();\n        }\n      }\n    }\n  };\n\n  /**\n   * Gets the focusZoneDirection by using the arrowDirection if specified,\n   * the direction specificed in the focusZoneProps, or defaults to FocusZoneDirection.vertical\n   */\n  private _getFocusZoneDirection() {\n    const { focusZoneProps } = this.props;\n    return focusZoneProps && focusZoneProps.direction !== undefined\n      ? focusZoneProps.direction\n      : FocusZoneDirection.vertical;\n  }\n\n  private _onRenderSubMenu(\n    subMenuProps: IContextualMenuProps,\n    defaultRender?: IRenderFunction<IContextualMenuProps>,\n  ): JSX.Element {\n    throw Error(\n      'ContextualMenuBase: onRenderSubMenu callback is null or undefined. ' +\n        'Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.',\n    );\n  }\n\n  private _onRenderMenuList = (\n    menuListProps: IContextualMenuListProps,\n    defaultRender?: IRenderFunction<IContextualMenuListProps>,\n  ): JSX.Element => {\n    let indexCorrection = 0;\n    const { items, totalItemCount, hasCheckmarks, hasIcons, role } = menuListProps;\n    return (\n      <ul className={this._classNames.list} onKeyDown={this._onKeyDown} onKeyUp={this._onKeyUp} role={role ?? 'menu'}>\n        {items.map((item, index) => {\n          const menuItem = this._renderMenuItem(item, index, indexCorrection, totalItemCount, hasCheckmarks, hasIcons);\n          if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {\n            const indexIncrease = item.customOnRenderListLength ? item.customOnRenderListLength : 1;\n            indexCorrection += indexIncrease;\n          }\n          return menuItem;\n        })}\n      </ul>\n    );\n  };\n\n  /**\n   * !!!IMPORTANT!!! Avoid mutating `item: IContextualMenuItem` argument. It will\n   * cause the menu items to always re-render because the component update is based on shallow comparison.\n   */\n  private _renderMenuItem = (\n    item: IContextualMenuItem,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): JSX.Element => {\n    const renderedItems: React.ReactNode[] = [];\n    const iconProps = item.iconProps || { iconName: 'None' };\n    const {\n      getItemClassNames, // eslint-disable-line deprecation/deprecation\n      itemProps,\n    } = item;\n    const styles = itemProps ? itemProps.styles : undefined;\n\n    // We only send a dividerClassName when the item to be rendered is a divider.\n    // For all other cases, the default divider style is used.\n    const dividerClassName = item.itemType === ContextualMenuItemType.Divider ? item.className : undefined;\n    const subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';\n\n    // eslint-disable-next-line deprecation/deprecation\n    let itemClassNames: IMenuItemClassNames;\n\n    // IContextualMenuItem#getItemClassNames for backwards compatibility\n    // otherwise uses mergeStyles for class names.\n    if (getItemClassNames) {\n      itemClassNames = getItemClassNames(\n        this.props.theme!,\n        isItemDisabled(item),\n        this.state.expandedMenuItemKey === item.key,\n        !!getIsChecked(item),\n        !!item.href,\n        iconProps.iconName !== 'None',\n        item.className,\n        dividerClassName,\n        iconProps.className,\n        subMenuIconClassName,\n        item.primaryDisabled,\n      );\n    } else {\n      const itemStyleProps: IContextualMenuItemStyleProps = {\n        theme: this.props.theme!,\n        disabled: isItemDisabled(item),\n        expanded: this.state.expandedMenuItemKey === item.key,\n        checked: !!getIsChecked(item),\n        isAnchorLink: !!item.href,\n        knownIcon: iconProps.iconName !== 'None',\n        itemClassName: item.className,\n        dividerClassName,\n        iconClassName: iconProps.className,\n        subMenuClassName: subMenuIconClassName,\n        primaryDisabled: item.primaryDisabled,\n      };\n\n      // We need to generate default styles then override if styles are provided\n      // since the ContextualMenu currently handles item classNames.\n      itemClassNames = getContextualMenuItemClassNames(\n        _getMenuItemStylesFunction(this._classNames.subComponentStyles?.menuItem, styles),\n        itemStyleProps,\n      );\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    if (item.text === '-' || item.name === '-') {\n      item.itemType = ContextualMenuItemType.Divider;\n    }\n    switch (item.itemType) {\n      case ContextualMenuItemType.Divider:\n        renderedItems.push(this._renderSeparator(index, itemClassNames));\n        break;\n      case ContextualMenuItemType.Header:\n        renderedItems.push(this._renderSeparator(index, itemClassNames));\n        const headerItem = this._renderHeaderMenuItem(item, itemClassNames, index, hasCheckmarks, hasIcons);\n        renderedItems.push(this._renderListItem(headerItem, item.key || index, itemClassNames, item.title));\n        break;\n      case ContextualMenuItemType.Section:\n        renderedItems.push(this._renderSectionItem(item, itemClassNames, index, hasCheckmarks, hasIcons));\n        break;\n      default:\n        const menuItem = this._renderNormalItem(\n          item,\n          itemClassNames,\n          index,\n          focusableElementIndex,\n          totalItemCount,\n          hasCheckmarks,\n          hasIcons,\n        );\n        renderedItems.push(this._renderListItem(menuItem, item.key || index, itemClassNames, item.title));\n        break;\n    }\n\n    // Since multiple nodes *could* be rendered, wrap them all in a fragment with this item's key.\n    // This ensures the reconciler handles multi-item output per-node correctly and does not re-mount content.\n    return <React.Fragment key={item.key}>{renderedItems}</React.Fragment>;\n  };\n\n  private _defaultMenuItemRenderer = (item: IContextualMenuItemRenderProps): React.ReactNode => {\n    const { index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons } = item;\n    return this._renderMenuItem(item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);\n  };\n\n  private _renderSectionItem(\n    sectionItem: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    menuClassNames: IMenuItemClassNames,\n    index: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ) {\n    const sectionProps = sectionItem.sectionProps;\n    if (!sectionProps) {\n      return;\n    }\n\n    let headerItem;\n    let groupProps;\n    if (sectionProps.title) {\n      let headerContextualMenuItem: IContextualMenuItem | undefined = undefined;\n      let ariaLabellledby = '';\n      if (typeof sectionProps.title === 'string') {\n        // Since title is a user-facing string, it needs to be stripped\n        // of whitespace in order to build a valid element ID\n        const id = this._id + sectionProps.title.replace(/\\s/g, '');\n        headerContextualMenuItem = {\n          key: `section-${sectionProps.title}-title`,\n          itemType: ContextualMenuItemType.Header,\n          text: sectionProps.title,\n          id: id,\n        };\n        ariaLabellledby = id;\n      } else {\n        headerContextualMenuItem = sectionProps.title;\n        ariaLabellledby = this._id + sectionProps.title.text?.replace(/\\s/g, '');\n      }\n\n      if (headerContextualMenuItem) {\n        groupProps = {\n          role: 'group',\n          'aria-labelledby': ariaLabellledby,\n        };\n        headerItem = this._renderHeaderMenuItem(\n          headerContextualMenuItem,\n          menuClassNames,\n          index,\n          hasCheckmarks,\n          hasIcons,\n        );\n      }\n    }\n\n    if (sectionProps.items && sectionProps.items.length > 0) {\n      return (\n        <li role=\"presentation\" key={sectionProps.key || sectionItem.key || `section-${index}`}>\n          <div {...groupProps}>\n            <ul className={this._classNames.list} role=\"menu\">\n              {sectionProps.topDivider && this._renderSeparator(index, menuClassNames, true, true)}\n              {headerItem &&\n                this._renderListItem(headerItem, sectionItem.key || index, menuClassNames, sectionItem.title)}\n              {sectionProps.items.map((contextualMenuItem, itemsIndex) =>\n                this._renderMenuItem(\n                  contextualMenuItem,\n                  itemsIndex,\n                  itemsIndex,\n                  sectionProps.items.length,\n                  hasCheckmarks,\n                  hasIcons,\n                ),\n              )}\n              {sectionProps.bottomDivider && this._renderSeparator(index, menuClassNames, false, true)}\n            </ul>\n          </div>\n        </li>\n      );\n    }\n  }\n\n  private _renderListItem(\n    content: React.ReactNode,\n    key: string | number,\n    classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n    title?: string,\n  ) {\n    return (\n      <li role=\"presentation\" title={title} key={key} className={classNames.item}>\n        {content}\n      </li>\n    );\n  }\n\n  private _renderSeparator(\n    index: number,\n    classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n    top?: boolean,\n    fromSection?: boolean,\n  ): React.ReactNode {\n    if (fromSection || index > 0) {\n      return (\n        <li\n          role=\"separator\"\n          key={'separator-' + index + (top === undefined ? '' : top ? '-top' : '-bottom')}\n          className={classNames.divider}\n          aria-hidden=\"true\"\n        />\n      );\n    }\n    return null;\n  }\n\n  private _renderNormalItem(\n    item: IContextualMenuItem,\n    classNames: IMenuItemClassNames, // eslint-disable-line deprecation/deprecation\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): React.ReactNode {\n    if (item.onRender) {\n      return item.onRender(\n        { 'aria-posinset': focusableElementIndex + 1, 'aria-setsize': totalItemCount, ...item },\n        this.dismiss,\n      );\n    }\n    if (item.href) {\n      return this._renderAnchorMenuItem(\n        item,\n        classNames,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n      );\n    }\n\n    if (item.split && hasSubmenu(item)) {\n      return this._renderSplitButton(\n        item,\n        classNames,\n        index,\n        focusableElementIndex,\n        totalItemCount,\n        hasCheckmarks,\n        hasIcons,\n      );\n    }\n\n    return this._renderButtonItem(\n      item,\n      classNames,\n      index,\n      focusableElementIndex,\n      totalItemCount,\n      hasCheckmarks,\n      hasIcons,\n    );\n  }\n\n  private _renderHeaderMenuItem(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): React.ReactNode {\n    const { contextualMenuItemAs: ChildrenRenderer = ContextualMenuItem } = this.props;\n    const { itemProps, id } = item;\n    const divHtmlProperties =\n      itemProps && getNativeProps<React.HTMLAttributes<HTMLDivElement>>(itemProps, divProperties);\n    return (\n      // eslint-disable-next-line deprecation/deprecation\n      <div id={id} className={this._classNames.header} {...divHtmlProperties} style={item.style}>\n        <ChildrenRenderer\n          item={item}\n          classNames={classNames}\n          index={index}\n          onCheckmarkClick={hasCheckmarks ? this._onItemClick : undefined}\n          hasIcons={hasIcons}\n          {...itemProps}\n        />\n      </div>\n    );\n  }\n\n  private _renderAnchorMenuItem(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks: boolean,\n    hasIcons: boolean,\n  ): React.ReactNode {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n    return (\n      <ContextualMenuAnchor\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onAnchorClick}\n        onItemKeyDown={this._onItemKeyDown}\n        getSubMenuId={this._getSubMenuId}\n        expandedMenuItemKey={expandedMenuItemKey}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n      />\n    );\n  }\n\n  private _renderButtonItem(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks?: boolean,\n    hasIcons?: boolean,\n  ) {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n\n    return (\n      <ContextualMenuButton\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onItemClick}\n        onItemClickBase={this._onItemClickBase}\n        onItemKeyDown={this._onItemKeyDown}\n        getSubMenuId={this._getSubMenuId}\n        expandedMenuItemKey={expandedMenuItemKey}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n      />\n    );\n  }\n\n  private _renderSplitButton(\n    item: IContextualMenuItem,\n    // eslint-disable-next-line deprecation/deprecation\n    classNames: IMenuItemClassNames,\n    index: number,\n    focusableElementIndex: number,\n    totalItemCount: number,\n    hasCheckmarks?: boolean,\n    hasIcons?: boolean,\n  ): JSX.Element {\n    const { contextualMenuItemAs } = this.props;\n    const { expandedMenuItemKey } = this.state;\n\n    return (\n      <ContextualMenuSplitButton\n        item={item}\n        classNames={classNames}\n        index={index}\n        focusableElementIndex={focusableElementIndex}\n        totalItemCount={totalItemCount}\n        hasCheckmarks={hasCheckmarks}\n        hasIcons={hasIcons}\n        contextualMenuItemAs={contextualMenuItemAs}\n        onItemMouseEnter={this._onItemMouseEnterBase}\n        onItemMouseLeave={this._onMouseItemLeave}\n        onItemMouseMove={this._onItemMouseMoveBase}\n        onItemMouseDown={this._onItemMouseDown}\n        executeItemClick={this._executeItemClick}\n        onItemClick={this._onItemClick}\n        onItemClickBase={this._onItemClickBase}\n        onItemKeyDown={this._onItemKeyDown}\n        openSubMenu={this._onItemSubMenuExpand}\n        dismissSubMenu={this._onSubMenuDismiss}\n        dismissMenu={this.dismiss}\n        expandedMenuItemKey={expandedMenuItemKey}\n        onTap={this._onPointerAndTouchEvent}\n      />\n    );\n  }\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    // Take note if we are processing an alt (option) or meta (command) keydown.\n    // See comment in _shouldHandleKeyUp for reasoning.\n    this._lastKeyDownWasAltOrMeta = this._isAltOrMeta(ev);\n\n    // On Mac, pressing escape dismisses all levels of native context menus\n    const dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());\n\n    return this._keyHandler(ev, this._shouldHandleKeyDown, dismissAllMenus);\n  };\n\n  private _shouldHandleKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    return (\n      ev.which === KeyCodes.escape ||\n      this._shouldCloseSubMenu(ev) ||\n      (ev.which === KeyCodes.up && (ev.altKey || ev.metaKey))\n    );\n  };\n\n  private _onMenuFocusCapture = (ev: React.FocusEvent<HTMLElement>) => {\n    if (this.props.delayUpdateFocusOnHover) {\n      this._shouldUpdateFocusOnMouseEvent = true;\n    }\n  };\n\n  private _onKeyUp = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    return this._keyHandler(ev, this._shouldHandleKeyUp, true /* dismissAllMenus */);\n  };\n\n  /**\n   * We close the menu on key up only if ALL of the following are true:\n   * - Most recent key down was alt or meta (command)\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n   *   expand/collapse the menu)\n   * - We're not on a Mac (or iOS)\n   *\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n   * closing any open context menus. There is not a similar behavior on Macs.\n   */\n  private _shouldHandleKeyUp = (ev: React.KeyboardEvent<HTMLElement>) => {\n    const keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);\n    this._lastKeyDownWasAltOrMeta = false;\n    return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());\n  };\n\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n  private _isAltOrMeta(ev: React.KeyboardEvent<HTMLElement>): boolean {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  }\n\n  /**\n   * Calls `shouldHandleKey` to determine whether the keyboard event should be handled;\n   * if so, stops event propagation and dismisses menu(s).\n   * @param ev - The keyboard event.\n   * @param shouldHandleKey - Returns whether we should handle this keyboard event.\n   * @param dismissAllMenus - If true, dismiss all menus. Otherwise, dismiss only the current menu.\n   * Only does anything if `shouldHandleKey` returns true.\n   * @returns Whether the event was handled.\n   */\n  private _keyHandler = (\n    ev: React.KeyboardEvent<HTMLElement>,\n    shouldHandleKey: (ev: React.KeyboardEvent<HTMLElement>) => boolean,\n    dismissAllMenus?: boolean,\n  ): boolean => {\n    let handled = false;\n\n    if (shouldHandleKey(ev)) {\n      this._focusingPreviousElement = true;\n      this.dismiss(ev, dismissAllMenus);\n      ev.preventDefault();\n      ev.stopPropagation();\n      handled = true;\n    }\n\n    return handled;\n  };\n\n  /**\n   * Checks if the submenu should be closed\n   */\n  private _shouldCloseSubMenu = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    const submenuCloseKey = getRTL(this.props.theme) ? KeyCodes.right : KeyCodes.left;\n\n    if (ev.which !== submenuCloseKey || !this.props.isSubMenu) {\n      return false;\n    }\n\n    return (\n      this._adjustedFocusZoneProps.direction === FocusZoneDirection.vertical ||\n      (!!this._adjustedFocusZoneProps.checkForNoWrap &&\n        !shouldWrapFocus(ev.target as HTMLElement, 'data-no-horizontal-wrap'))\n    );\n  };\n\n  private _onMenuKeyDown = (ev: React.KeyboardEvent<HTMLElement>) => {\n    // Mark as handled if onKeyDown returns true (for handling collapse cases)\n    // or if we are attempting to expand a submenu\n    const handled = this._onKeyDown(ev);\n\n    if (handled || !this._host) {\n      return;\n    }\n\n    // If we have a modifier key being pressed, we do not want to move focus.\n    // Otherwise, handle up and down keys.\n    const hasModifier = !!(ev.altKey || ev.metaKey);\n    const isUp = ev.which === KeyCodes.up;\n    const isDown = ev.which === KeyCodes.down;\n    if (!hasModifier && (isUp || isDown)) {\n      const elementToFocus = isUp\n        ? getLastFocusable(this._host, this._host.lastChild as HTMLElement, true)\n        : getFirstFocusable(this._host, this._host.firstChild as HTMLElement, true);\n\n      if (elementToFocus) {\n        elementToFocus.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  /**\n   * Scroll handler for the callout to make sure the mouse events\n   * for updating focus are not interacting during scroll\n   */\n  private _onScroll = (): void => {\n    if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {\n      this._async.clearTimeout(this._scrollIdleTimeoutId);\n      this._scrollIdleTimeoutId = undefined;\n    } else {\n      this._isScrollIdle = false;\n    }\n\n    this._scrollIdleTimeoutId = this._async.setTimeout(() => {\n      this._isScrollIdle = true;\n    }, NavigationIdleDelay);\n  };\n\n  private _onItemMouseEnterBase = (item: any, ev: React.MouseEvent<HTMLElement>, target?: HTMLElement): void => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    this._updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  private _onItemMouseMoveBase = (item: any, ev: React.MouseEvent<HTMLElement>, target: HTMLElement): void => {\n    const targetElement = ev.currentTarget as HTMLElement;\n\n    // Always do this check to make sure we record a mouseMove if needed (even if we are timed out)\n    if (this._shouldUpdateFocusOnMouseEvent) {\n      this._gotMouseMove = true;\n    } else {\n      return;\n    }\n\n    if (\n      !this._isScrollIdle ||\n      this._enterTimerId !== undefined ||\n      targetElement === (this._targetWindow.document.activeElement as HTMLElement)\n    ) {\n      return;\n    }\n\n    this._updateFocusOnMouseEvent(item, ev, target);\n  };\n\n  private _shouldIgnoreMouseEvent(): boolean {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  }\n\n  private _onMouseItemLeave = (item: any, ev: React.MouseEvent<HTMLElement>): void => {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n\n    if (this.state.expandedMenuItemKey !== undefined) {\n      return;\n    }\n\n    /**\n     * IE11 focus() method forces parents to scroll to top of element.\n     * Edge and IE expose a setActive() function for focusable divs that\n     * sets the page focus but does not scroll the parent element.\n     */\n    if ((this._host as any).setActive) {\n      try {\n        (this._host as any).setActive();\n      } catch (e) {\n        /* no-op */\n      }\n    } else {\n      this._host.focus();\n    }\n  };\n\n  /**\n   * Handles updating focus when mouseEnter or mouseMove fire.\n   * As part of updating focus, This function will also update\n   * the expand/collapse state accordingly.\n   */\n  private _updateFocusOnMouseEvent(item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>, target?: HTMLElement) {\n    const targetElement = target ? target : (ev.currentTarget as HTMLElement);\n    const { subMenuHoverDelay: timeoutDuration = NavigationIdleDelay } = this.props;\n\n    if (item.key === this.state.expandedMenuItemKey) {\n      return;\n    }\n\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n\n    // If the menu is not expanded we can update focus without any delay\n    if (this.state.expandedMenuItemKey === undefined) {\n      targetElement.focus();\n    }\n\n    // Delay updating expanding/dismissing the submenu\n    // and only set focus if we have not already done so\n    if (hasSubmenu(item)) {\n      ev.stopPropagation();\n      this._enterTimerId = this._async.setTimeout(() => {\n        targetElement.focus();\n        this.setState({\n          expandedByMouseClick: true,\n        });\n        this._onItemSubMenuExpand(item, targetElement);\n        this._enterTimerId = undefined;\n      }, timeoutDuration);\n    } else {\n      this._enterTimerId = this._async.setTimeout(() => {\n        this._onSubMenuDismiss(ev);\n        targetElement.focus();\n        this._enterTimerId = undefined;\n      }, timeoutDuration);\n    }\n  }\n\n  private _onItemMouseDown = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>): void => {\n    if (item.onMouseDown) {\n      item.onMouseDown(item, ev);\n    }\n  };\n\n  private _onItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    this._onItemClickBase(item, ev, ev.currentTarget as HTMLElement);\n  };\n\n  private _onItemClickBase = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    target: HTMLElement,\n  ): void => {\n    const items = getSubmenuItems(item);\n\n    // Cancel a async menu item hover timeout action from being taken and instead\n    // just trigger the click event instead.\n    this._cancelSubMenuTimer();\n\n    if (!hasSubmenu(item) && (!items || !items.length)) {\n      // This is an item without a menu. Click it.\n      this._executeItemClick(item, ev);\n    } else {\n      if (item.key !== this.state.expandedMenuItemKey) {\n        // This has a collapsed sub menu. Expand it.\n        this.setState({\n          // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing\n          // \"Enter\" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates\n          // between a real click event and a keypress event (detail should be the number of mouse clicks).\n          // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).\n          // So we also check the pointerType property, which both Edge and IE set to \"mouse\" for real clicks\n          // and \"\" for pressing \"Enter\" with Narrator on.\n          expandedByMouseClick: ev.nativeEvent.detail !== 0 || (ev.nativeEvent as PointerEvent).pointerType === 'mouse',\n        });\n        this._onItemSubMenuExpand(item, target);\n      }\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  private _onAnchorClick = (item: IContextualMenuItem, ev: React.MouseEvent<HTMLElement>) => {\n    this._executeItemClick(item, ev);\n    ev.stopPropagation();\n  };\n\n  private _executeItemClick = (\n    item: IContextualMenuItem,\n    ev: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    if (item.disabled || item.isDisabled) {\n      return;\n    }\n\n    let dismiss = false;\n    if (item.onClick) {\n      dismiss = !!item.onClick(ev, item);\n    } else if (this.props.onItemClick) {\n      dismiss = !!this.props.onItemClick(ev, item);\n    }\n\n    if (dismiss || !ev.defaultPrevented) {\n      this.dismiss(ev, true);\n\n      // This should be removed whenever possible.\n      // This ensures that the hidden dismissal action maintains the same behavior.\n      // If the menu is being dismissed then the previously focused element should\n      // get focused since the dismiss was triggered by a user click on an item\n      // Rather than focus being lost.\n      this._focusingPreviousElement = true;\n    }\n  };\n\n  private _onItemKeyDown = (item: any, ev: React.KeyboardEvent<HTMLElement>): void => {\n    const openKey = getRTL(this.props.theme) ? KeyCodes.left : KeyCodes.right;\n\n    if (\n      !item.disabled &&\n      (ev.which === openKey || ev.which === KeyCodes.enter || (ev.which === KeyCodes.down && (ev.altKey || ev.metaKey)))\n    ) {\n      this.setState({\n        expandedByMouseClick: false,\n      });\n      this._onItemSubMenuExpand(item, ev.currentTarget as HTMLElement);\n      ev.preventDefault();\n    }\n  };\n\n  // Cancel a async menu item hover timeout action from being taken and instead\n  // do new upcoming behavior\n  private _cancelSubMenuTimer = () => {\n    if (this._enterTimerId !== undefined) {\n      this._async.clearTimeout(this._enterTimerId);\n      this._enterTimerId = undefined;\n    }\n  };\n\n  private _onItemSubMenuExpand = (item: IContextualMenuItem, target: HTMLElement): void => {\n    if (this.state.expandedMenuItemKey !== item.key) {\n      if (this.state.expandedMenuItemKey) {\n        this._onSubMenuDismiss();\n      }\n\n      // Focus the target to ensure when we close it, we're focusing on the correct element.\n      target.focus();\n      this.setState({\n        expandedMenuItemKey: item.key,\n        submenuTarget: target,\n      });\n    }\n  };\n\n  private _getSubmenuProps() {\n    const { submenuTarget, expandedMenuItemKey } = this.state;\n    const item = this._findItemByKey(expandedMenuItemKey!);\n    let submenuProps: IContextualMenuProps | null = null;\n\n    if (item) {\n      submenuProps = {\n        items: getSubmenuItems(item)!,\n        target: submenuTarget,\n        onDismiss: this._onSubMenuDismiss,\n        isSubMenu: true,\n        id: this.state.subMenuId,\n        shouldFocusOnMount: true,\n        shouldFocusOnContainer: this.state.expandedByMouseClick,\n        directionalHint: getRTL(this.props.theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,\n        className: this.props.className,\n        gapSpace: 0,\n        isBeakVisible: false,\n      };\n\n      if (item.subMenuProps) {\n        assign(submenuProps, item.subMenuProps);\n      }\n    }\n    return submenuProps;\n  }\n\n  private _findItemByKey(key: string): IContextualMenuItem | undefined {\n    const { items } = this.props;\n    return this._findItemByKeyFromItems(key, items);\n  }\n\n  /**\n   * Returns the item that mathes a given key if any.\n   * @param key - The key of the item to match\n   * @param items - The items to look for the key\n   */\n  private _findItemByKeyFromItems(key: string, items: IContextualMenuItem[]): IContextualMenuItem | undefined {\n    for (const item of items) {\n      if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {\n        const match = this._findItemByKeyFromItems(key, item.sectionProps.items);\n        if (match) {\n          return match;\n        }\n      } else if (item.key && item.key === key) {\n        return item;\n      }\n    }\n  }\n\n  /**\n   * This function is called ASYNCHRONOUSLY, and so there is a chance it is called\n   * after the component is unmounted. The _mounted property is added to prevent\n   * from calling setState() after unmount. Do NOT copy this pattern in synchronous\n   * code.\n   */\n  private _onSubMenuDismiss = (ev?: any, dismissAll?: boolean): void => {\n    if (dismissAll) {\n      this.dismiss(ev, dismissAll);\n    } else if (this._mounted) {\n      this.setState({\n        dismissedMenuItemKey: this.state.expandedMenuItemKey,\n        expandedMenuItemKey: undefined,\n        submenuTarget: undefined,\n      });\n    }\n  };\n\n  private _setTargetWindowAndElement(target: Target): void {\n    const currentElement = this._host;\n\n    if (target) {\n      if (typeof target === 'string') {\n        const currentDoc: Document = getDocument(currentElement)!;\n        this._target = currentDoc ? (currentDoc.querySelector(target) as Element) : null;\n        this._targetWindow = getWindow(currentElement)!;\n        // Cast to any prevents error about stopPropagation always existing\n      } else if ((target as any).stopPropagation) {\n        this._targetWindow = getWindow((target as MouseEvent).target as HTMLElement)!;\n        this._target = target as MouseEvent;\n      } else if (\n        // eslint-disable-next-line deprecation/deprecation\n        ((target as Point).left !== undefined || (target as Point).x !== undefined) &&\n        // eslint-disable-next-line deprecation/deprecation\n        ((target as Point).top !== undefined || (target as Point).y !== undefined)\n      ) {\n        this._targetWindow = getWindow(currentElement)!;\n        this._target = target as Point;\n      } else if ((target as React.RefObject<Element>).current !== undefined) {\n        this._target = (target as React.RefObject<Element>).current;\n        this._targetWindow = getWindow(this._target)!;\n      } else {\n        const targetElement: Element = target as Element;\n        this._targetWindow = getWindow(targetElement)!;\n        this._target = target as Element;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement)!;\n    }\n  }\n\n  private _getSubMenuId = (item: IContextualMenuItem): string | undefined => {\n    let { subMenuId } = this.state;\n\n    if (item.subMenuProps && item.subMenuProps.id) {\n      subMenuId = item.subMenuProps.id;\n    }\n\n    return subMenuId;\n  };\n\n  private _onPointerAndTouchEvent = (ev: React.TouchEvent<HTMLElement> | PointerEvent) => {\n    this._cancelSubMenuTimer();\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}