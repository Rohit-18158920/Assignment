{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { BaseDecorator } from './BaseDecorator';\nimport { getWindow, hoistStatics, EventGroup } from '../../Utilities';\nimport { WindowContext } from '../../WindowProvider';\nexport var ResponsiveMode;\n\n(function (ResponsiveMode) {\n  ResponsiveMode[ResponsiveMode[\"small\"] = 0] = \"small\";\n  ResponsiveMode[ResponsiveMode[\"medium\"] = 1] = \"medium\";\n  ResponsiveMode[ResponsiveMode[\"large\"] = 2] = \"large\";\n  ResponsiveMode[ResponsiveMode[\"xLarge\"] = 3] = \"xLarge\";\n  ResponsiveMode[ResponsiveMode[\"xxLarge\"] = 4] = \"xxLarge\";\n  ResponsiveMode[ResponsiveMode[\"xxxLarge\"] = 5] = \"xxxLarge\";\n  ResponsiveMode[ResponsiveMode[\"unknown\"] = 999] = \"unknown\";\n})(ResponsiveMode || (ResponsiveMode = {}));\n\nvar RESPONSIVE_MAX_CONSTRAINT = [479, 639, 1023, 1365, 1919, 99999999];\n/**\n * User specified mode to default to, useful for server side rendering scenarios.\n */\n\nvar _defaultMode;\n/**\n * Tracking the last mode we successfully rendered, which allows us to\n * paint initial renders with the correct size.\n */\n\n\nvar _lastMode;\n/**\n * Allows a server rendered scenario to provide a default responsive mode.\n */\n\n\nexport function setResponsiveMode(responsiveMode) {\n  _defaultMode = responsiveMode;\n}\n/**\n * Initializes the responsive mode to the current window size. This can be used to avoid\n * a re-render during first component mount since the window would otherwise not be measured\n * until after mounting.\n */\n\nexport function initializeResponsiveMode(element) {\n  if (typeof window !== 'undefined') {\n    var currentWindow = element && getWindow(element) || window;\n    getResponsiveMode(currentWindow);\n  }\n}\nexport function getInitialResponsiveMode() {\n  return _defaultMode || _lastMode || ResponsiveMode.large;\n}\nexport function withResponsiveMode(ComposedComponent) {\n  var _a;\n\n  var resultClass = (_a =\n  /** @class */\n  function (_super) {\n    __extends(WithResponsiveMode, _super);\n\n    function WithResponsiveMode(props) {\n      var _this = _super.call(this, props) || this;\n\n      _this._onResize = function () {\n        var responsiveMode = getResponsiveMode(_this.context.window);\n\n        if (responsiveMode !== _this.state.responsiveMode) {\n          _this.setState({\n            responsiveMode: responsiveMode\n          });\n        }\n      };\n\n      _this._events = new EventGroup(_this);\n      _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);\n      _this.state = {\n        responsiveMode: getInitialResponsiveMode()\n      };\n      return _this;\n    }\n\n    WithResponsiveMode.prototype.componentDidMount = function () {\n      this._events.on(this.context.window, 'resize', this._onResize);\n\n      this._onResize();\n    };\n\n    WithResponsiveMode.prototype.componentWillUnmount = function () {\n      this._events.dispose();\n    };\n\n    WithResponsiveMode.prototype.render = function () {\n      var responsiveMode = this.state.responsiveMode;\n      return responsiveMode === ResponsiveMode.unknown ? null : React.createElement(ComposedComponent, __assign({\n        ref: this._updateComposedComponentRef,\n        responsiveMode: responsiveMode\n      }, this.props));\n    };\n\n    return WithResponsiveMode;\n  }(BaseDecorator), _a.contextType = WindowContext, _a);\n  return hoistStatics(ComposedComponent, resultClass);\n}\nexport function getResponsiveMode(currentWindow) {\n  var responsiveMode = ResponsiveMode.small;\n\n  if (currentWindow) {\n    try {\n      while (currentWindow.innerWidth > RESPONSIVE_MAX_CONSTRAINT[responsiveMode]) {\n        responsiveMode++;\n      }\n    } catch (e) {\n      // Return a best effort result in cases where we're in the browser but it throws on getting innerWidth.\n      responsiveMode = getInitialResponsiveMode();\n    } // Tracking last mode just gives us a better default in future renders,\n    // which avoids starting with the wrong value if we've measured once.\n\n\n    _lastMode = responsiveMode;\n  } else {\n    if (_defaultMode !== undefined) {\n      responsiveMode = _defaultMode;\n    } else {\n      throw new Error('Content was rendered in a server environment without providing a default responsive mode. ' + 'Call setResponsiveMode to define what the responsive mode is.');\n    }\n  }\n\n  return responsiveMode;\n}","map":{"version":3,"sources":["utilities/decorators/withResponsiveMode.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,aAAT,QAA8B,iBAA9B;AACA,SAAS,SAAT,EAAoB,YAApB,EAAkC,UAAlC,QAAoD,iBAApD;AACA,SAAS,aAAT,QAA8B,sBAA9B;AAMA,OAAA,IAAY,cAAZ;;AAAA,CAAA,UAAY,cAAZ,EAA0B;AACxB,EAAA,cAAA,CAAA,cAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;AACA,EAAA,cAAA,CAAA,cAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,cAAA,CAAA,cAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;AACA,EAAA,cAAA,CAAA,cAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,cAAA,CAAA,cAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA,EAAA,cAAA,CAAA,cAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AACA,EAAA,cAAA,CAAA,cAAA,CAAA,SAAA,CAAA,GAAA,GAAA,CAAA,GAAA,SAAA;AACD,CARD,EAAY,cAAc,KAAd,cAAc,GAAA,EAAA,CAA1B;;AAUA,IAAM,yBAAyB,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,IAAX,EAAiB,IAAjB,EAAuB,IAAvB,EAA6B,QAA7B,CAAlC;AAEA;;AAEG;;AACH,IAAI,YAAJ;AAEA;;;AAGG;;;AACH,IAAI,SAAJ;AAEA;;AAEG;;;AACH,OAAM,SAAU,iBAAV,CAA4B,cAA5B,EAAsE;AAC1E,EAAA,YAAY,GAAG,cAAf;AACD;AAED;;;;AAIG;;AACH,OAAM,SAAU,wBAAV,CAAmC,OAAnC,EAAwD;AAC5D,MAAI,OAAO,MAAP,KAAkB,WAAtB,EAAmC;AACjC,QAAM,aAAa,GAAI,OAAO,IAAI,SAAS,CAAC,OAAD,CAArB,IAAmC,MAAzD;AAEA,IAAA,iBAAiB,CAAC,aAAD,CAAjB;AACD;AACF;AAED,OAAM,SAAU,wBAAV,GAAkC;AACtC,SAAO,YAAY,IAAI,SAAhB,IAA6B,cAAc,CAAC,KAAnD;AACD;AAED,OAAM,SAAU,kBAAV,CACJ,iBADI,EACqF;;;AAEzF,MAAM,WAAW,IAAA,EAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAAoC,IAAA,SAAA,CAAA,kBAAA,EAAA,MAAA,CAAA;;AAMnD,aAAA,kBAAA,CAAY,KAAZ,EAAyB;AAAzB,UAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,KAAY,IADd;;AA+BQ,MAAA,KAAA,CAAA,SAAA,GAAY,YAAA;AAClB,YAAM,cAAc,GAAG,iBAAiB,CAAC,KAAI,CAAC,OAAL,CAAa,MAAd,CAAxC;;AAEA,YAAI,cAAc,KAAK,KAAI,CAAC,KAAL,CAAW,cAAlC,EAAkD;AAChD,UAAA,KAAI,CAAC,QAAL,CAAc;AACZ,YAAA,cAAc,EAAA;AADF,WAAd;AAGD;AACF,OARO;;AA7BN,MAAA,KAAI,CAAC,OAAL,GAAe,IAAI,UAAJ,CAAe,KAAf,CAAf;AACA,MAAA,KAAI,CAAC,2BAAL,GAAmC,KAAI,CAAC,2BAAL,CAAiC,IAAjC,CAAsC,KAAtC,CAAnC;AAEA,MAAA,KAAI,CAAC,KAAL,GAAa;AACX,QAAA,cAAc,EAAE,wBAAwB;AAD7B,OAAb;;AAGD;;AAEM,IAAA,kBAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,YAAA;AACE,WAAK,OAAL,CAAa,EAAb,CAAgB,KAAK,OAAL,CAAa,MAA7B,EAAqC,QAArC,EAA+C,KAAK,SAApD;;AACA,WAAK,SAAL;AACD,KAHM;;AAKA,IAAA,kBAAA,CAAA,SAAA,CAAA,oBAAA,GAAP,YAAA;AACE,WAAK,OAAL,CAAa,OAAb;AACD,KAFM;;AAIA,IAAA,kBAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACU,UAAA,cAAA,GAAA,KAAA,KAAA,CAAA,cAAA;AAER,aAAO,cAAc,KAAK,cAAc,CAAC,OAAlC,GAA4C,IAA5C,GACL,KAAA,CAAA,aAAA,CAAC,iBAAD,EAAkB,QAAA,CAAA;AAChB,QAAA,GAAG,EAAE,KAAK,2BADM;AAEhB,QAAA,cAAc,EAAE;AAFA,OAAA,EAGX,KAAK,KAHM,CAAlB,CADF;AAOD,KAVM;;AAqBT,WAAA,kBAAA;AAAC,GA9CgB,CAAoC,aAApC,CAAA,EACD,EAAA,CAAA,WAAA,GAAc,aADb,EA8ChB,EA9CgB,CAAjB;AA+CA,SAAO,YAAY,CAAC,iBAAD,EAAoB,WAApB,CAAnB;AACD;AAED,OAAM,SAAU,iBAAV,CAA4B,aAA5B,EAA6D;AACjE,MAAI,cAAc,GAAG,cAAc,CAAC,KAApC;;AAEA,MAAI,aAAJ,EAAmB;AACjB,QAAI;AACF,aAAO,aAAa,CAAC,UAAd,GAA2B,yBAAyB,CAAC,cAAD,CAA3D,EAA6E;AAC3E,QAAA,cAAc;AACf;AACF,KAJD,CAIE,OAAO,CAAP,EAAU;AACV;AACA,MAAA,cAAc,GAAG,wBAAwB,EAAzC;AACD,KARgB,CAUjB;AACA;;;AACA,IAAA,SAAS,GAAG,cAAZ;AACD,GAbD,MAaO;AACL,QAAI,YAAY,KAAK,SAArB,EAAgC;AAC9B,MAAA,cAAc,GAAG,YAAjB;AACD,KAFD,MAEO;AACL,YAAM,IAAI,KAAJ,CACJ,+FACE,+DAFE,CAAN;AAID;AACF;;AAED,SAAO,cAAP;AACD","sourcesContent":["import * as React from 'react';\nimport { BaseDecorator } from './BaseDecorator';\nimport { getWindow, hoistStatics, EventGroup } from '../../Utilities';\nimport { WindowContext } from '../../WindowProvider';\n\nexport interface IWithResponsiveModeState {\n  responsiveMode?: ResponsiveMode;\n}\n\nexport enum ResponsiveMode {\n  small = 0,\n  medium = 1,\n  large = 2,\n  xLarge = 3,\n  xxLarge = 4,\n  xxxLarge = 5,\n  unknown = 999,\n}\n\nconst RESPONSIVE_MAX_CONSTRAINT = [479, 639, 1023, 1365, 1919, 99999999];\n\n/**\n * User specified mode to default to, useful for server side rendering scenarios.\n */\nlet _defaultMode: ResponsiveMode | undefined;\n\n/**\n * Tracking the last mode we successfully rendered, which allows us to\n * paint initial renders with the correct size.\n */\nlet _lastMode: ResponsiveMode | undefined;\n\n/**\n * Allows a server rendered scenario to provide a default responsive mode.\n */\nexport function setResponsiveMode(responsiveMode: ResponsiveMode | undefined): void {\n  _defaultMode = responsiveMode;\n}\n\n/**\n * Initializes the responsive mode to the current window size. This can be used to avoid\n * a re-render during first component mount since the window would otherwise not be measured\n * until after mounting.\n */\nexport function initializeResponsiveMode(element?: HTMLElement): void {\n  if (typeof window !== 'undefined') {\n    const currentWindow = (element && getWindow(element)) || window;\n\n    getResponsiveMode(currentWindow);\n  }\n}\n\nexport function getInitialResponsiveMode() {\n  return _defaultMode || _lastMode || ResponsiveMode.large;\n}\n\nexport function withResponsiveMode<TProps extends { responsiveMode?: ResponsiveMode }, TState>(\n  ComposedComponent: new (props: TProps, ...args: any[]) => React.Component<TProps, TState>,\n): any {\n  const resultClass = class WithResponsiveMode extends BaseDecorator<TProps, IWithResponsiveModeState> {\n    public static contextType = WindowContext;\n    public context: React.ContextType<typeof WindowContext>;\n\n    private _events: EventGroup;\n\n    constructor(props: TProps) {\n      super(props);\n      this._events = new EventGroup(this);\n      this._updateComposedComponentRef = this._updateComposedComponentRef.bind(this);\n\n      this.state = {\n        responsiveMode: getInitialResponsiveMode(),\n      };\n    }\n\n    public componentDidMount(): void {\n      this._events.on(this.context.window, 'resize', this._onResize);\n      this._onResize();\n    }\n\n    public componentWillUnmount(): void {\n      this._events.dispose();\n    }\n\n    public render(): JSX.Element | null {\n      const { responsiveMode } = this.state;\n\n      return responsiveMode === ResponsiveMode.unknown ? null : (\n        <ComposedComponent\n          ref={this._updateComposedComponentRef}\n          responsiveMode={responsiveMode}\n          {...(this.props as any)}\n        />\n      );\n    }\n\n    private _onResize = () => {\n      const responsiveMode = getResponsiveMode(this.context.window);\n\n      if (responsiveMode !== this.state.responsiveMode) {\n        this.setState({\n          responsiveMode,\n        });\n      }\n    };\n  };\n  return hoistStatics(ComposedComponent, resultClass);\n}\n\nexport function getResponsiveMode(currentWindow: Window | undefined): ResponsiveMode {\n  let responsiveMode = ResponsiveMode.small;\n\n  if (currentWindow) {\n    try {\n      while (currentWindow.innerWidth > RESPONSIVE_MAX_CONSTRAINT[responsiveMode]) {\n        responsiveMode++;\n      }\n    } catch (e) {\n      // Return a best effort result in cases where we're in the browser but it throws on getting innerWidth.\n      responsiveMode = getInitialResponsiveMode();\n    }\n\n    // Tracking last mode just gives us a better default in future renders,\n    // which avoids starting with the wrong value if we've measured once.\n    _lastMode = responsiveMode;\n  } else {\n    if (_defaultMode !== undefined) {\n      responsiveMode = _defaultMode;\n    } else {\n      throw new Error(\n        'Content was rendered in a server environment without providing a default responsive mode. ' +\n          'Call setResponsiveMode to define what the responsive mode is.',\n      );\n    }\n  }\n\n  return responsiveMode;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}