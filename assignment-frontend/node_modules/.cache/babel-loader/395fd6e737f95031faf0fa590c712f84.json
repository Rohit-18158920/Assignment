{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { BaseDecorator } from './BaseDecorator';\nimport { findScrollableParent, getRect, getWindow, Async, EventGroup } from '../../Utilities';\nvar RESIZE_DELAY = 500;\nvar MAX_RESIZE_ATTEMPTS = 3;\n/**\n * A decorator to update decorated component on viewport or window resize events.\n *\n * @param ComposedComponent decorated React component reference.\n */\n\nexport function withViewport(ComposedComponent) {\n  return (\n    /** @class */\n    function (_super) {\n      __extends(WithViewportComponent, _super);\n\n      function WithViewportComponent(props) {\n        var _this = _super.call(this, props) || this;\n\n        _this._root = React.createRef();\n\n        _this._registerResizeObserver = function () {\n          var win = getWindow(_this._root.current);\n          _this._viewportResizeObserver = new win.ResizeObserver(_this._onAsyncResize);\n\n          _this._viewportResizeObserver.observe(_this._root.current);\n        };\n\n        _this._unregisterResizeObserver = function () {\n          if (_this._viewportResizeObserver) {\n            _this._viewportResizeObserver.disconnect();\n\n            delete _this._viewportResizeObserver;\n          }\n        };\n        /* Note: using lambda here because decorators don't seem to work in decorators. */\n\n\n        _this._updateViewport = function (withForceUpdate) {\n          var viewport = _this.state.viewport;\n          var viewportElement = _this._root.current;\n          var scrollElement = findScrollableParent(viewportElement);\n          var scrollRect = getRect(scrollElement);\n          var clientRect = getRect(viewportElement);\n\n          var updateComponent = function () {\n            if (withForceUpdate && _this._composedComponentInstance) {\n              _this._composedComponentInstance.forceUpdate();\n            }\n          };\n\n          var isSizeChanged = (clientRect && clientRect.width) !== viewport.width || (scrollRect && scrollRect.height) !== viewport.height;\n\n          if (isSizeChanged && _this._resizeAttempts < MAX_RESIZE_ATTEMPTS && clientRect && scrollRect) {\n            _this._resizeAttempts++;\n\n            _this.setState({\n              viewport: {\n                width: clientRect.width,\n                height: scrollRect.height\n              }\n            }, function () {\n              _this._updateViewport(withForceUpdate);\n            });\n          } else {\n            _this._resizeAttempts = 0;\n            updateComponent();\n          }\n        };\n\n        _this._async = new Async(_this);\n        _this._events = new EventGroup(_this);\n        _this._resizeAttempts = 0;\n        _this.state = {\n          viewport: {\n            width: 0,\n            height: 0\n          }\n        };\n        return _this;\n      }\n\n      WithViewportComponent.prototype.componentDidMount = function () {\n        var _a = this.props,\n            skipViewportMeasures = _a.skipViewportMeasures,\n            disableResizeObserver = _a.disableResizeObserver;\n        var win = getWindow(this._root.current);\n        this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\n          leading: false\n        });\n\n        if (!skipViewportMeasures) {\n          if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n            this._registerResizeObserver();\n          } else {\n            this._events.on(win, 'resize', this._onAsyncResize);\n          }\n\n          this._updateViewport();\n        }\n      };\n\n      WithViewportComponent.prototype.componentDidUpdate = function (previousProps) {\n        var previousSkipViewportMeasures = previousProps.skipViewportMeasures;\n        var _a = this.props,\n            skipViewportMeasures = _a.skipViewportMeasures,\n            disableResizeObserver = _a.disableResizeObserver;\n        var win = getWindow(this._root.current);\n\n        if (skipViewportMeasures !== previousSkipViewportMeasures) {\n          if (!skipViewportMeasures) {\n            if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n              if (!this._viewportResizeObserver) {\n                this._registerResizeObserver();\n              }\n            } else {\n              this._events.on(win, 'resize', this._onAsyncResize);\n            }\n\n            this._updateViewport();\n          } else {\n            this._unregisterResizeObserver();\n\n            this._events.off(win, 'resize', this._onAsyncResize);\n          }\n        }\n      };\n\n      WithViewportComponent.prototype.componentWillUnmount = function () {\n        this._events.dispose();\n\n        this._async.dispose();\n\n        this._unregisterResizeObserver();\n      };\n\n      WithViewportComponent.prototype.render = function () {\n        var viewport = this.state.viewport;\n        var newViewport = viewport.width > 0 && viewport.height > 0 ? viewport : undefined;\n        return React.createElement(\"div\", {\n          className: \"ms-Viewport\",\n          ref: this._root,\n          style: {\n            minWidth: 1,\n            minHeight: 1\n          }\n        }, React.createElement(ComposedComponent, __assign({\n          ref: this._updateComposedComponentRef,\n          viewport: newViewport\n        }, this.props)));\n      };\n\n      WithViewportComponent.prototype.forceUpdate = function () {\n        this._updateViewport(true);\n      };\n\n      WithViewportComponent.prototype._onAsyncResize = function () {\n        this._updateViewport();\n      };\n\n      WithViewportComponent.prototype._isResizeObserverAvailable = function () {\n        var win = getWindow(this._root.current);\n        return win && win.ResizeObserver;\n      };\n\n      return WithViewportComponent;\n    }(BaseDecorator)\n  );\n}","map":{"version":3,"sources":["utilities/decorators/withViewport.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { BaseDecorator } from './BaseDecorator';\nimport { findScrollableParent, getRect, getWindow, Async, EventGroup } from '../../Utilities';\n\n/**\n * Viewport rectangle dimensions.\n *\n * {@docCategory DetailsList}\n */\nexport interface IViewport {\n  /**\n   * Width in pixels.\n   */\n  width: number;\n  /**\n   * Height in pixels.\n   */\n  height: number;\n}\n\nexport interface IWithViewportState {\n  viewport?: IViewport;\n}\n\n/**\n * Props interface for the withViewport component.\n *\n * {@docCategory DetailsList}\n */\nexport interface IWithViewportProps {\n  /**\n   * Whether or not `withViewport` should disable its viewport measurements, effectively making this decorator\n   * pass-through with no impact on the rendered component.\n   *\n   * Since `withViewport` measures the `viewport` on mount, after each React update, and in response to events,\n   * it may cause a component which does not currently need this information due to its configuration to re-render\n   * too often. `skipViewportMeasures` may be toggled on and off based on current state, and will suspend and resume\n   * measurement as-needed.\n   *\n   * For example, when this wraps `DetailsList`, set `skipViewportMeasures` to `true` when the `layoutMode` is\n   * `fixedColumns`, since the `DetailsList` does not use the viewport size in any calculations.\n   *\n   * In addition, consider setting `skipViewportMeasures` to `true` when running within a React test renderer, to avoid\n   * direct DOM dependencies.\n   */\n  skipViewportMeasures?: boolean;\n  /**\n   * Whether or not to explicitly disable usage of the `ResizeObserver` in favor of a `'resize'` event on `window`,\n   * even if the browser supports `ResizeObserver`. This may be necessary if use of `ResizeObserver` results in too\n   * many re-renders of the wrapped component due to the frequency at which events are fired.\n   *\n   * This has no impact if `skipViewportMeasures` is `true`, as no viewport measurement strategy is used.\n   */\n  disableResizeObserver?: boolean;\n}\n\nconst RESIZE_DELAY = 500;\nconst MAX_RESIZE_ATTEMPTS = 3;\n\n/**\n * A decorator to update decorated component on viewport or window resize events.\n *\n * @param ComposedComponent decorated React component reference.\n */\nexport function withViewport<TProps extends { viewport?: IViewport }, TState>(\n  ComposedComponent: new (props: TProps, ...args: any[]) => React.Component<TProps, TState>,\n): any {\n  return class WithViewportComponent extends BaseDecorator<TProps, IWithViewportState> {\n    private _root = React.createRef<HTMLDivElement>();\n    private _resizeAttempts: number;\n    private _viewportResizeObserver: any;\n    private _async: Async;\n    private _events: EventGroup;\n\n    constructor(props: TProps) {\n      super(props);\n\n      this._async = new Async(this);\n      this._events = new EventGroup(this);\n      this._resizeAttempts = 0;\n\n      this.state = {\n        viewport: {\n          width: 0,\n          height: 0,\n        },\n      };\n    }\n\n    public componentDidMount(): void {\n      const { skipViewportMeasures, disableResizeObserver } = this.props as IWithViewportProps;\n      const win = getWindow(this._root.current);\n\n      this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\n        leading: false,\n      });\n\n      if (!skipViewportMeasures) {\n        if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n          this._registerResizeObserver();\n        } else {\n          this._events.on(win, 'resize', this._onAsyncResize);\n        }\n\n        this._updateViewport();\n      }\n    }\n\n    public componentDidUpdate(previousProps: TProps) {\n      const { skipViewportMeasures: previousSkipViewportMeasures } = previousProps as IWithViewportProps;\n      const { skipViewportMeasures, disableResizeObserver } = this.props as IWithViewportProps;\n      const win = getWindow(this._root.current);\n\n      if (skipViewportMeasures !== previousSkipViewportMeasures) {\n        if (!skipViewportMeasures) {\n          if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n            if (!this._viewportResizeObserver) {\n              this._registerResizeObserver();\n            }\n          } else {\n            this._events.on(win, 'resize', this._onAsyncResize);\n          }\n\n          this._updateViewport();\n        } else {\n          this._unregisterResizeObserver();\n          this._events.off(win, 'resize', this._onAsyncResize);\n        }\n      }\n    }\n\n    public componentWillUnmount(): void {\n      this._events.dispose();\n      this._async.dispose();\n      this._unregisterResizeObserver();\n    }\n\n    public render(): JSX.Element {\n      const { viewport } = this.state;\n      const newViewport = viewport!.width > 0 && viewport!.height > 0 ? viewport : undefined;\n\n      return (\n        <div className=\"ms-Viewport\" ref={this._root} style={{ minWidth: 1, minHeight: 1 }}>\n          <ComposedComponent ref={this._updateComposedComponentRef} viewport={newViewport} {...(this.props as any)} />\n        </div>\n      );\n    }\n\n    public forceUpdate(): void {\n      this._updateViewport(true);\n    }\n\n    private _onAsyncResize(): void {\n      this._updateViewport();\n    }\n\n    private _isResizeObserverAvailable(): boolean {\n      const win = getWindow(this._root.current);\n\n      return win && (win as any).ResizeObserver;\n    }\n\n    private _registerResizeObserver = () => {\n      const win = getWindow(this._root.current);\n\n      this._viewportResizeObserver = new (win as any).ResizeObserver(this._onAsyncResize);\n      this._viewportResizeObserver.observe(this._root.current);\n    };\n\n    private _unregisterResizeObserver = () => {\n      if (this._viewportResizeObserver) {\n        this._viewportResizeObserver.disconnect();\n        delete this._viewportResizeObserver;\n      }\n    };\n\n    /* Note: using lambda here because decorators don't seem to work in decorators. */\n    private _updateViewport = (withForceUpdate?: boolean) => {\n      const { viewport } = this.state;\n      const viewportElement = this._root.current;\n      const scrollElement = findScrollableParent(viewportElement) as HTMLElement;\n      const scrollRect = getRect(scrollElement);\n      const clientRect = getRect(viewportElement);\n      const updateComponent = () => {\n        if (withForceUpdate && this._composedComponentInstance) {\n          this._composedComponentInstance.forceUpdate();\n        }\n      };\n\n      const isSizeChanged =\n        (clientRect && clientRect.width) !== viewport!.width || (scrollRect && scrollRect.height) !== viewport!.height;\n\n      if (isSizeChanged && this._resizeAttempts < MAX_RESIZE_ATTEMPTS && clientRect && scrollRect) {\n        this._resizeAttempts++;\n        this.setState(\n          {\n            viewport: {\n              width: clientRect.width,\n              height: scrollRect.height,\n            },\n          },\n          () => {\n            this._updateViewport(withForceUpdate);\n          },\n        );\n      } else {\n        this._resizeAttempts = 0;\n        updateComponent();\n      }\n    };\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}