{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async } from './Async';\nimport { EventGroup } from './EventGroup';\nimport { warnConditionallyRequiredProps } from './warn/warnConditionallyRequiredProps';\nimport { warnMutuallyExclusive } from './warn/warnMutuallyExclusive';\nimport { warnDeprecations } from './warn/warnDeprecations';\n/**\n * BaseComponent class, which provides basic helpers for all components.\n *\n * @public\n * {@docCategory BaseComponent}\n *\n * @deprecated Do not use. We are moving away from class component.\n */\n\nvar BaseComponent =\n/** @class */\nfunction (_super) {\n  __extends(BaseComponent, _super);\n  /**\n   * BaseComponent constructor\n   * @param props - The props for the component.\n   * @param context - The context for the component.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  function BaseComponent(props, context) {\n    var _this = _super.call(this, props, context) || this; // eslint-disable-next-line deprecation/deprecation\n\n\n    _makeAllSafe(_this, BaseComponent.prototype, ['componentDidMount', 'shouldComponentUpdate', 'getSnapshotBeforeUpdate', 'render', 'componentDidUpdate', 'componentWillUnmount']);\n\n    return _this;\n  }\n  /**\n   * When the component receives props, make sure the componentRef is updated.\n   */\n\n\n  BaseComponent.prototype.componentDidUpdate = function (prevProps, prevState) {\n    this._updateComponentRef(prevProps, this.props);\n  };\n  /**\n   * When the component has mounted, update the componentRef.\n   */\n\n\n  BaseComponent.prototype.componentDidMount = function () {\n    this._setComponentRef(this.props.componentRef, this);\n  };\n  /**\n   * If we have disposables, dispose them automatically on unmount.\n   */\n\n\n  BaseComponent.prototype.componentWillUnmount = function () {\n    this._setComponentRef(this.props.componentRef, null);\n\n    if (this.__disposables) {\n      for (var i = 0, len = this._disposables.length; i < len; i++) {\n        var disposable = this.__disposables[i];\n\n        if (disposable.dispose) {\n          disposable.dispose();\n        }\n      }\n\n      this.__disposables = null;\n    }\n  };\n\n  Object.defineProperty(BaseComponent.prototype, \"className\", {\n    /**\n     * Gets the object's class name.\n     */\n    get: function () {\n      if (!this.__className) {\n        var funcNameRegex = /function (.{1,})\\(/;\n        var results = funcNameRegex.exec(this.constructor.toString());\n        this.__className = results && results.length > 1 ? results[1] : '';\n      }\n\n      return this.__className;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseComponent.prototype, \"_disposables\", {\n    /**\n     * Allows subclasses to push things to this._disposables to be auto disposed.\n     */\n    get: function () {\n      if (!this.__disposables) {\n        this.__disposables = [];\n      }\n\n      return this.__disposables;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseComponent.prototype, \"_async\", {\n    /**\n     * Gets the async instance associated with the component, created on demand. The async instance gives\n     * subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks\n     * will be cleared/ignored automatically after unmounting. The helpers within the async object also\n     * preserve the this pointer so that you don't need to \"bind\" the callbacks.\n     */\n    get: function () {\n      if (!this.__async) {\n        this.__async = new Async(this);\n\n        this._disposables.push(this.__async);\n      }\n\n      return this.__async;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseComponent.prototype, \"_events\", {\n    /**\n     * Gets the event group instance assocaited with the component, created on demand. The event instance\n     * provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks\n     * will be automatically disconnected after unmounting. The helpers within the events object also\n     * preserve the this reference so that you don't need to \"bind\" the callbacks.\n     */\n    get: function () {\n      if (!this.__events) {\n        this.__events = new EventGroup(this);\n\n        this._disposables.push(this.__events);\n      }\n\n      return this.__events;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Helper to return a memoized ref resolver function.\n   * @param refName - Name of the member to assign the ref to.\n   * @returns A function instance keyed from the given refname.\n   * @deprecated Use `createRef` from React.createRef.\n   */\n\n  BaseComponent.prototype._resolveRef = function (refName) {\n    var _this = this;\n\n    if (!this.__resolves) {\n      this.__resolves = {};\n    }\n\n    if (!this.__resolves[refName]) {\n      this.__resolves[refName] = function (ref) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return _this[refName] = ref;\n      };\n    }\n\n    return this.__resolves[refName];\n  };\n  /**\n   * Updates the componentRef (by calling it with \"this\" when necessary.)\n   */\n\n\n  BaseComponent.prototype._updateComponentRef = function (currentProps, newProps) {\n    if (newProps === void 0) {\n      newProps = {};\n    } // currentProps *should* always be defined, but verify that just in case a subclass is manually\n    // calling a lifecycle method with no parameters (which has happened) or other odd usage.\n\n\n    if (currentProps && newProps && currentProps.componentRef !== newProps.componentRef) {\n      this._setComponentRef(currentProps.componentRef, null);\n\n      this._setComponentRef(newProps.componentRef, this);\n    }\n  };\n  /**\n   * Warns when a deprecated props are being used.\n   *\n   * @param deprecationMap - The map of deprecations, where key is the prop name and the value is\n   * either null or a replacement prop name.\n   */\n\n\n  BaseComponent.prototype._warnDeprecations = function (deprecationMap) {\n    warnDeprecations(this.className, this.props, deprecationMap);\n  };\n  /**\n   * Warns when props which are mutually exclusive with each other are both used.\n   *\n   * @param mutuallyExclusiveMap - The map of mutually exclusive props.\n   */\n\n\n  BaseComponent.prototype._warnMutuallyExclusive = function (mutuallyExclusiveMap) {\n    warnMutuallyExclusive(this.className, this.props, mutuallyExclusiveMap);\n  };\n  /**\n   * Warns when props are required if a condition is met.\n   *\n   * @param requiredProps - The name of the props that are required when the condition is met.\n   * @param conditionalPropName - The name of the prop that the condition is based on.\n   * @param condition - Whether the condition is met.\n   */\n\n\n  BaseComponent.prototype._warnConditionallyRequiredProps = function (requiredProps, conditionalPropName, condition) {\n    warnConditionallyRequiredProps(this.className, this.props, requiredProps, conditionalPropName, condition);\n  };\n\n  BaseComponent.prototype._setComponentRef = function (ref, value) {\n    if (!this._skipComponentRefResolution && ref) {\n      if (typeof ref === 'function') {\n        ref(value);\n      }\n\n      if (typeof ref === 'object') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ref.current = value;\n      }\n    }\n  };\n\n  return BaseComponent;\n}(React.Component);\n\nexport { BaseComponent };\n/**\n * Helper to override a given method with a wrapper method that can try/catch the original, but also\n * ensures that the BaseComponent's methods are called before the subclass's. This ensures that\n * componentWillUnmount in the base is called and that things in the _disposables array are disposed.\n */\n// eslint-disable-next-line deprecation/deprecation\n\nfunction _makeAllSafe(obj, prototype, methodNames) {\n  for (var i = 0, len = methodNames.length; i < len; i++) {\n    _makeSafe(obj, prototype, methodNames[i]);\n  }\n} // eslint-disable-next-line deprecation/deprecation\n\n\nfunction _makeSafe(obj, prototype, methodName) {\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  var classMethod = obj[methodName];\n  var prototypeMethod = prototype[methodName];\n\n  if (classMethod || prototypeMethod) {\n    obj[methodName] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      /* eslint-enable @typescript-eslint/no-explicit-any */\n\n\n      var retVal;\n\n      if (prototypeMethod) {\n        retVal = prototypeMethod.apply(this, args);\n      }\n\n      if (classMethod !== prototypeMethod) {\n        retVal = classMethod.apply(this, args);\n      }\n\n      return retVal;\n    };\n  }\n}\n/**\n * Simple constant function for returning null, used to render empty templates in JSX.\n *\n * @public\n */\n\n\nexport function nullRender() {\n  return null;\n}","map":{"version":3,"sources":["BaseComponent.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Async } from './Async';\nimport { EventGroup } from './EventGroup';\nimport { IDisposable } from './IDisposable';\nimport { ISettingsMap } from './warn/warn';\nimport { warnConditionallyRequiredProps } from './warn/warnConditionallyRequiredProps';\nimport { warnMutuallyExclusive } from './warn/warnMutuallyExclusive';\nimport { warnDeprecations } from './warn/warnDeprecations';\nimport { IRefObject } from './createRef';\nimport { IBaseProps } from './BaseComponent.types';\n\n/**\n * BaseComponent class, which provides basic helpers for all components.\n *\n * @public\n * {@docCategory BaseComponent}\n *\n * @deprecated Do not use. We are moving away from class component.\n */\nexport class BaseComponent<TProps extends IBaseProps = {}, TState = {}> extends React.Component<TProps, TState> {\n  /**\n   * @deprecated Use React's error boundaries instead.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public static onError: (errorMessage?: string, ex?: any) => void;\n\n  /**\n   * Controls whether the componentRef prop will be resolved by this component instance. If you are\n   * implementing a passthrough (higher-order component), you would set this to false and pass through\n   * the props to the inner component, allowing it to resolve the componentRef.\n   */\n  protected _skipComponentRefResolution: boolean;\n\n  private __async: Async;\n  private __events: EventGroup;\n  private __disposables: IDisposable[] | null;\n  private __resolves: { [name: string]: (ref: React.ReactNode) => React.ReactNode };\n  private __className: string;\n\n  /**\n   * BaseComponent constructor\n   * @param props - The props for the component.\n   * @param context - The context for the component.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(props: TProps, context?: any) {\n    super(props, context);\n\n    // eslint-disable-next-line deprecation/deprecation\n    _makeAllSafe(this, BaseComponent.prototype, [\n      'componentDidMount',\n      'shouldComponentUpdate',\n      'getSnapshotBeforeUpdate',\n      'render',\n      'componentDidUpdate',\n      'componentWillUnmount',\n    ]);\n  }\n\n  /**\n   * When the component receives props, make sure the componentRef is updated.\n   */\n  public componentDidUpdate(prevProps: TProps, prevState: TState): void {\n    this._updateComponentRef(prevProps, this.props);\n  }\n\n  /**\n   * When the component has mounted, update the componentRef.\n   */\n  public componentDidMount(): void {\n    this._setComponentRef(this.props.componentRef, this);\n  }\n\n  /**\n   * If we have disposables, dispose them automatically on unmount.\n   */\n  public componentWillUnmount(): void {\n    this._setComponentRef(this.props.componentRef, null);\n\n    if (this.__disposables) {\n      for (let i = 0, len = this._disposables.length; i < len; i++) {\n        let disposable = this.__disposables[i];\n\n        if (disposable.dispose) {\n          disposable.dispose();\n        }\n      }\n      this.__disposables = null;\n    }\n  }\n\n  /**\n   * Gets the object's class name.\n   */\n  public get className(): string {\n    if (!this.__className) {\n      let funcNameRegex = /function (.{1,})\\(/;\n      let results = funcNameRegex.exec(this.constructor.toString());\n\n      this.__className = results && results.length > 1 ? results[1] : '';\n    }\n\n    return this.__className;\n  }\n\n  /**\n   * Allows subclasses to push things to this._disposables to be auto disposed.\n   */\n  protected get _disposables(): IDisposable[] {\n    if (!this.__disposables) {\n      this.__disposables = [];\n    }\n    return this.__disposables;\n  }\n\n  /**\n   * Gets the async instance associated with the component, created on demand. The async instance gives\n   * subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks\n   * will be cleared/ignored automatically after unmounting. The helpers within the async object also\n   * preserve the this pointer so that you don't need to \"bind\" the callbacks.\n   */\n  protected get _async(): Async {\n    if (!this.__async) {\n      this.__async = new Async(this);\n      this._disposables.push(this.__async);\n    }\n\n    return this.__async;\n  }\n\n  /**\n   * Gets the event group instance assocaited with the component, created on demand. The event instance\n   * provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks\n   * will be automatically disconnected after unmounting. The helpers within the events object also\n   * preserve the this reference so that you don't need to \"bind\" the callbacks.\n   */\n  protected get _events(): EventGroup {\n    if (!this.__events) {\n      this.__events = new EventGroup(this);\n      this._disposables.push(this.__events);\n    }\n\n    return this.__events;\n  }\n\n  /**\n   * Helper to return a memoized ref resolver function.\n   * @param refName - Name of the member to assign the ref to.\n   * @returns A function instance keyed from the given refname.\n   * @deprecated Use `createRef` from React.createRef.\n   */\n  protected _resolveRef(refName: string): (ref: React.ReactNode) => React.ReactNode {\n    if (!this.__resolves) {\n      this.__resolves = {};\n    }\n\n    if (!this.__resolves[refName]) {\n      this.__resolves[refName] = (ref: React.ReactNode) => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return ((this as any)[refName] = ref);\n      };\n    }\n\n    return this.__resolves[refName];\n  }\n\n  /**\n   * Updates the componentRef (by calling it with \"this\" when necessary.)\n   */\n  protected _updateComponentRef(currentProps: IBaseProps, newProps: IBaseProps = {}): void {\n    // currentProps *should* always be defined, but verify that just in case a subclass is manually\n    // calling a lifecycle method with no parameters (which has happened) or other odd usage.\n    if (currentProps && newProps && currentProps.componentRef !== newProps.componentRef) {\n      this._setComponentRef(currentProps.componentRef, null);\n      this._setComponentRef(newProps.componentRef, this);\n    }\n  }\n\n  /**\n   * Warns when a deprecated props are being used.\n   *\n   * @param deprecationMap - The map of deprecations, where key is the prop name and the value is\n   * either null or a replacement prop name.\n   */\n  protected _warnDeprecations(deprecationMap: ISettingsMap<TProps>): void {\n    warnDeprecations(this.className, this.props, deprecationMap);\n  }\n\n  /**\n   * Warns when props which are mutually exclusive with each other are both used.\n   *\n   * @param mutuallyExclusiveMap - The map of mutually exclusive props.\n   */\n  protected _warnMutuallyExclusive(mutuallyExclusiveMap: ISettingsMap<TProps>): void {\n    warnMutuallyExclusive(this.className, this.props, mutuallyExclusiveMap);\n  }\n\n  /**\n   * Warns when props are required if a condition is met.\n   *\n   * @param requiredProps - The name of the props that are required when the condition is met.\n   * @param conditionalPropName - The name of the prop that the condition is based on.\n   * @param condition - Whether the condition is met.\n   */\n  protected _warnConditionallyRequiredProps(\n    requiredProps: string[],\n    conditionalPropName: string,\n    condition: boolean,\n  ): void {\n    warnConditionallyRequiredProps(this.className, this.props, requiredProps, conditionalPropName, condition);\n  }\n\n  private _setComponentRef<TRefInterface>(\n    ref: IRefObject<TRefInterface> | undefined,\n    value: TRefInterface | null,\n  ): void {\n    if (!this._skipComponentRefResolution && ref) {\n      if (typeof ref === 'function') {\n        ref(value);\n      }\n\n      if (typeof ref === 'object') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (ref as any).current = value;\n      }\n    }\n  }\n}\n\n/**\n * Helper to override a given method with a wrapper method that can try/catch the original, but also\n * ensures that the BaseComponent's methods are called before the subclass's. This ensures that\n * componentWillUnmount in the base is called and that things in the _disposables array are disposed.\n */\n// eslint-disable-next-line deprecation/deprecation\nfunction _makeAllSafe(obj: BaseComponent<{}, {}>, prototype: Object, methodNames: string[]): void {\n  for (let i = 0, len = methodNames.length; i < len; i++) {\n    _makeSafe(obj, prototype, methodNames[i]);\n  }\n}\n\n// eslint-disable-next-line deprecation/deprecation\nfunction _makeSafe(obj: BaseComponent<{}, {}>, prototype: Object, methodName: string): void {\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  let classMethod = (obj as any)[methodName];\n  let prototypeMethod = (prototype as any)[methodName];\n\n  if (classMethod || prototypeMethod) {\n    (obj as any)[methodName] = function(...args: any[]): any {\n      /* eslint-enable @typescript-eslint/no-explicit-any */\n      let retVal;\n\n      if (prototypeMethod) {\n        retVal = prototypeMethod.apply(this, args);\n      }\n      if (classMethod !== prototypeMethod) {\n        retVal = classMethod.apply(this, args);\n      }\n\n      return retVal;\n    };\n  }\n}\n\n/**\n * Simple constant function for returning null, used to render empty templates in JSX.\n *\n * @public\n */\nexport function nullRender(): JSX.Element | null {\n  return null;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}