{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, classNamesFunction } from '../../Utilities';\nimport { initializeComponentRef } from '@uifabric/utilities';\nvar getClassNames = classNamesFunction();\nvar TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD = 5;\n/**\n * {@docCategory DocumentCard}\n */\n\nvar DocumentCardTitleBase =\n/** @class */\nfunction (_super) {\n  __extends(DocumentCardTitleBase, _super);\n\n  function DocumentCardTitleBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._titleElement = React.createRef();\n    _this._measureTitleElement = React.createRef(); // Truncate logic here way can't handle the case that chars with different widths are mixed very well.\n    // Let _shrinkTitle take care of that.\n\n    _this._truncateTitle = function () {\n      if (!_this.state.needMeasurement) {\n        return;\n      }\n\n      _this._async.requestAnimationFrame(_this._truncateWhenInAnimation);\n    };\n\n    _this._truncateWhenInAnimation = function () {\n      var originalTitle = _this.props.title;\n      var element = _this._measureTitleElement.current;\n\n      if (element) {\n        var style = getComputedStyle(element);\n\n        if (style.width && style.lineHeight && style.height) {\n          var clientWidth = element.clientWidth,\n              scrollWidth = element.scrollWidth;\n          var lines = Math.floor((parseInt(style.height, 10) + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD) / parseInt(style.lineHeight, 10)); // Use overflow to predict truncated length.\n          // Take an example.The text is: A text with A very long text that need to be truncated.ppt\n          // if container is like\n          // |A text with A very| long text that need to be truncated.ppt\n          // The scroll width is 58, (take two | out of length)\n          // The client width is 18\n          // the overflow rate is scrollWidth/clientWidth which should be close to length(overflowText)/length(visualText)\n          // And the length of remaining text should be truncated is (original Length)/(58/18) -3 = 15.\n          // So that the logic can predict truncated text well.\n          // first piece will be `A text `, * second piece will be `ated.ppt`\n          // |A text ...ated.ppt|\n\n          var overFlowRate = scrollWidth / (parseInt(style.width, 10) * lines);\n\n          if (overFlowRate > 1) {\n            var truncatedLength = originalTitle.length / overFlowRate - 3\n            /** Saved for separator */\n            ;\n            return _this.setState({\n              truncatedTitleFirstPiece: originalTitle.slice(0, truncatedLength / 2),\n              truncatedTitleSecondPiece: originalTitle.slice(originalTitle.length - truncatedLength / 2),\n              clientWidth: clientWidth,\n              needMeasurement: false\n            });\n          }\n        }\n      }\n\n      return _this.setState({\n        needMeasurement: false\n      });\n    };\n\n    _this._shrinkTitle = function () {\n      var _a = _this.state,\n          truncatedTitleFirstPiece = _a.truncatedTitleFirstPiece,\n          truncatedTitleSecondPiece = _a.truncatedTitleSecondPiece;\n\n      if (truncatedTitleFirstPiece && truncatedTitleSecondPiece) {\n        var titleElement = _this._titleElement.current;\n\n        if (!titleElement) {\n          return;\n        }\n\n        if (titleElement.scrollHeight > titleElement.clientHeight + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD || titleElement.scrollWidth > titleElement.clientWidth) {\n          _this.setState({\n            truncatedTitleFirstPiece: truncatedTitleFirstPiece.slice(0, truncatedTitleFirstPiece.length - 1),\n            truncatedTitleSecondPiece: truncatedTitleSecondPiece.slice(1)\n          });\n        }\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this.state = {\n      truncatedTitleFirstPiece: '',\n      truncatedTitleSecondPiece: '',\n      previousTitle: props.title,\n      needMeasurement: !!props.shouldTruncate\n    };\n    return _this;\n  }\n\n  DocumentCardTitleBase.prototype.componentDidUpdate = function () {\n    if (this.props.title !== this.state.previousTitle) {\n      this.setState({\n        truncatedTitleFirstPiece: undefined,\n        truncatedTitleSecondPiece: undefined,\n        clientWidth: undefined,\n        previousTitle: this.props.title,\n        needMeasurement: !!this.props.shouldTruncate\n      });\n    }\n\n    this._events.off(window, 'resize', this._updateTruncation);\n\n    if (this.props.shouldTruncate) {\n      this._truncateTitle();\n\n      requestAnimationFrame(this._shrinkTitle);\n\n      this._events.on(window, 'resize', this._updateTruncation);\n    }\n  };\n\n  DocumentCardTitleBase.prototype.componentDidMount = function () {\n    if (this.props.shouldTruncate) {\n      this._truncateTitle();\n\n      this._events.on(window, 'resize', this._updateTruncation);\n    }\n  };\n\n  DocumentCardTitleBase.prototype.componentWillUnmount = function () {\n    this._events.dispose();\n\n    this._async.dispose();\n  };\n\n  DocumentCardTitleBase.prototype.render = function () {\n    var _a = this.props,\n        title = _a.title,\n        shouldTruncate = _a.shouldTruncate,\n        showAsSecondaryTitle = _a.showAsSecondaryTitle,\n        styles = _a.styles,\n        theme = _a.theme,\n        className = _a.className;\n    var _b = this.state,\n        truncatedTitleFirstPiece = _b.truncatedTitleFirstPiece,\n        truncatedTitleSecondPiece = _b.truncatedTitleSecondPiece,\n        needMeasurement = _b.needMeasurement;\n    this._classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      showAsSecondaryTitle: showAsSecondaryTitle\n    });\n    var documentCardTitle;\n\n    if (needMeasurement) {\n      documentCardTitle = React.createElement(\"div\", {\n        className: this._classNames.root,\n        ref: this._measureTitleElement,\n        title: title,\n        style: {\n          whiteSpace: 'nowrap'\n        }\n      }, title);\n    } else if (shouldTruncate && truncatedTitleFirstPiece && truncatedTitleSecondPiece) {\n      documentCardTitle = React.createElement(\"div\", {\n        className: this._classNames.root,\n        ref: this._titleElement,\n        title: title\n      }, truncatedTitleFirstPiece, \"\\u2026\", truncatedTitleSecondPiece);\n    } else {\n      documentCardTitle = React.createElement(\"div\", {\n        className: this._classNames.root,\n        ref: this._titleElement,\n        title: title\n      }, title);\n    }\n\n    return documentCardTitle;\n  };\n\n  DocumentCardTitleBase.prototype._updateTruncation = function () {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      // Only update truncation if the title's size has changed since the last time we truncated\n      if (_this._titleElement.current) {\n        var clientWidth = _this._titleElement.current.clientWidth; // Throttle truncation so that it doesn't happen during a window resize\n\n        clearTimeout(_this._titleTruncationTimer);\n\n        if (_this.state.clientWidth !== clientWidth) {\n          _this._titleTruncationTimer = _this._async.setTimeout(function () {\n            return _this.setState({\n              truncatedTitleFirstPiece: undefined,\n              truncatedTitleSecondPiece: undefined,\n              needMeasurement: true\n            });\n          }, 250);\n        }\n      }\n    });\n  };\n\n  return DocumentCardTitleBase;\n}(React.Component);\n\nexport { DocumentCardTitleBase };","map":{"version":3,"sources":["components/DocumentCard/DocumentCardTitle.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nimport { Async, EventGroup, classNamesFunction } from '../../Utilities';\nimport {\n  IDocumentCardTitleProps,\n  IDocumentCardTitleStyleProps,\n  IDocumentCardTitleStyles,\n} from './DocumentCardTitle.types';\nimport { IProcessedStyleSet } from '../../Styling';\nimport { initializeComponentRef } from '@uifabric/utilities';\n\nconst getClassNames = classNamesFunction<IDocumentCardTitleStyleProps, IDocumentCardTitleStyles>();\n\nexport interface IDocumentCardTitleState {\n  truncatedTitleFirstPiece?: string;\n  truncatedTitleSecondPiece?: string;\n  clientWidth?: number;\n  previousTitle: string;\n\n  /**\n   * In measuring, it will render a same style text with whiteSpace: 'nowrap', to get overflow rate.\n   * So that the logic can predict truncated text well.\n   */\n  needMeasurement: boolean;\n}\n\nconst TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD = 5;\n\n/**\n * {@docCategory DocumentCard}\n */\nexport class DocumentCardTitleBase extends React.Component<IDocumentCardTitleProps, IDocumentCardTitleState> {\n  private _titleElement = React.createRef<HTMLDivElement>();\n  private _measureTitleElement = React.createRef<HTMLDivElement>();\n\n  private _titleTruncationTimer: number;\n  private _classNames: IProcessedStyleSet<IDocumentCardTitleStyles>;\n\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IDocumentCardTitleProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    this.state = {\n      truncatedTitleFirstPiece: '',\n      truncatedTitleSecondPiece: '',\n      previousTitle: props.title,\n      needMeasurement: !!props.shouldTruncate,\n    };\n  }\n\n  public componentDidUpdate(): void {\n    if (this.props.title !== this.state.previousTitle) {\n      this.setState({\n        truncatedTitleFirstPiece: undefined,\n        truncatedTitleSecondPiece: undefined,\n        clientWidth: undefined,\n        previousTitle: this.props.title,\n        needMeasurement: !!this.props.shouldTruncate,\n      });\n    }\n\n    this._events.off(window, 'resize', this._updateTruncation);\n\n    if (this.props.shouldTruncate) {\n      this._truncateTitle();\n      requestAnimationFrame(this._shrinkTitle);\n      this._events.on(window, 'resize', this._updateTruncation);\n    }\n  }\n\n  public componentDidMount(): void {\n    if (this.props.shouldTruncate) {\n      this._truncateTitle();\n      this._events.on(window, 'resize', this._updateTruncation);\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._events.dispose();\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const { title, shouldTruncate, showAsSecondaryTitle, styles, theme, className } = this.props;\n    const { truncatedTitleFirstPiece, truncatedTitleSecondPiece, needMeasurement } = this.state;\n\n    this._classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      showAsSecondaryTitle,\n    });\n\n    let documentCardTitle;\n    if (needMeasurement) {\n      documentCardTitle = (\n        <div\n          className={this._classNames.root}\n          ref={this._measureTitleElement}\n          title={title}\n          style={{ whiteSpace: 'nowrap' }}\n        >\n          {title}\n        </div>\n      );\n    } else if (shouldTruncate && truncatedTitleFirstPiece && truncatedTitleSecondPiece) {\n      documentCardTitle = (\n        <div className={this._classNames.root} ref={this._titleElement} title={title}>\n          {truncatedTitleFirstPiece}\n          &hellip;\n          {truncatedTitleSecondPiece}\n        </div>\n      );\n    } else {\n      documentCardTitle = (\n        <div className={this._classNames.root} ref={this._titleElement} title={title}>\n          {title}\n        </div>\n      );\n    }\n    return documentCardTitle;\n  }\n\n  // Truncate logic here way can't handle the case that chars with different widths are mixed very well.\n  // Let _shrinkTitle take care of that.\n  private _truncateTitle = (): void => {\n    if (!this.state.needMeasurement) {\n      return;\n    }\n\n    this._async.requestAnimationFrame(this._truncateWhenInAnimation);\n  };\n\n  private _truncateWhenInAnimation: () => void = () => {\n    const originalTitle = this.props.title;\n    const element: HTMLDivElement | null = this._measureTitleElement.current;\n\n    if (element) {\n      const style: CSSStyleDeclaration = getComputedStyle(element);\n      if (style.width && style.lineHeight && style.height) {\n        const { clientWidth, scrollWidth } = element;\n        const lines: number = Math.floor(\n          (parseInt(style.height, 10) + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD) / parseInt(style.lineHeight, 10),\n        );\n\n        // Use overflow to predict truncated length.\n        // Take an example.The text is: A text with A very long text that need to be truncated.ppt\n        // if container is like\n        // |A text with A very| long text that need to be truncated.ppt\n        // The scroll width is 58, (take two | out of length)\n        // The client width is 18\n        // the overflow rate is scrollWidth/clientWidth which should be close to length(overflowText)/length(visualText)\n        // And the length of remaining text should be truncated is (original Length)/(58/18) -3 = 15.\n        // So that the logic can predict truncated text well.\n        // first piece will be `A text `, * second piece will be `ated.ppt`\n        // |A text ...ated.ppt|\n        const overFlowRate: number = scrollWidth / (parseInt(style.width, 10) * lines);\n\n        if (overFlowRate > 1) {\n          const truncatedLength: number = originalTitle.length / overFlowRate - 3 /** Saved for separator */;\n          return this.setState({\n            truncatedTitleFirstPiece: originalTitle.slice(0, truncatedLength / 2),\n            truncatedTitleSecondPiece: originalTitle.slice(originalTitle.length - truncatedLength / 2),\n            clientWidth,\n            needMeasurement: false,\n          });\n        }\n      }\n    }\n\n    return this.setState({ needMeasurement: false });\n  };\n\n  private _shrinkTitle: () => void = () => {\n    const { truncatedTitleFirstPiece, truncatedTitleSecondPiece } = this.state;\n    if (truncatedTitleFirstPiece && truncatedTitleSecondPiece) {\n      const titleElement = this._titleElement.current;\n\n      if (!titleElement) {\n        return;\n      }\n\n      if (\n        titleElement.scrollHeight > titleElement.clientHeight + TRUNCATION_VERTICAL_OVERFLOW_THRESHOLD ||\n        titleElement.scrollWidth > titleElement.clientWidth\n      ) {\n        this.setState({\n          truncatedTitleFirstPiece: truncatedTitleFirstPiece.slice(0, truncatedTitleFirstPiece.length - 1),\n          truncatedTitleSecondPiece: truncatedTitleSecondPiece.slice(1),\n        });\n      }\n    }\n  };\n\n  private _updateTruncation(): void {\n    this._async.requestAnimationFrame(() => {\n      // Only update truncation if the title's size has changed since the last time we truncated\n      if (this._titleElement.current) {\n        const clientWidth: number = this._titleElement.current.clientWidth;\n        // Throttle truncation so that it doesn't happen during a window resize\n        clearTimeout(this._titleTruncationTimer);\n        if (this.state.clientWidth !== clientWidth) {\n          this._titleTruncationTimer = this._async.setTimeout(\n            () =>\n              this.setState({\n                truncatedTitleFirstPiece: undefined,\n                truncatedTitleSecondPiece: undefined,\n                needMeasurement: true,\n              }),\n            250,\n          );\n        }\n      }\n    });\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}