{"ast":null,"code":"import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n/**\n * Counter for mounted component that uses focus rectangle.\n * We want to cleanup the listners before last component that uses focus rectangle unmounts.\n */\n\nvar mountCounters = new WeakMap();\n\nfunction setMountCounters(key, delta) {\n  var newValue;\n  var currValue = mountCounters.get(key);\n\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown and mousedown events. (It will only do it once per window,\n *    so it's safe to call this method multiple times.)\n * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname\n *    to the document body, removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user clicks a mouse button, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    document body, removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\n\n\nexport function useFocusRects(rootRef) {\n  React.useEffect(function () {\n    var _a, _b;\n\n    var win = getWindow((_a = rootRef) === null || _a === void 0 ? void 0 : _a.current);\n\n    if (!win || ((_b = win.FabricConfig) === null || _b === void 0 ? void 0 : _b.disableFocusRects) === true) {\n      return undefined;\n    }\n\n    var count = setMountCounters(win, 1);\n\n    if (count <= 1) {\n      win.addEventListener('mousedown', _onMouseDown, true);\n      win.addEventListener('pointerdown', _onPointerDown, true);\n      win.addEventListener('keydown', _onKeyDown, true);\n    }\n\n    return function () {\n      var _a;\n\n      if (!win || ((_a = win.FabricConfig) === null || _a === void 0 ? void 0 : _a.disableFocusRects) === true) {\n        return;\n      }\n\n      count = setMountCounters(win, -1);\n\n      if (count === 0) {\n        win.removeEventListener('mousedown', _onMouseDown, true);\n        win.removeEventListener('pointerdown', _onPointerDown, true);\n        win.removeEventListener('keydown', _onKeyDown, true);\n      }\n    };\n  }, [rootRef]);\n}\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\n\nexport var FocusRects = function (props) {\n  useFocusRects(props.rootRef);\n  return null;\n};\n\nfunction _onMouseDown(ev) {\n  setFocusVisibility(false, ev.target);\n}\n\nfunction _onPointerDown(ev) {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target);\n  }\n}\n\nfunction _onKeyDown(ev) {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target);\n  }\n}","map":{"version":3,"sources":["useFocusRects.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { getWindow } from './dom/getWindow';\nimport { isDirectionalKeyCode } from './keyboard';\nimport { setFocusVisibility } from './setFocusVisibility';\n\n/**\n * Counter for mounted component that uses focus rectangle.\n * We want to cleanup the listners before last component that uses focus rectangle unmounts.\n */\nlet mountCounters = new WeakMap<Window, number>();\n\nfunction setMountCounters(key: Window, delta: number): number {\n  let newValue;\n  const currValue = mountCounters.get(key);\n  if (currValue) {\n    newValue = currValue + delta;\n  } else {\n    newValue = 1;\n  }\n\n  mountCounters.set(key, newValue);\n  return newValue;\n}\n\ntype AppWindow = (Window & { FabricConfig?: { disableFocusRects?: boolean } }) | undefined;\n\n/**\n * Initializes the logic which:\n *\n * 1. Subscribes keydown and mousedown events. (It will only do it once per window,\n *    so it's safe to call this method multiple times.)\n * 2. When the user presses directional keyboard keys, adds the 'ms-Fabric--isFocusVisible' classname\n *    to the document body, removes the 'ms-Fabric-isFocusHidden' classname.\n * 3. When the user clicks a mouse button, adds the 'ms-Fabric-isFocusHidden' classname to the\n *    document body, removes the 'ms-Fabric--isFocusVisible' classname.\n *\n * This logic allows components on the page to conditionally render focus treatments based on\n * the existence of global classnames, which simplifies logic overall.\n *\n * @param rootRef - A Ref object. Focus rectangle can be applied on itself and all its children.\n */\nexport function useFocusRects(rootRef?: React.RefObject<HTMLElement>): void {\n  React.useEffect(() => {\n    const win = getWindow(rootRef?.current) as AppWindow;\n\n    if (!win || win.FabricConfig?.disableFocusRects === true) {\n      return undefined;\n    }\n\n    let count = setMountCounters(win, 1);\n    if (count <= 1) {\n      win.addEventListener('mousedown', _onMouseDown, true);\n      win.addEventListener('pointerdown', _onPointerDown, true);\n      win.addEventListener('keydown', _onKeyDown, true);\n    }\n\n    return () => {\n      if (!win || win.FabricConfig?.disableFocusRects === true) {\n        return;\n      }\n\n      count = setMountCounters(win, -1);\n      if (count === 0) {\n        win.removeEventListener('mousedown', _onMouseDown, true);\n        win.removeEventListener('pointerdown', _onPointerDown, true);\n        win.removeEventListener('keydown', _onKeyDown, true);\n      }\n    };\n  }, [rootRef]);\n}\n\n/**\n * Function Component wrapper which enables calling `useFocusRects` hook.\n * Renders nothing.\n */\nexport const FocusRects: React.FunctionComponent<{ rootRef?: React.RefObject<HTMLElement> }> = props => {\n  useFocusRects(props.rootRef);\n  return null;\n};\n\nfunction _onMouseDown(ev: MouseEvent): void {\n  setFocusVisibility(false, ev.target as Element);\n}\n\nfunction _onPointerDown(ev: PointerEvent): void {\n  if (ev.pointerType !== 'mouse') {\n    setFocusVisibility(false, ev.target as Element);\n  }\n}\n\nfunction _onKeyDown(ev: KeyboardEvent): void {\n  // eslint-disable-next-line deprecation/deprecation\n  if (isDirectionalKeyCode(ev.which)) {\n    setFocusVisibility(true, ev.target as Element);\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}