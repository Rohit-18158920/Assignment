{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport { initializeComponentRef, warnMutuallyExclusive, Async, getId, KeyCodes, customizable, calculatePrecision, precisionRound, mergeAriaAttributeValues, getNativeProps, divProperties } from '../../Utilities';\nimport { Position } from '../../utilities/positioning';\nimport { getStyles, getArrowButtonStyles } from './SpinButton.styles';\nimport { getClassNames } from './SpinButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nexport var KeyboardSpinDirection;\n\n(function (KeyboardSpinDirection) {\n  KeyboardSpinDirection[KeyboardSpinDirection[\"down\"] = -1] = \"down\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"notSpinning\"] = 0] = \"notSpinning\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"up\"] = 1] = \"up\";\n})(KeyboardSpinDirection || (KeyboardSpinDirection = {}));\n\nvar SpinButton =\n/** @class */\nfunction (_super) {\n  __extends(SpinButton, _super);\n\n  function SpinButton(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._input = React.createRef();\n    _this._initialStepDelay = 400;\n    _this._stepDelay = 75;\n\n    _this._onFocus = function (ev) {\n      // We can't set focus on a non-existing element\n      if (!_this._input.current) {\n        return;\n      }\n\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._stop();\n      }\n\n      _this._input.current.select();\n\n      _this.setState({\n        isFocused: true\n      });\n\n      if (_this.props.onFocus) {\n        _this.props.onFocus(ev);\n      }\n    };\n\n    _this._onBlur = function (ev) {\n      _this._validate(ev);\n\n      _this.setState({\n        isFocused: false\n      });\n\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n    };\n\n    _this._onValidate = function (value, event) {\n      if (_this.props.onValidate) {\n        return _this.props.onValidate(value, event);\n      } else {\n        return _this._defaultOnValidate(value);\n      }\n    };\n\n    _this._calculatePrecision = function (props) {\n      var _a = props.precision,\n          precision = _a === void 0 ? Math.max(calculatePrecision(props.step), 0) : _a;\n      return precision;\n    };\n    /**\n     * Validate function to use if one is not passed in\n     */\n\n\n    _this._defaultOnValidate = function (value) {\n      if (value === null || value.trim().length === 0 || isNaN(Number(value))) {\n        return _this._lastValidValue;\n      }\n\n      var newValue = Math.min(_this.props.max, Math.max(_this.props.min, Number(value)));\n      return String(newValue);\n    };\n\n    _this._onIncrement = function (value, event) {\n      if (_this.props.onIncrement) {\n        return _this.props.onIncrement(value, event);\n      } else {\n        return _this._defaultOnIncrement(value);\n      }\n    };\n    /**\n     * Increment function to use if one is not passed in\n     */\n\n\n    _this._defaultOnIncrement = function (value) {\n      var _a = _this.props,\n          max = _a.max,\n          step = _a.step;\n      var newValue = Math.min(Number(value) + Number(step), max);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n\n    _this._onDecrement = function (value, event) {\n      if (_this.props.onDecrement) {\n        return _this.props.onDecrement(value, event);\n      } else {\n        return _this._defaultOnDecrement(value);\n      }\n    };\n    /**\n     * Increment function to use if one is not passed in\n     */\n\n\n    _this._defaultOnDecrement = function (value) {\n      var _a = _this.props,\n          min = _a.min,\n          step = _a.step;\n      var newValue = Math.max(Number(value) - Number(step), min);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n    /**\n     * This is used when validating text entry in the input on blur or when enter key is pressed\n     * (not when changed via the buttons).\n     * @param event - the event that fired\n     */\n\n\n    _this._validate = function (event) {\n      if (_this.value !== undefined && _this._valueToValidate !== undefined && _this._valueToValidate !== _this._lastValidValue) {\n        var newValue = _this._onValidate(_this._valueToValidate, event); // Done validating this value, so clear it\n\n\n        _this._valueToValidate = undefined;\n\n        if (newValue !== undefined) {\n          _this._lastValidValue = newValue;\n\n          _this.setState({\n            value: newValue\n          });\n        } else {\n          // Value was invalid. Reset state to last valid value.\n          _this.setState({\n            value: _this._lastValidValue\n          });\n        }\n      }\n    };\n    /**\n     * The method is needed to ensure we are updating the actual input value.\n     * without this our value will never change (and validation will not have the correct number)\n     * @param event - the event that was fired\n     */\n\n\n    _this._onInputChange = function (event) {\n      var element = event.target;\n      var value = element.value;\n      _this._valueToValidate = value;\n\n      _this.setState({\n        value: value\n      });\n    };\n    /**\n     * Update the value with the given stepFunction\n     * @param shouldSpin - should we fire off another updateValue when we are done here? This should be true\n     * when spinning in response to a mouseDown\n     * @param stepFunction - function to use to step by\n     * @param event - The event that triggered the updateValue\n     */\n\n\n    _this._updateValue = function (shouldSpin, stepDelay, stepFunction, event) {\n      var newValue = stepFunction(_this.value || '', event);\n\n      if (newValue !== undefined) {\n        _this._lastValidValue = newValue;\n\n        _this.setState({\n          value: newValue\n        });\n      }\n\n      if (_this._spinningByMouse !== shouldSpin) {\n        _this._spinningByMouse = shouldSpin;\n      }\n\n      if (shouldSpin) {\n        _this._currentStepFunctionHandle = _this._async.setTimeout(function () {\n          _this._updateValue(shouldSpin, _this._stepDelay, stepFunction, event);\n        }, stepDelay);\n      }\n    };\n    /**\n     * Stop spinning (clear any currently pending update and set spinning to false)\n     */\n\n\n    _this._stop = function () {\n      if (_this._currentStepFunctionHandle >= 0) {\n        _this._async.clearTimeout(_this._currentStepFunctionHandle);\n\n        _this._currentStepFunctionHandle = -1;\n      }\n\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._spinningByMouse = false;\n\n        _this.setState({\n          keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n        });\n      }\n    };\n    /**\n     * Handle keydown on the text field. We need to update\n     * the value when up or down arrow are depressed\n     * @param event - the keyboardEvent that was fired\n     */\n\n\n    _this._handleKeyDown = function (event) {\n      // eat the up and down arrow keys to keep focus in the spinButton\n      // (especially when a spinButton is inside of a FocusZone)\n      if (event.which === KeyCodes.up || event.which === KeyCodes.down || event.which === KeyCodes.enter) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      if (_this.props.disabled) {\n        _this._stop();\n\n        return;\n      }\n\n      var spinDirection = KeyboardSpinDirection.notSpinning;\n\n      switch (event.which) {\n        case KeyCodes.up:\n          spinDirection = KeyboardSpinDirection.up;\n\n          _this._updateValue(false\n          /* shouldSpin */\n          , _this._initialStepDelay, _this._onIncrement, event);\n\n          break;\n\n        case KeyCodes.down:\n          spinDirection = KeyboardSpinDirection.down;\n\n          _this._updateValue(false\n          /* shouldSpin */\n          , _this._initialStepDelay, _this._onDecrement, event);\n\n          break;\n\n        case KeyCodes.enter:\n          _this._validate(event);\n\n          break;\n\n        case KeyCodes.escape:\n          if (_this.value !== _this._lastValidValue) {\n            _this.setState({\n              value: _this._lastValidValue\n            });\n          }\n\n          break;\n\n        default:\n          break;\n      } // style the increment/decrement button to look active\n      // when the corresponding up/down arrow keys trigger a step\n\n\n      if (_this.state.keyboardSpinDirection !== spinDirection) {\n        _this.setState({\n          keyboardSpinDirection: spinDirection\n        });\n      }\n    };\n    /**\n     * Make sure that we have stopped spinning on keyUp\n     * if the up or down arrow fired this event\n     * @param event - keyboard event\n     */\n\n\n    _this._handleKeyUp = function (event) {\n      if (_this.props.disabled || event.which === KeyCodes.up || event.which === KeyCodes.down) {\n        _this._stop();\n\n        return;\n      }\n    };\n\n    _this._onIncrementMouseDown = function (event) {\n      _this._updateValue(true\n      /* shouldSpin */\n      , _this._initialStepDelay, _this._onIncrement, event);\n    };\n\n    _this._onDecrementMouseDown = function (event) {\n      _this._updateValue(true\n      /* shouldSpin */\n      , _this._initialStepDelay, _this._onDecrement, event);\n    };\n\n    initializeComponentRef(_this);\n    warnMutuallyExclusive('SpinButton', props, {\n      value: 'defaultValue'\n    }); // Don't use || here because it won't handle empty strings properly\n\n    var _a = props.value,\n        value = _a === void 0 ? props.defaultValue : _a;\n\n    if (value === undefined) {\n      value = typeof props.min === 'number' ? String(props.min) : '0';\n    }\n\n    _this._lastValidValue = value; // Ensure that the autocalculated precision is not negative.\n\n    _this._precision = _this._calculatePrecision(props);\n    _this.state = {\n      isFocused: false,\n      value: value,\n      keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n    };\n    _this._async = new Async(_this);\n    _this._currentStepFunctionHandle = -1;\n    _this._labelId = getId('Label');\n    _this._inputId = getId('input');\n    _this._spinningByMouse = false;\n    _this._valueToValidate = undefined;\n    return _this;\n  }\n\n  SpinButton.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n  /**\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\n   */\n\n\n  SpinButton.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    if (newProps.value !== undefined) {\n      // Value from props is considered pre-validated\n      this._lastValidValue = newProps.value;\n      this.setState({\n        value: newProps.value\n      });\n    }\n\n    this._precision = this._calculatePrecision(newProps);\n  };\n\n  SpinButton.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disabled = _a.disabled,\n        label = _a.label,\n        min = _a.min,\n        max = _a.max,\n        labelPosition = _a.labelPosition,\n        iconProps = _a.iconProps,\n        incrementButtonIcon = _a.incrementButtonIcon,\n        incrementButtonAriaLabel = _a.incrementButtonAriaLabel,\n        decrementButtonIcon = _a.decrementButtonIcon,\n        decrementButtonAriaLabel = _a.decrementButtonAriaLabel,\n        ariaLabel = _a.ariaLabel,\n        ariaDescribedBy = _a.ariaDescribedBy,\n        customStyles = _a.styles,\n        customUpArrowButtonStyles = _a.upArrowButtonStyles,\n        customDownArrowButtonStyles = _a.downArrowButtonStyles,\n        theme = _a.theme,\n        ariaPositionInSet = _a.ariaPositionInSet,\n        ariaSetSize = _a.ariaSetSize,\n        ariaValueNow = _a.ariaValueNow,\n        ariaValueText = _a.ariaValueText,\n        keytipProps = _a.keytipProps,\n        className = _a.className,\n        inputProps = _a.inputProps,\n        iconButtonProps = _a.iconButtonProps;\n    var _b = this.state,\n        isFocused = _b.isFocused,\n        keyboardSpinDirection = _b.keyboardSpinDirection;\n    var value = this.value;\n    var classNames = this.props.getClassNames ? this.props.getClassNames(theme, disabled, isFocused, keyboardSpinDirection, labelPosition, className) : getClassNames(getStyles(theme, customStyles), disabled, isFocused, keyboardSpinDirection, labelPosition, className);\n    var nativeProps = getNativeProps(this.props, divProperties, ['onBlur', 'onFocus', 'className']);\n    return React.createElement(\"div\", {\n      className: classNames.root\n    }, labelPosition !== Position.bottom && (iconProps || label) && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, __assign({}, iconProps, {\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    })), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label,\n      disabled: disabled\n    }, label)), React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return React.createElement(\"div\", __assign({}, nativeProps, {\n        className: classNames.spinButtonWrapper,\n        \"aria-label\": ariaLabel && ariaLabel,\n        \"aria-posinset\": ariaPositionInSet,\n        \"aria-setsize\": ariaSetSize,\n        \"data-ktp-target\": keytipAttributes['data-ktp-target']\n      }), React.createElement(\"input\", __assign({\n        value: value,\n        id: _this._inputId,\n        onChange: _this._onChange,\n        onInput: _this._onInputChange,\n        className: classNames.input,\n        type: \"text\",\n        autoComplete: \"off\",\n        role: \"spinbutton\",\n        \"aria-labelledby\": label && _this._labelId,\n        \"aria-valuenow\": typeof ariaValueNow === 'number' ? ariaValueNow : value && !isNaN(Number(value)) // Number('') is 0 which may not be desirable\n        ? Number(value) : undefined,\n        \"aria-valuetext\": typeof ariaValueText === 'string' ? ariaValueText : !value || isNaN(Number(value)) // Number('') is 0 which may not be desirable\n        ? value : undefined,\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-describedby\": mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby']),\n        onBlur: _this._onBlur,\n        ref: _this._input,\n        onFocus: _this._onFocus,\n        onKeyDown: _this._handleKeyDown,\n        onKeyUp: _this._handleKeyUp,\n        disabled: disabled,\n        \"aria-disabled\": disabled,\n        \"data-lpignore\": true,\n        \"data-ktp-execute-target\": keytipAttributes['data-ktp-execute-target']\n      }, inputProps)), React.createElement(\"span\", {\n        className: classNames.arrowBox\n      }, React.createElement(IconButton, __assign({\n        styles: getArrowButtonStyles(theme, true, customUpArrowButtonStyles),\n        className: 'ms-UpButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.up,\n        disabled: disabled,\n        iconProps: incrementButtonIcon,\n        onMouseDown: _this._onIncrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: incrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      }, iconButtonProps)), React.createElement(IconButton, __assign({\n        styles: getArrowButtonStyles(theme, false, customDownArrowButtonStyles),\n        className: 'ms-DownButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.down,\n        disabled: disabled,\n        iconProps: decrementButtonIcon,\n        onMouseDown: _this._onDecrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: decrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      }, iconButtonProps))));\n    }), labelPosition === Position.bottom && (iconProps || label) && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, {\n      iconName: iconProps.iconName,\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    }), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label,\n      disabled: disabled\n    }, label)));\n  };\n\n  SpinButton.prototype.focus = function () {\n    if (this._input.current) {\n      this._input.current.focus();\n    }\n  };\n\n  Object.defineProperty(SpinButton.prototype, \"value\", {\n    /**\n     * Gets the value of the spin button.\n     */\n    get: function () {\n      // TODO (version 8): value from props should ALWAYS override value from state.\n      // In a class component the code should be:\n      // const { value = this.state.value } = this.props;\n      // return value;\n      return this.state.value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SpinButton.prototype._onChange = function () {\n    /**\n     * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n     * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n     * The no-op onChange handler was still needed because React gives console errors if an input\n     * doesn't have onChange.\n     *\n     * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n     * ours or 3rd-party, which simulate entering text in a SpinButton)\n     */\n  };\n\n  SpinButton.defaultProps = {\n    step: 1,\n    min: 0,\n    max: 100,\n    disabled: false,\n    labelPosition: Position.start,\n    label: '',\n    incrementButtonIcon: {\n      iconName: 'ChevronUpSmall'\n    },\n    decrementButtonIcon: {\n      iconName: 'ChevronDownSmall'\n    }\n  };\n  SpinButton = __decorate([customizable('SpinButton', ['theme', 'styles'], true)], SpinButton);\n  return SpinButton;\n}(React.Component);\n\nexport { SpinButton };","map":{"version":3,"sources":["components/SpinButton/SpinButton.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport {\n  initializeComponentRef,\n  warnMutuallyExclusive,\n  Async,\n  getId,\n  KeyCodes,\n  customizable,\n  calculatePrecision,\n  precisionRound,\n  mergeAriaAttributeValues,\n  getNativeProps,\n  divProperties,\n} from '../../Utilities';\nimport { ISpinButton, ISpinButtonProps } from './SpinButton.types';\nimport { Position } from '../../utilities/positioning';\nimport { getStyles, getArrowButtonStyles } from './SpinButton.styles';\nimport { getClassNames } from './SpinButton.classNames';\nimport { KeytipData } from '../../KeytipData';\n\nexport enum KeyboardSpinDirection {\n  down = -1,\n  notSpinning = 0,\n  up = 1,\n}\n\nexport interface ISpinButtonState {\n  /**\n   * Is true when the control has focus.\n   */\n  isFocused: boolean;\n\n  /**\n   * the value of the spin button\n   */\n  value: string;\n\n  /**\n   * keyboard spin direction, used to style the up or down button\n   * as active when up/down arrow is pressed\n   */\n  keyboardSpinDirection: KeyboardSpinDirection;\n}\n\n// TODO (Fabric Next): remove default min/max values (issue #11358).\nexport type DefaultProps = Required<\n  Pick<\n    ISpinButtonProps,\n    'step' | 'min' | 'max' | 'disabled' | 'labelPosition' | 'label' | 'incrementButtonIcon' | 'decrementButtonIcon'\n  >\n>;\n\n/** Internal only props */\ntype ISpinButtonInternalProps = ISpinButtonProps & DefaultProps;\n\n@customizable('SpinButton', ['theme', 'styles'], true)\nexport class SpinButton extends React.Component<ISpinButtonProps, ISpinButtonState> implements ISpinButton {\n  public static defaultProps: DefaultProps = {\n    step: 1,\n    min: 0,\n    max: 100,\n    disabled: false,\n    labelPosition: Position.start,\n    label: '',\n    incrementButtonIcon: { iconName: 'ChevronUpSmall' },\n    decrementButtonIcon: { iconName: 'ChevronDownSmall' },\n  };\n\n  private _async: Async;\n  private _input = React.createRef<HTMLInputElement>();\n  private _inputId: string;\n  private _labelId: string;\n  private _lastValidValue: string;\n  private _spinningByMouse: boolean;\n  private _valueToValidate: string | undefined; // To avoid duplicate validations/submissions\n  private _precision: number;\n\n  private _currentStepFunctionHandle: number;\n  private _initialStepDelay = 400;\n  private _stepDelay = 75;\n\n  constructor(props: ISpinButtonProps) {\n    super(props);\n\n    initializeComponentRef(this);\n\n    warnMutuallyExclusive('SpinButton', props, {\n      value: 'defaultValue',\n    });\n\n    // Don't use || here because it won't handle empty strings properly\n    let { value = props.defaultValue } = props;\n    if (value === undefined) {\n      value = typeof props.min === 'number' ? String(props.min) : '0';\n    }\n    this._lastValidValue = value;\n\n    // Ensure that the autocalculated precision is not negative.\n    this._precision = this._calculatePrecision(props as ISpinButtonInternalProps);\n\n    this.state = {\n      isFocused: false,\n      value,\n      keyboardSpinDirection: KeyboardSpinDirection.notSpinning,\n    };\n\n    this._async = new Async(this);\n    this._currentStepFunctionHandle = -1;\n    this._labelId = getId('Label');\n    this._inputId = getId('input');\n    this._spinningByMouse = false;\n    this._valueToValidate = undefined;\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n  }\n\n  /**\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\n   */\n  public UNSAFE_componentWillReceiveProps(newProps: ISpinButtonProps): void {\n    if (newProps.value !== undefined) {\n      // Value from props is considered pre-validated\n      this._lastValidValue = newProps.value;\n      this.setState({ value: newProps.value });\n    }\n    this._precision = this._calculatePrecision(newProps as ISpinButtonProps & DefaultProps);\n  }\n\n  public render(): JSX.Element {\n    const {\n      disabled,\n      label,\n      min,\n      max,\n      labelPosition,\n      iconProps,\n      incrementButtonIcon,\n      incrementButtonAriaLabel,\n      decrementButtonIcon,\n      decrementButtonAriaLabel,\n      ariaLabel,\n      ariaDescribedBy,\n      styles: customStyles,\n      upArrowButtonStyles: customUpArrowButtonStyles,\n      downArrowButtonStyles: customDownArrowButtonStyles,\n      theme,\n      ariaPositionInSet,\n      ariaSetSize,\n      ariaValueNow,\n      ariaValueText,\n      keytipProps,\n      className,\n      inputProps,\n      iconButtonProps,\n    } = this.props as ISpinButtonInternalProps;\n\n    const { isFocused, keyboardSpinDirection } = this.state;\n    const value = this.value;\n\n    const classNames = this.props.getClassNames\n      ? this.props.getClassNames(theme!, disabled, isFocused, keyboardSpinDirection, labelPosition, className)\n      : getClassNames(\n          getStyles(theme!, customStyles),\n          disabled,\n          isFocused,\n          keyboardSpinDirection,\n          labelPosition,\n          className,\n        );\n\n    const nativeProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties, [\n      'onBlur',\n      'onFocus',\n      'className',\n    ]);\n\n    return (\n      <div className={classNames.root}>\n        {labelPosition !== Position.bottom && (iconProps || label) && (\n          <div className={classNames.labelWrapper}>\n            {iconProps && <Icon {...iconProps} className={classNames.icon} aria-hidden=\"true\" />}\n            {label && (\n              <Label id={this._labelId} htmlFor={this._inputId} className={classNames.label} disabled={disabled}>\n                {label}\n              </Label>\n            )}\n          </div>\n        )}\n        <KeytipData keytipProps={keytipProps} disabled={disabled}>\n          {(keytipAttributes: any): JSX.Element => (\n            <div\n              {...nativeProps}\n              className={classNames.spinButtonWrapper}\n              aria-label={ariaLabel && ariaLabel}\n              aria-posinset={ariaPositionInSet}\n              aria-setsize={ariaSetSize}\n              data-ktp-target={keytipAttributes['data-ktp-target']}\n            >\n              <input\n                value={value}\n                id={this._inputId}\n                onChange={this._onChange}\n                onInput={this._onInputChange}\n                className={classNames.input}\n                type=\"text\"\n                autoComplete=\"off\"\n                role=\"spinbutton\"\n                aria-labelledby={label && this._labelId}\n                aria-valuenow={\n                  typeof ariaValueNow === 'number'\n                    ? ariaValueNow\n                    : value && !isNaN(Number(value)) // Number('') is 0 which may not be desirable\n                    ? Number(value)\n                    : undefined\n                }\n                aria-valuetext={\n                  typeof ariaValueText === 'string'\n                    ? ariaValueText\n                    : !value || isNaN(Number(value)) // Number('') is 0 which may not be desirable\n                    ? value\n                    : undefined\n                }\n                aria-valuemin={min}\n                aria-valuemax={max}\n                aria-describedby={mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby'])}\n                onBlur={this._onBlur}\n                ref={this._input}\n                onFocus={this._onFocus}\n                onKeyDown={this._handleKeyDown}\n                onKeyUp={this._handleKeyUp}\n                disabled={disabled}\n                aria-disabled={disabled}\n                data-lpignore={true}\n                data-ktp-execute-target={keytipAttributes['data-ktp-execute-target']}\n                {...inputProps}\n              />\n              <span className={classNames.arrowBox}>\n                <IconButton\n                  styles={getArrowButtonStyles(theme!, true, customUpArrowButtonStyles)}\n                  className={'ms-UpButton'}\n                  checked={keyboardSpinDirection === KeyboardSpinDirection.up}\n                  disabled={disabled}\n                  iconProps={incrementButtonIcon}\n                  onMouseDown={this._onIncrementMouseDown}\n                  onMouseLeave={this._stop}\n                  onMouseUp={this._stop}\n                  tabIndex={-1}\n                  ariaLabel={incrementButtonAriaLabel}\n                  data-is-focusable={false}\n                  {...iconButtonProps}\n                />\n                <IconButton\n                  styles={getArrowButtonStyles(theme!, false, customDownArrowButtonStyles)}\n                  className={'ms-DownButton'}\n                  checked={keyboardSpinDirection === KeyboardSpinDirection.down}\n                  disabled={disabled}\n                  iconProps={decrementButtonIcon}\n                  onMouseDown={this._onDecrementMouseDown}\n                  onMouseLeave={this._stop}\n                  onMouseUp={this._stop}\n                  tabIndex={-1}\n                  ariaLabel={decrementButtonAriaLabel}\n                  data-is-focusable={false}\n                  {...iconButtonProps}\n                />\n              </span>\n            </div>\n          )}\n        </KeytipData>\n        {labelPosition === Position.bottom && (iconProps || label) && (\n          <div className={classNames.labelWrapper}>\n            {iconProps && <Icon iconName={iconProps.iconName} className={classNames.icon} aria-hidden=\"true\" />}\n            {label && (\n              <Label id={this._labelId} htmlFor={this._inputId} className={classNames.label} disabled={disabled}>\n                {label}\n              </Label>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  public focus(): void {\n    if (this._input.current) {\n      this._input.current.focus();\n    }\n  }\n\n  /**\n   * Gets the value of the spin button.\n   */\n  public get value(): string | undefined {\n    // TODO (version 8): value from props should ALWAYS override value from state.\n    // In a class component the code should be:\n    // const { value = this.state.value } = this.props;\n    // return value;\n    return this.state.value;\n  }\n\n  private _onFocus = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    // We can't set focus on a non-existing element\n    if (!this._input.current) {\n      return;\n    }\n\n    if (this._spinningByMouse || this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      this._stop();\n    }\n\n    this._input.current.select();\n\n    this.setState({ isFocused: true });\n\n    if (this.props.onFocus) {\n      this.props.onFocus(ev);\n    }\n  };\n\n  private _onBlur = (ev: React.FocusEvent<HTMLInputElement>): void => {\n    this._validate(ev);\n    this.setState({ isFocused: false });\n    if (this.props.onBlur) {\n      this.props.onBlur(ev);\n    }\n  };\n\n  private _onValidate = (value: string, event?: React.SyntheticEvent<HTMLElement>): string | void => {\n    if (this.props.onValidate) {\n      return this.props.onValidate(value, event);\n    } else {\n      return this._defaultOnValidate(value);\n    }\n  };\n\n  private _calculatePrecision = (props: ISpinButtonProps & DefaultProps) => {\n    const { precision = Math.max(calculatePrecision(props.step), 0) } = props;\n    return precision;\n  };\n\n  /**\n   * Validate function to use if one is not passed in\n   */\n  private _defaultOnValidate = (value: string) => {\n    if (value === null || value.trim().length === 0 || isNaN(Number(value))) {\n      return this._lastValidValue;\n    }\n    const newValue = Math.min(this.props.max as number, Math.max(this.props.min as number, Number(value)));\n    return String(newValue);\n  };\n\n  private _onIncrement = (\n    value: string,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): string | void => {\n    if (this.props.onIncrement) {\n      return this.props.onIncrement(value, event);\n    } else {\n      return this._defaultOnIncrement(value);\n    }\n  };\n\n  /**\n   * Increment function to use if one is not passed in\n   */\n  private _defaultOnIncrement = (value: string): string | void => {\n    const { max, step } = this.props as ISpinButtonInternalProps;\n    let newValue: number = Math.min(Number(value) + Number(step), max);\n    newValue = precisionRound(newValue, this._precision);\n    return String(newValue);\n  };\n\n  private _onDecrement = (\n    value: string,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): string | void => {\n    if (this.props.onDecrement) {\n      return this.props.onDecrement(value, event);\n    } else {\n      return this._defaultOnDecrement(value);\n    }\n  };\n\n  /**\n   * Increment function to use if one is not passed in\n   */\n  private _defaultOnDecrement = (value: string): string | void => {\n    const { min, step } = this.props as ISpinButtonInternalProps;\n    let newValue: number = Math.max(Number(value) - Number(step), min);\n    newValue = precisionRound(newValue, this._precision);\n    return String(newValue);\n  };\n\n  private _onChange(): void {\n    /**\n     * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n     * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n     * The no-op onChange handler was still needed because React gives console errors if an input\n     * doesn't have onChange.\n     *\n     * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n     * ours or 3rd-party, which simulate entering text in a SpinButton)\n     */\n  }\n\n  /**\n   * This is used when validating text entry in the input on blur or when enter key is pressed\n   * (not when changed via the buttons).\n   * @param event - the event that fired\n   */\n  private _validate = (event: React.FocusEvent<HTMLInputElement> | React.KeyboardEvent<HTMLInputElement>): void => {\n    if (\n      this.value !== undefined &&\n      this._valueToValidate !== undefined &&\n      this._valueToValidate !== this._lastValidValue\n    ) {\n      const newValue = this._onValidate!(this._valueToValidate, event);\n      // Done validating this value, so clear it\n      this._valueToValidate = undefined;\n\n      if (newValue !== undefined) {\n        this._lastValidValue = newValue;\n        this.setState({ value: newValue });\n      } else {\n        // Value was invalid. Reset state to last valid value.\n        this.setState({ value: this._lastValidValue });\n      }\n    }\n  };\n\n  /**\n   * The method is needed to ensure we are updating the actual input value.\n   * without this our value will never change (and validation will not have the correct number)\n   * @param event - the event that was fired\n   */\n  private _onInputChange = (event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>): void => {\n    const element: HTMLInputElement = event.target as HTMLInputElement;\n    const value: string = element.value;\n    this._valueToValidate = value;\n    this.setState({\n      value: value,\n    });\n  };\n\n  /**\n   * Update the value with the given stepFunction\n   * @param shouldSpin - should we fire off another updateValue when we are done here? This should be true\n   * when spinning in response to a mouseDown\n   * @param stepFunction - function to use to step by\n   * @param event - The event that triggered the updateValue\n   */\n  private _updateValue = (\n    shouldSpin: boolean,\n    stepDelay: number,\n    stepFunction: (\n      value: string,\n      event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n    ) => string | void,\n    event?: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>,\n  ): void => {\n    const newValue: string | void = stepFunction(this.value || '', event);\n    if (newValue !== undefined) {\n      this._lastValidValue = newValue;\n      this.setState({ value: newValue });\n    }\n\n    if (this._spinningByMouse !== shouldSpin) {\n      this._spinningByMouse = shouldSpin;\n    }\n\n    if (shouldSpin) {\n      this._currentStepFunctionHandle = this._async.setTimeout(() => {\n        this._updateValue(shouldSpin, this._stepDelay, stepFunction, event);\n      }, stepDelay);\n    }\n  };\n\n  /**\n   * Stop spinning (clear any currently pending update and set spinning to false)\n   */\n  private _stop = (): void => {\n    if (this._currentStepFunctionHandle >= 0) {\n      this._async.clearTimeout(this._currentStepFunctionHandle);\n      this._currentStepFunctionHandle = -1;\n    }\n\n    if (this._spinningByMouse || this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n      this._spinningByMouse = false;\n      this.setState({ keyboardSpinDirection: KeyboardSpinDirection.notSpinning });\n    }\n  };\n\n  /**\n   * Handle keydown on the text field. We need to update\n   * the value when up or down arrow are depressed\n   * @param event - the keyboardEvent that was fired\n   */\n  private _handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>): void => {\n    // eat the up and down arrow keys to keep focus in the spinButton\n    // (especially when a spinButton is inside of a FocusZone)\n    if (event.which === KeyCodes.up || event.which === KeyCodes.down || event.which === KeyCodes.enter) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (this.props.disabled) {\n      this._stop();\n      return;\n    }\n\n    let spinDirection = KeyboardSpinDirection.notSpinning;\n\n    switch (event.which) {\n      case KeyCodes.up:\n        spinDirection = KeyboardSpinDirection.up;\n        this._updateValue(false /* shouldSpin */, this._initialStepDelay, this._onIncrement!, event);\n        break;\n      case KeyCodes.down:\n        spinDirection = KeyboardSpinDirection.down;\n        this._updateValue(false /* shouldSpin */, this._initialStepDelay, this._onDecrement!, event);\n        break;\n      case KeyCodes.enter:\n        this._validate(event);\n        break;\n      case KeyCodes.escape:\n        if (this.value !== this._lastValidValue) {\n          this.setState({ value: this._lastValidValue });\n        }\n        break;\n      default:\n        break;\n    }\n\n    // style the increment/decrement button to look active\n    // when the corresponding up/down arrow keys trigger a step\n    if (this.state.keyboardSpinDirection !== spinDirection) {\n      this.setState({ keyboardSpinDirection: spinDirection });\n    }\n  };\n\n  /**\n   * Make sure that we have stopped spinning on keyUp\n   * if the up or down arrow fired this event\n   * @param event - keyboard event\n   */\n  private _handleKeyUp = (event: React.KeyboardEvent<HTMLElement>): void => {\n    if (this.props.disabled || event.which === KeyCodes.up || event.which === KeyCodes.down) {\n      this._stop();\n      return;\n    }\n  };\n\n  private _onIncrementMouseDown = (event: React.MouseEvent<HTMLElement>): void => {\n    this._updateValue(true /* shouldSpin */, this._initialStepDelay, this._onIncrement!, event);\n  };\n\n  private _onDecrementMouseDown = (event: React.MouseEvent<HTMLElement>): void => {\n    this._updateValue(true /* shouldSpin */, this._initialStepDelay, this._onDecrement!, event);\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}