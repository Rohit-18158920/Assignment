{"ast":null,"code":"var DEFAULT_HEIGHT = '50%';\nvar DEFAULT_WIDTH = 20;\n/**\n * - Generates a style used to fade out an overflowing content by defining a style for an :after pseudo element.\n * - Apply it to the :after selector for all combination of states the parent of content might have (normal, hover,\n * selected, focus).\n * - Requires the target to have position set to relative and overflow set to hidden.\n *\n * @example\n * ```tsx\n * // Assuming the following DOM structure and the different background colors coming from\n * // the parent holding the content.\n * <div className={classNames.parent}>\n *   <span className={classNames.content}>Overflown Content</span>\n * </div>\n * ```\n * ```ts\n * // This is how the style set would look in Component.styles.ts\n * const { bodyBackground } = theme.semanticColors;\n * const { neutralLighter } = theme.palette;\n *\n * // The second argument of getFadedOverflowStyle function is a string representing a key of\n * // ISemanticColors or IPalette.\n *\n * const styles = {\n *   parent: [\n *     backgroundColor: bodyBackground,\n *     selectors: {\n *       '&:hover: {\n *         backgroundColor: neutralLighter\n *       },\n *       '$content:after': {\n *         ...getFadedOverflowStyle(theme, 'bodyBackground')\n *       },\n *       '&:hover $content:after': {\n *         ...getFadedOverflowStyle(theme, 'neutralLighter')\n *       }\n *     }\n *   ],\n *   content: [\n *     width: '100%',\n *     display: 'inline-block',\n *     position: 'relative',\n *     overflow: 'hidden'\n *   ]\n * }\n * ```\n * @param theme - The theme object to use.\n * @param color - The background color to fade out to. Accepts only keys of ISemanticColors or IPalette.\n * Defaults to 'bodyBackground'.\n * @param direction - The direction of the overflow. Defaults to horizontal.\n * @param width - The width of the fading overflow. Vertical direction defaults it to 100% vs 20px when horizontal.\n * @param height - The Height of the fading overflow. Vertical direction defaults it to 50% vs 100% when horizontal.\n * @returns The style object.\n */\n\nexport function getFadedOverflowStyle(theme, color, direction, width, height) {\n  if (color === void 0) {\n    color = 'bodyBackground';\n  }\n\n  if (direction === void 0) {\n    direction = 'horizontal';\n  }\n\n  if (width === void 0) {\n    width = getDefaultValue('width', direction);\n  }\n\n  if (height === void 0) {\n    height = getDefaultValue('height', direction);\n  } // Get the color value string from the theme semanticColors or palette.\n\n\n  var colorValue = theme.semanticColors[color] || theme.palette[color]; // Get the red, green, blue values of the colorValue.\n\n  var rgbColor = color2rgb(colorValue); // Apply opacity 0 to serve as a start color of the gradient.\n\n  var rgba = \"rgba(\" + rgbColor.r + \", \" + rgbColor.g + \", \" + rgbColor.b + \", 0)\"; // Get the direction of the gradient. (mergeStyles takes care of RTL direction)\n\n  var gradientDirection = direction === 'vertical' ? 'to bottom' : 'to right';\n  return {\n    content: '\"\"',\n    position: 'absolute',\n    right: 0,\n    bottom: 0,\n    width: width,\n    height: height,\n    pointerEvents: 'none',\n    backgroundImage: \"linear-gradient(\" + gradientDirection + \", \" + rgba + \" 0%, \" + colorValue + \" 100%)\"\n  };\n} // TODO consider moving this to a separate module along with some more color functions from OUFR/utilities.\n\n/**\n * Helper function to convert a string hex color to an RGB object.\n *\n * @param colorValue - Color to be converted from hex to rgba.\n */\n\nfunction color2rgb(colorValue) {\n  if (colorValue[0] === '#') {\n    // If it's a hex code\n    return {\n      r: parseInt(colorValue.slice(1, 3), 16),\n      g: parseInt(colorValue.slice(3, 5), 16),\n      b: parseInt(colorValue.slice(5, 7), 16)\n    };\n  } else if (colorValue.indexOf('rgba(') === 0) {\n    // If it's an rgba color string\n    colorValue = colorValue.match(/rgba\\(([^)]+)\\)/)[1];\n    var parts = colorValue.split(/ *, */).map(Number);\n    return {\n      r: parts[0],\n      g: parts[1],\n      b: parts[2]\n    };\n  } // The only remaining possibility is transparent.\n\n\n  return {\n    r: 255,\n    g: 255,\n    b: 255\n  };\n}\n/**\n * Helper function to get the default values for parameters of main function.\n *\n * @param style - Which style to get the default value for.\n * @param direction - What direction to take into consideration.\n */\n\n\nfunction getDefaultValue(style, direction) {\n  if (style === 'width') {\n    return direction === 'horizontal' ? DEFAULT_WIDTH : '100%';\n  } else {\n    return direction === 'vertical' ? DEFAULT_HEIGHT : '100%';\n  }\n}","map":{"version":3,"sources":["styles/getFadedOverflowStyle.ts"],"names":[],"mappings":"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","sourcesContent":["import { IRawStyle } from '@uifabric/merge-styles';\nimport { ITheme, ISemanticColors, IPalette } from '../interfaces/index';\n\ninterface IRGB {\n  r: number;\n  g: number;\n  b: number;\n}\n\nconst DEFAULT_HEIGHT = '50%';\nconst DEFAULT_WIDTH = 20;\n\n/**\n * - Generates a style used to fade out an overflowing content by defining a style for an :after pseudo element.\n * - Apply it to the :after selector for all combination of states the parent of content might have (normal, hover,\n * selected, focus).\n * - Requires the target to have position set to relative and overflow set to hidden.\n *\n * @example\n * ```tsx\n * // Assuming the following DOM structure and the different background colors coming from\n * // the parent holding the content.\n * <div className={classNames.parent}>\n *   <span className={classNames.content}>Overflown Content</span>\n * </div>\n * ```\n * ```ts\n * // This is how the style set would look in Component.styles.ts\n * const { bodyBackground } = theme.semanticColors;\n * const { neutralLighter } = theme.palette;\n *\n * // The second argument of getFadedOverflowStyle function is a string representing a key of\n * // ISemanticColors or IPalette.\n *\n * const styles = {\n *   parent: [\n *     backgroundColor: bodyBackground,\n *     selectors: {\n *       '&:hover: {\n *         backgroundColor: neutralLighter\n *       },\n *       '$content:after': {\n *         ...getFadedOverflowStyle(theme, 'bodyBackground')\n *       },\n *       '&:hover $content:after': {\n *         ...getFadedOverflowStyle(theme, 'neutralLighter')\n *       }\n *     }\n *   ],\n *   content: [\n *     width: '100%',\n *     display: 'inline-block',\n *     position: 'relative',\n *     overflow: 'hidden'\n *   ]\n * }\n * ```\n * @param theme - The theme object to use.\n * @param color - The background color to fade out to. Accepts only keys of ISemanticColors or IPalette.\n * Defaults to 'bodyBackground'.\n * @param direction - The direction of the overflow. Defaults to horizontal.\n * @param width - The width of the fading overflow. Vertical direction defaults it to 100% vs 20px when horizontal.\n * @param height - The Height of the fading overflow. Vertical direction defaults it to 50% vs 100% when horizontal.\n * @returns The style object.\n */\nexport function getFadedOverflowStyle(\n  theme: ITheme,\n  color: keyof ISemanticColors | keyof IPalette = 'bodyBackground',\n  direction: 'horizontal' | 'vertical' = 'horizontal',\n  width: string | number = getDefaultValue('width', direction),\n  height: string | number = getDefaultValue('height', direction),\n): IRawStyle {\n  // Get the color value string from the theme semanticColors or palette.\n  const colorValue: string =\n    theme.semanticColors[color as keyof ISemanticColors] || theme.palette[color as keyof IPalette];\n  // Get the red, green, blue values of the colorValue.\n  const rgbColor: IRGB = color2rgb(colorValue);\n  // Apply opacity 0 to serve as a start color of the gradient.\n  const rgba = `rgba(${rgbColor.r}, ${rgbColor.g}, ${rgbColor.b}, 0)`;\n  // Get the direction of the gradient. (mergeStyles takes care of RTL direction)\n  const gradientDirection = direction === 'vertical' ? 'to bottom' : 'to right';\n\n  return {\n    content: '\"\"',\n    position: 'absolute',\n    right: 0,\n    bottom: 0,\n    width: width,\n    height: height,\n    pointerEvents: 'none',\n    backgroundImage: `linear-gradient(${gradientDirection}, ${rgba} 0%, ${colorValue} 100%)`,\n  };\n}\n\n// TODO consider moving this to a separate module along with some more color functions from OUFR/utilities.\n/**\n * Helper function to convert a string hex color to an RGB object.\n *\n * @param colorValue - Color to be converted from hex to rgba.\n */\nfunction color2rgb(colorValue: string): IRGB {\n  if (colorValue[0] === '#') {\n    // If it's a hex code\n    return {\n      r: parseInt(colorValue.slice(1, 3), 16),\n      g: parseInt(colorValue.slice(3, 5), 16),\n      b: parseInt(colorValue.slice(5, 7), 16),\n    };\n  } else if (colorValue.indexOf('rgba(') === 0) {\n    // If it's an rgba color string\n    colorValue = colorValue.match(/rgba\\(([^)]+)\\)/)![1];\n    const parts = colorValue.split(/ *, */).map(Number);\n\n    return {\n      r: parts[0],\n      g: parts[1],\n      b: parts[2],\n    };\n  }\n  // The only remaining possibility is transparent.\n  return {\n    r: 255,\n    g: 255,\n    b: 255,\n  };\n}\n\n/**\n * Helper function to get the default values for parameters of main function.\n *\n * @param style - Which style to get the default value for.\n * @param direction - What direction to take into consideration.\n */\nfunction getDefaultValue(style: 'width' | 'height', direction: string): number | string {\n  if (style === 'width') {\n    return direction === 'horizontal' ? DEFAULT_WIDTH : '100%';\n  } else {\n    return direction === 'vertical' ? DEFAULT_HEIGHT : '100%';\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}