{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, divProperties, getNativeProps, warnDeprecations } from '../../Utilities';\nimport { ResizeGroupDirection } from './ResizeGroup.types';\nimport { initializeComponentRef } from '@uifabric/utilities';\nvar RESIZE_DELAY = 16;\n/**\n * Returns a simple object is able to store measurements with a given key.\n */\n\nexport var getMeasurementCache = function () {\n  var measurementsCache = {};\n  return {\n    /**\n     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a\n     * corresponding entry in the measurementsCache, then it will return that value.\n     * Returns undefined otherwise.\n     */\n    getCachedMeasurement: function (data) {\n      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {\n        return measurementsCache[data.cacheKey];\n      }\n\n      return undefined;\n    },\n\n    /**\n     * Should be called whenever there is a new measurement associated with a given data object.\n     * If the data has a cacheKey, store that measurement in the measurementsCache.\n     */\n    addMeasurementToCache: function (data, measurement) {\n      if (data.cacheKey) {\n        measurementsCache[data.cacheKey] = measurement;\n      }\n    }\n  };\n};\n/**\n * Returns a function that is able to compute the next state for the ResizeGroup given the current\n * state and any measurement updates.\n */\n\nexport var getNextResizeGroupStateProvider = function (measurementCache) {\n  if (measurementCache === void 0) {\n    measurementCache = getMeasurementCache();\n  }\n\n  var _measurementCache = measurementCache;\n\n  var _containerDimension;\n  /**\n   * Gets the width/height of the data rendered in a hidden div.\n   * @param measuredData - The data corresponding to the measurement we wish to take.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n\n\n  function _getMeasuredDimension(measuredData, getElementToMeasureDimension) {\n    var cachedDimension = _measurementCache.getCachedMeasurement(measuredData);\n\n    if (cachedDimension !== undefined) {\n      return cachedDimension;\n    }\n\n    var measuredDimension = getElementToMeasureDimension();\n\n    _measurementCache.addMeasurementToCache(measuredData, measuredDimension);\n\n    return measuredDimension;\n  }\n  /**\n   * Will get the next IResizeGroupState based on the current data while trying to shrink contents\n   * to fit in the container.\n   * @param data - The initial data point to start measuring.\n   * @param onReduceData - Function that transforms the data into something that should render with less width/height.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n\n\n  function _shrinkContentsUntilTheyFit(data, onReduceData, getElementToMeasureDimension) {\n    var dataToMeasure = data;\n\n    var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension > _containerDimension) {\n      var nextMeasuredData = onReduceData(dataToMeasure); // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onReduceData should return undefined when\n      // there are no more scaling states to apply.\n\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData); // If the measurement isn't in the cache, we need to rerender with some data in a hidden div\n\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n          resizeDirection: 'shrink'\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    return {\n      renderedData: dataToMeasure,\n      resizeDirection: undefined,\n      dataToMeasure: undefined\n    };\n  }\n  /**\n   * This function should be called when the state changes in a manner that might allow for more content to fit\n   * on the screen, such as the window width/height growing.\n   * @param data - The initial data point to start measuring.\n   * @param onGrowData - Function that transforms the data into something that may take up more space when rendering.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n\n\n  function _growDataUntilItDoesNotFit(data, onGrowData, getElementToMeasureDimension, onReduceData) {\n    var dataToMeasure = data;\n\n    var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension < _containerDimension) {\n      var nextMeasuredData = onGrowData(dataToMeasure); // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onGrowData should return undefined when\n      // there are no more scaling states to apply.\n\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData); // If the measurement isn't in the cache, we need to rerender with some data in a hidden div\n\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    } // Once the loop is done, we should now shrink until the contents fit.\n\n\n    return __assign({\n      resizeDirection: 'shrink'\n    }, _shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureDimension));\n  }\n  /**\n   * Handles an update to the container width/height.\n   * Should only be called when we knew the previous container width/height.\n   * @param newDimension - The new width/height of the container.\n   * @param fullDimensionData - The initial data passed in as a prop to resizeGroup.\n   * @param renderedData - The data that was rendered prior to the container size changing.\n   * @param onGrowData - Set to true if the Resize group has an onGrowData function.\n   */\n\n\n  function _updateContainerDimension(newDimension, fullDimensionData, renderedData, onGrowData) {\n    var nextState;\n\n    if (newDimension > _containerDimension) {\n      if (onGrowData) {\n        nextState = {\n          resizeDirection: 'grow',\n          dataToMeasure: onGrowData(renderedData)\n        };\n      } else {\n        nextState = {\n          resizeDirection: 'shrink',\n          dataToMeasure: fullDimensionData\n        };\n      }\n    } else {\n      nextState = {\n        resizeDirection: 'shrink',\n        dataToMeasure: renderedData\n      };\n    }\n\n    _containerDimension = newDimension;\n    return __assign(__assign({}, nextState), {\n      measureContainer: false\n    });\n  }\n\n  function getNextState(props, currentState, getElementToMeasureDimension, newContainerDimension) {\n    // If there is no new container width/height or data to measure, there is no need for a new state update\n    if (newContainerDimension === undefined && currentState.dataToMeasure === undefined) {\n      return undefined;\n    }\n\n    if (newContainerDimension) {\n      // If we know the last container size and we rendered data at that width/height, we can do an optimized render\n      if (_containerDimension && currentState.renderedData && !currentState.dataToMeasure) {\n        return __assign(__assign({}, currentState), _updateContainerDimension(newContainerDimension, props.data, currentState.renderedData, props.onGrowData));\n      } // If we are just setting the container width/height for the first time, we can't do any optimizations\n\n\n      _containerDimension = newContainerDimension;\n    }\n\n    var nextState = __assign(__assign({}, currentState), {\n      measureContainer: false\n    });\n\n    if (currentState.dataToMeasure) {\n      if (currentState.resizeDirection === 'grow' && props.onGrowData) {\n        nextState = __assign(__assign({}, nextState), _growDataUntilItDoesNotFit(currentState.dataToMeasure, props.onGrowData, getElementToMeasureDimension, props.onReduceData));\n      } else {\n        nextState = __assign(__assign({}, nextState), _shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureDimension));\n      }\n    }\n\n    return nextState;\n  }\n  /** Function that determines if we need to render content for measurement based on the measurement cache contents. */\n\n\n  function shouldRenderDataForMeasurement(dataToMeasure) {\n    if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function getInitialResizeGroupState(data) {\n    return {\n      dataToMeasure: __assign({}, data),\n      resizeDirection: 'grow',\n      measureContainer: true\n    };\n  }\n\n  return {\n    getNextState: getNextState,\n    shouldRenderDataForMeasurement: shouldRenderDataForMeasurement,\n    getInitialResizeGroupState: getInitialResizeGroupState\n  };\n}; // Provides a context property that (if true) tells any child components that\n// they are only being used for measurement purposes and will not be visible.\n\nexport var MeasuredContext = React.createContext({\n  isMeasured: false\n}); // Styles for the hidden div used for measurement\n\nvar hiddenDivStyles = {\n  position: 'fixed',\n  visibility: 'hidden'\n};\nvar hiddenParentStyles = {\n  position: 'relative'\n};\nvar COMPONENT_NAME = 'ResizeGroup';\n\nvar ResizeGroupBase =\n/** @class */\nfunction (_super) {\n  __extends(ResizeGroupBase, _super);\n\n  function ResizeGroupBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._nextResizeGroupStateProvider = getNextResizeGroupStateProvider(); // The root div which is the container inside of which we are trying to fit content.\n\n    _this._root = React.createRef(); // A div that can be used for the initial measurement so that we can avoid mounting a second instance\n    // of the component being measured for the initial render.\n\n    _this._initialHiddenDiv = React.createRef(); // A hidden div that is used for mounting a new instance of the component for measurement in a hidden\n    // div without unmounting the currently visible content.\n\n    _this._updateHiddenDiv = React.createRef(); // Tracks if any content has been rendered to the user. This enables us to do some performance optimizations\n    // for the initial render.\n\n    _this._hasRenderedContent = false;\n    _this.state = _this._nextResizeGroupStateProvider.getInitialResizeGroupState(_this.props.data);\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    warnDeprecations(COMPONENT_NAME, props, {\n      styles: 'className'\n    });\n    return _this;\n  }\n\n  ResizeGroupBase.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        onRenderData = _a.onRenderData;\n    var _b = this.state,\n        dataToMeasure = _b.dataToMeasure,\n        renderedData = _b.renderedData;\n    var divProps = getNativeProps(this.props, divProperties, ['data']);\n\n    var dataNeedsMeasuring = this._nextResizeGroupStateProvider.shouldRenderDataForMeasurement(dataToMeasure);\n\n    var isInitialMeasure = !this._hasRenderedContent && dataNeedsMeasuring; // We only ever render the final content to the user. All measurements are done in a hidden div.\n    // For the initial render, we want this to be as fast as possible, so we need to make sure that we only mount one\n    // version of the component for measurement and the final render. For renders that update what is on screen, we\n    // want to make sure that there are no jarring effects such as the screen flashing as we apply scaling steps for\n    // measurement. In the update case, we mount a second version of the component just for measurement purposes and\n    // leave the rendered content untouched until we know the next state to show to the user.\n\n    return React.createElement(\"div\", __assign({}, divProps, {\n      className: className,\n      ref: this._root\n    }), React.createElement(\"div\", {\n      style: hiddenParentStyles\n    }, dataNeedsMeasuring && !isInitialMeasure && React.createElement(\"div\", {\n      style: hiddenDivStyles,\n      ref: this._updateHiddenDiv\n    }, React.createElement(MeasuredContext.Provider, {\n      value: {\n        isMeasured: true\n      }\n    }, onRenderData(dataToMeasure))), React.createElement(\"div\", {\n      ref: this._initialHiddenDiv,\n      style: isInitialMeasure ? hiddenDivStyles : undefined,\n      \"data-automation-id\": \"visibleContent\"\n    }, isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData))));\n  };\n\n  ResizeGroupBase.prototype.componentDidMount = function () {\n    this._afterComponentRendered(this.props.direction);\n\n    this._events.on(window, 'resize', this._async.debounce(this._onResize, RESIZE_DELAY, {\n      leading: true\n    }));\n  };\n\n  ResizeGroupBase.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    this.setState({\n      dataToMeasure: __assign({}, nextProps.data),\n      resizeDirection: 'grow',\n      // Receiving new props means the parent might rerender and the root width/height might change\n      measureContainer: true\n    });\n  };\n\n  ResizeGroupBase.prototype.componentDidUpdate = function (prevProps) {\n    if (this.state.renderedData) {\n      this._hasRenderedContent = true;\n\n      if (this.props.dataDidRender) {\n        this.props.dataDidRender(this.state.renderedData);\n      }\n    }\n\n    this._afterComponentRendered(this.props.direction);\n  };\n\n  ResizeGroupBase.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  };\n\n  ResizeGroupBase.prototype.remeasure = function () {\n    if (this._root.current) {\n      this.setState({\n        measureContainer: true\n      });\n    }\n  };\n\n  ResizeGroupBase.prototype._afterComponentRendered = function (direction) {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      var containerDimension = undefined;\n\n      if (_this.state.measureContainer && _this._root.current) {\n        var boundingRect = _this._root.current.getBoundingClientRect();\n\n        containerDimension = direction && direction === ResizeGroupDirection.vertical ? boundingRect.height : boundingRect.width;\n      }\n\n      var nextState = _this._nextResizeGroupStateProvider.getNextState(_this.props, _this.state, function () {\n        var refToMeasure = !_this._hasRenderedContent ? _this._initialHiddenDiv : _this._updateHiddenDiv;\n\n        if (!refToMeasure.current) {\n          return 0;\n        }\n\n        return direction && direction === ResizeGroupDirection.vertical ? refToMeasure.current.scrollHeight : refToMeasure.current.scrollWidth;\n      }, containerDimension);\n\n      if (nextState) {\n        _this.setState(nextState);\n      }\n    }, this._root.current);\n  };\n\n  ResizeGroupBase.prototype._onResize = function () {\n    if (this._root.current) {\n      this.setState({\n        measureContainer: true\n      });\n    }\n  };\n\n  return ResizeGroupBase;\n}(React.Component);\n\nexport { ResizeGroupBase };","map":{"version":3,"sources":["components/ResizeGroup/ResizeGroup.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Async, EventGroup, divProperties, getNativeProps, warnDeprecations } from '../../Utilities';\nimport { IResizeGroupProps, ResizeGroupDirection } from './ResizeGroup.types';\nimport { initializeComponentRef } from '@uifabric/utilities';\n\nconst RESIZE_DELAY = 16;\n\nexport interface IResizeGroupState {\n  /**\n   * Final data used to render proper sized component\n   */\n  renderedData?: any;\n\n  /**\n   * Data to render in a hidden div for measurement\n   */\n  dataToMeasure?: any;\n\n  /**\n   * Set to true when the content container might have new dimensions and should\n   * be remeasured.\n   */\n  measureContainer?: boolean;\n\n  /**\n   * Are we resizing to accommodate having more or less available space?\n   * The 'grow' direction is when the container may have more room than the last render,\n   * such as when a window resize occurs. This means we will try to fit more content in the window.\n   * The 'shrink' direction is when the contents don't fit in the container and we need\n   * to find a transformation of the data that makes everything fit.\n   */\n  resizeDirection?: 'grow' | 'shrink';\n}\n\n/**\n * Returns a simple object is able to store measurements with a given key.\n */\nexport const getMeasurementCache = () => {\n  const measurementsCache: { [key: string]: number } = {};\n\n  return {\n    /**\n     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a\n     * corresponding entry in the measurementsCache, then it will return that value.\n     * Returns undefined otherwise.\n     */\n    getCachedMeasurement: (data: any): number | undefined => {\n      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {\n        return measurementsCache[data.cacheKey];\n      }\n\n      return undefined;\n    },\n    /**\n     * Should be called whenever there is a new measurement associated with a given data object.\n     * If the data has a cacheKey, store that measurement in the measurementsCache.\n     */\n    addMeasurementToCache: (data: any, measurement: number): void => {\n      if (data.cacheKey) {\n        measurementsCache[data.cacheKey] = measurement;\n      }\n    },\n  };\n};\n\n/**\n * Returns a function that is able to compute the next state for the ResizeGroup given the current\n * state and any measurement updates.\n */\nexport const getNextResizeGroupStateProvider = (measurementCache = getMeasurementCache()) => {\n  const _measurementCache = measurementCache;\n  let _containerDimension: number | undefined;\n\n  /**\n   * Gets the width/height of the data rendered in a hidden div.\n   * @param measuredData - The data corresponding to the measurement we wish to take.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _getMeasuredDimension(measuredData: any, getElementToMeasureDimension: () => number): number {\n    const cachedDimension = _measurementCache.getCachedMeasurement(measuredData);\n    if (cachedDimension !== undefined) {\n      return cachedDimension;\n    }\n\n    const measuredDimension = getElementToMeasureDimension();\n    _measurementCache.addMeasurementToCache(measuredData, measuredDimension);\n    return measuredDimension;\n  }\n\n  /**\n   * Will get the next IResizeGroupState based on the current data while trying to shrink contents\n   * to fit in the container.\n   * @param data - The initial data point to start measuring.\n   * @param onReduceData - Function that transforms the data into something that should render with less width/height.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _shrinkContentsUntilTheyFit(\n    data: any,\n    onReduceData: (prevData: any) => any,\n    getElementToMeasureDimension: () => number,\n  ): IResizeGroupState {\n    let dataToMeasure = data;\n    let measuredDimension: number | undefined = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension > _containerDimension!) {\n      const nextMeasuredData = onReduceData(dataToMeasure);\n\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onReduceData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined,\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);\n\n      // If the measurement isn't in the cache, we need to rerender with some data in a hidden div\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n          resizeDirection: 'shrink',\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    return {\n      renderedData: dataToMeasure,\n      resizeDirection: undefined,\n      dataToMeasure: undefined,\n    };\n  }\n\n  /**\n   * This function should be called when the state changes in a manner that might allow for more content to fit\n   * on the screen, such as the window width/height growing.\n   * @param data - The initial data point to start measuring.\n   * @param onGrowData - Function that transforms the data into something that may take up more space when rendering.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n  function _growDataUntilItDoesNotFit(\n    data: any,\n    onGrowData: (prevData: any) => any,\n    getElementToMeasureDimension: () => number,\n    onReduceData: (prevData: any) => any,\n  ): IResizeGroupState {\n    let dataToMeasure = data;\n    let measuredDimension: number | undefined = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension < _containerDimension!) {\n      const nextMeasuredData = onGrowData(dataToMeasure);\n\n      // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onGrowData should return undefined when\n      // there are no more scaling states to apply.\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined,\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData);\n      // If the measurement isn't in the cache, we need to rerender with some data in a hidden div\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    // Once the loop is done, we should now shrink until the contents fit.\n    return {\n      resizeDirection: 'shrink',\n      ..._shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureDimension),\n    };\n  }\n\n  /**\n   * Handles an update to the container width/height.\n   * Should only be called when we knew the previous container width/height.\n   * @param newDimension - The new width/height of the container.\n   * @param fullDimensionData - The initial data passed in as a prop to resizeGroup.\n   * @param renderedData - The data that was rendered prior to the container size changing.\n   * @param onGrowData - Set to true if the Resize group has an onGrowData function.\n   */\n  function _updateContainerDimension(\n    newDimension: number,\n    fullDimensionData: any,\n    renderedData: any,\n    onGrowData?: (prevData: any) => any,\n  ): IResizeGroupState {\n    let nextState: IResizeGroupState;\n    if (newDimension > _containerDimension!) {\n      if (onGrowData) {\n        nextState = {\n          resizeDirection: 'grow',\n          dataToMeasure: onGrowData(renderedData),\n        };\n      } else {\n        nextState = {\n          resizeDirection: 'shrink',\n          dataToMeasure: fullDimensionData,\n        };\n      }\n    } else {\n      nextState = {\n        resizeDirection: 'shrink',\n        dataToMeasure: renderedData,\n      };\n    }\n    _containerDimension = newDimension;\n    return { ...nextState, measureContainer: false };\n  }\n\n  function getNextState(\n    props: IResizeGroupProps,\n    currentState: IResizeGroupState,\n    getElementToMeasureDimension: () => number,\n    newContainerDimension?: number,\n  ): IResizeGroupState | undefined {\n    // If there is no new container width/height or data to measure, there is no need for a new state update\n    if (newContainerDimension === undefined && currentState.dataToMeasure === undefined) {\n      return undefined;\n    }\n\n    if (newContainerDimension) {\n      // If we know the last container size and we rendered data at that width/height, we can do an optimized render\n      if (_containerDimension && currentState.renderedData && !currentState.dataToMeasure) {\n        return {\n          ...currentState,\n          ..._updateContainerDimension(newContainerDimension, props.data, currentState.renderedData, props.onGrowData),\n        };\n      }\n\n      // If we are just setting the container width/height for the first time, we can't do any optimizations\n      _containerDimension = newContainerDimension;\n    }\n\n    let nextState: IResizeGroupState = {\n      ...currentState,\n      measureContainer: false,\n    };\n\n    if (currentState.dataToMeasure) {\n      if (currentState.resizeDirection === 'grow' && props.onGrowData) {\n        nextState = {\n          ...nextState,\n          ..._growDataUntilItDoesNotFit(\n            currentState.dataToMeasure,\n            props.onGrowData,\n            getElementToMeasureDimension,\n            props.onReduceData,\n          ),\n        };\n      } else {\n        nextState = {\n          ...nextState,\n          ..._shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureDimension),\n        };\n      }\n    }\n\n    return nextState;\n  }\n\n  /** Function that determines if we need to render content for measurement based on the measurement cache contents. */\n  function shouldRenderDataForMeasurement(dataToMeasure: any | undefined): boolean {\n    if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function getInitialResizeGroupState(data: any): IResizeGroupState {\n    return {\n      dataToMeasure: { ...data },\n      resizeDirection: 'grow',\n      measureContainer: true,\n    };\n  }\n\n  return {\n    getNextState,\n    shouldRenderDataForMeasurement,\n    getInitialResizeGroupState,\n  };\n};\n\n// Provides a context property that (if true) tells any child components that\n// they are only being used for measurement purposes and will not be visible.\nexport const MeasuredContext = React.createContext({ isMeasured: false });\n\n// Styles for the hidden div used for measurement\nconst hiddenDivStyles: React.CSSProperties = { position: 'fixed', visibility: 'hidden' };\nconst hiddenParentStyles: React.CSSProperties = { position: 'relative' };\nconst COMPONENT_NAME = 'ResizeGroup';\n\nexport class ResizeGroupBase extends React.Component<IResizeGroupProps, IResizeGroupState> {\n  private _nextResizeGroupStateProvider = getNextResizeGroupStateProvider();\n  // The root div which is the container inside of which we are trying to fit content.\n  private _root = React.createRef<HTMLDivElement>();\n  // A div that can be used for the initial measurement so that we can avoid mounting a second instance\n  // of the component being measured for the initial render.\n  private _initialHiddenDiv = React.createRef<HTMLDivElement>();\n  // A hidden div that is used for mounting a new instance of the component for measurement in a hidden\n  // div without unmounting the currently visible content.\n  private _updateHiddenDiv = React.createRef<HTMLDivElement>();\n  // Tracks if any content has been rendered to the user. This enables us to do some performance optimizations\n  // for the initial render.\n  private _hasRenderedContent = false;\n\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IResizeGroupProps) {\n    super(props);\n    this.state = this._nextResizeGroupStateProvider.getInitialResizeGroupState(this.props.data);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    warnDeprecations(COMPONENT_NAME, props, {\n      styles: 'className',\n    });\n  }\n\n  public render(): JSX.Element {\n    const { className, onRenderData } = this.props;\n    const { dataToMeasure, renderedData } = this.state;\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties, ['data']);\n\n    const dataNeedsMeasuring = this._nextResizeGroupStateProvider.shouldRenderDataForMeasurement(dataToMeasure);\n\n    const isInitialMeasure = !this._hasRenderedContent && dataNeedsMeasuring;\n\n    // We only ever render the final content to the user. All measurements are done in a hidden div.\n    // For the initial render, we want this to be as fast as possible, so we need to make sure that we only mount one\n    // version of the component for measurement and the final render. For renders that update what is on screen, we\n    // want to make sure that there are no jarring effects such as the screen flashing as we apply scaling steps for\n    // measurement. In the update case, we mount a second version of the component just for measurement purposes and\n    // leave the rendered content untouched until we know the next state to show to the user.\n    return (\n      <div {...divProps} className={className} ref={this._root}>\n        <div style={hiddenParentStyles}>\n          {dataNeedsMeasuring && !isInitialMeasure && (\n            <div style={hiddenDivStyles} ref={this._updateHiddenDiv}>\n              <MeasuredContext.Provider value={{ isMeasured: true }}>\n                {onRenderData(dataToMeasure)}\n              </MeasuredContext.Provider>\n            </div>\n          )}\n\n          <div\n            ref={this._initialHiddenDiv}\n            style={isInitialMeasure ? hiddenDivStyles : undefined}\n            data-automation-id=\"visibleContent\"\n          >\n            {isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData)}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  public componentDidMount(): void {\n    this._afterComponentRendered(this.props.direction);\n    this._events.on(window, 'resize', this._async.debounce(this._onResize, RESIZE_DELAY, { leading: true }));\n  }\n\n  public UNSAFE_componentWillReceiveProps(nextProps: IResizeGroupProps): void {\n    this.setState({\n      dataToMeasure: { ...nextProps.data },\n      resizeDirection: 'grow',\n      // Receiving new props means the parent might rerender and the root width/height might change\n      measureContainer: true,\n    });\n  }\n\n  public componentDidUpdate(prevProps: IResizeGroupProps) {\n    if (this.state.renderedData) {\n      this._hasRenderedContent = true;\n      if (this.props.dataDidRender) {\n        this.props.dataDidRender(this.state.renderedData);\n      }\n    }\n    this._afterComponentRendered(this.props.direction);\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n    this._events.dispose();\n  }\n\n  public remeasure(): void {\n    if (this._root.current) {\n      this.setState({ measureContainer: true });\n    }\n  }\n\n  private _afterComponentRendered(direction?: ResizeGroupDirection): void {\n    this._async.requestAnimationFrame(() => {\n      let containerDimension = undefined;\n      if (this.state.measureContainer && this._root.current) {\n        const boundingRect = this._root.current.getBoundingClientRect();\n        containerDimension =\n          direction && direction === ResizeGroupDirection.vertical ? boundingRect.height : boundingRect.width;\n      }\n      const nextState = this._nextResizeGroupStateProvider.getNextState(\n        this.props,\n        this.state,\n        () => {\n          const refToMeasure = !this._hasRenderedContent ? this._initialHiddenDiv : this._updateHiddenDiv;\n          if (!refToMeasure.current) {\n            return 0;\n          }\n          return direction && direction === ResizeGroupDirection.vertical\n            ? refToMeasure.current.scrollHeight\n            : refToMeasure.current.scrollWidth;\n        },\n        containerDimension,\n      );\n\n      if (nextState) {\n        this.setState(nextState);\n      }\n    }, this._root.current);\n  }\n\n  private _onResize(): void {\n    if (this._root.current) {\n      this.setState({ measureContainer: true });\n    }\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}