{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport { Stylesheet } from './Stylesheet';\nimport { kebabRules } from './transforms/kebabRules';\nimport { prefixRules } from './transforms/prefixRules';\nimport { provideUnits } from './transforms/provideUnits';\nimport { rtlifyRules } from './transforms/rtlifyRules';\nvar DISPLAY_NAME = 'displayName';\n\nfunction getDisplayName(rules) {\n  var rootStyle = rules && rules['&'];\n  return rootStyle ? rootStyle.displayName : undefined;\n}\n\nvar globalSelectorRegExp = /\\:global\\((.+?)\\)/g;\n/**\n * Finds comma separated selectors in a :global() e.g. \":global(.class1, .class2, .class3)\"\n * and wraps them each in their own global \":global(.class1), :global(.class2), :global(.class3)\"\n *\n * @param selectorWithGlobals The selector to process\n * @returns The updated selector\n */\n\nfunction expandCommaSeparatedGlobals(selectorWithGlobals) {\n  // We the selector does not have a :global() we can shortcut\n  if (!globalSelectorRegExp.test(selectorWithGlobals)) {\n    return selectorWithGlobals;\n  }\n\n  var replacementInfo = [];\n  var findGlobal = /\\:global\\((.+?)\\)/g;\n  var match = null; // Create a result list for global selectors so we can replace them.\n\n  while (match = findGlobal.exec(selectorWithGlobals)) {\n    // Only if the found selector is a comma separated list we'll process it.\n    if (match[1].indexOf(',') > -1) {\n      replacementInfo.push([match.index, match.index + match[0].length, // Wrap each of the found selectors in :global()\n      match[1].split(',').map(function (v) {\n        return \":global(\" + v.trim() + \")\";\n      }).join(', ')]);\n    }\n  } // Replace the found selectors with their wrapped variants in reverse order\n\n\n  return replacementInfo.reverse().reduce(function (selector, _a) {\n    var matchIndex = _a[0],\n        matchEndIndex = _a[1],\n        replacement = _a[2];\n    var prefix = selector.slice(0, matchIndex);\n    var suffix = selector.slice(matchEndIndex);\n    return prefix + replacement + suffix;\n  }, selectorWithGlobals);\n}\n\nfunction expandSelector(newSelector, currentSelector) {\n  if (newSelector.indexOf(':global(') >= 0) {\n    return newSelector.replace(globalSelectorRegExp, '$1');\n  } else if (newSelector.indexOf(':') === 0) {\n    return currentSelector + newSelector;\n  } else if (newSelector.indexOf('&') < 0) {\n    return currentSelector + ' ' + newSelector;\n  }\n\n  return newSelector;\n}\n\nfunction extractSelector(currentSelector, rules, selector, value) {\n  if (rules === void 0) {\n    rules = {\n      __order: []\n    };\n  }\n\n  if (selector.indexOf('@') === 0) {\n    selector = selector + '{' + currentSelector;\n    extractRules([value], rules, selector);\n  } else if (selector.indexOf(',') > -1) {\n    expandCommaSeparatedGlobals(selector).split(',').map(function (s) {\n      return s.trim();\n    }).forEach(function (separatedSelector) {\n      return extractRules([value], rules, expandSelector(separatedSelector, currentSelector));\n    });\n  } else {\n    extractRules([value], rules, expandSelector(selector, currentSelector));\n  }\n}\n\nfunction extractRules(args, rules, currentSelector) {\n  if (rules === void 0) {\n    rules = {\n      __order: []\n    };\n  }\n\n  if (currentSelector === void 0) {\n    currentSelector = '&';\n  }\n\n  var stylesheet = Stylesheet.getInstance();\n  var currentRules = rules[currentSelector];\n\n  if (!currentRules) {\n    currentRules = {};\n    rules[currentSelector] = currentRules;\n\n    rules.__order.push(currentSelector);\n  }\n\n  for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {\n    var arg = args_1[_i]; // If the arg is a string, we need to look up the class map and merge.\n\n    if (typeof arg === 'string') {\n      var expandedRules = stylesheet.argsFromClassName(arg);\n\n      if (expandedRules) {\n        extractRules(expandedRules, rules, currentSelector);\n      } // Else if the arg is an array, we need to recurse in.\n\n    } else if (Array.isArray(arg)) {\n      extractRules(arg, rules, currentSelector);\n    } else {\n      for (var prop in arg) {\n        if (arg.hasOwnProperty(prop)) {\n          var propValue = arg[prop];\n\n          if (prop === 'selectors') {\n            // every child is a selector.\n            var selectors = arg.selectors;\n\n            for (var newSelector in selectors) {\n              if (selectors.hasOwnProperty(newSelector)) {\n                extractSelector(currentSelector, rules, newSelector, selectors[newSelector]);\n              }\n            }\n          } else if (typeof propValue === 'object') {\n            // prop is a selector.\n            if (propValue !== null) {\n              extractSelector(currentSelector, rules, prop, propValue);\n            }\n          } else {\n            if (propValue !== undefined) {\n              // Else, add the rule to the currentSelector.\n              if (prop === 'margin' || prop === 'padding') {\n                expandQuads(currentRules, prop, propValue);\n              } else {\n                currentRules[prop] = propValue;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return rules;\n}\n\nfunction expandQuads(currentRules, name, value) {\n  var parts = typeof value === 'string' ? value.split(' ') : [value];\n  currentRules[name + 'Top'] = parts[0];\n  currentRules[name + 'Right'] = parts[1] || parts[0];\n  currentRules[name + 'Bottom'] = parts[2] || parts[0];\n  currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];\n}\n\nfunction getKeyForRules(options, rules) {\n  var serialized = [options.rtl ? 'rtl' : 'ltr'];\n  var hasProps = false;\n\n  for (var _i = 0, _a = rules.__order; _i < _a.length; _i++) {\n    var selector = _a[_i];\n    serialized.push(selector);\n    var rulesForSelector = rules[selector];\n\n    for (var propName in rulesForSelector) {\n      if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== undefined) {\n        hasProps = true;\n        serialized.push(propName, rulesForSelector[propName]);\n      }\n    }\n  }\n\n  return hasProps ? serialized.join('') : undefined;\n}\n\nfunction repeatString(target, count) {\n  if (count <= 0) {\n    return '';\n  }\n\n  if (count === 1) {\n    return target;\n  }\n\n  return target + repeatString(target, count - 1);\n}\n\nexport function serializeRuleEntries(options, ruleEntries) {\n  if (!ruleEntries) {\n    return '';\n  }\n\n  var allEntries = [];\n\n  for (var entry in ruleEntries) {\n    if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== undefined) {\n      allEntries.push(entry, ruleEntries[entry]);\n    }\n  } // Apply transforms.\n\n\n  for (var i = 0; i < allEntries.length; i += 2) {\n    kebabRules(allEntries, i);\n    provideUnits(allEntries, i);\n    rtlifyRules(options, allEntries, i);\n    prefixRules(allEntries, i);\n  } // Apply punctuation.\n\n\n  for (var i = 1; i < allEntries.length; i += 4) {\n    allEntries.splice(i, 1, ':', allEntries[i], ';');\n  }\n\n  return allEntries.join('');\n}\nexport function styleToRegistration(options) {\n  var args = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n\n  var rules = extractRules(args);\n  var key = getKeyForRules(options, rules);\n\n  if (key) {\n    var stylesheet = Stylesheet.getInstance();\n    var registration = {\n      className: stylesheet.classNameFromKey(key),\n      key: key,\n      args: args\n    };\n\n    if (!registration.className) {\n      registration.className = stylesheet.getClassName(getDisplayName(rules));\n      var rulesToInsert = [];\n\n      for (var _a = 0, _b = rules.__order; _a < _b.length; _a++) {\n        var selector = _b[_a];\n        rulesToInsert.push(selector, serializeRuleEntries(options, rules[selector]));\n      }\n\n      registration.rulesToInsert = rulesToInsert;\n    }\n\n    return registration;\n  }\n\n  return undefined;\n}\n/**\n * Insert style to stylesheet.\n * @param registration Style registration.\n * @param specificityMultiplier Number of times classname selector is repeated in the css rule.\n * This is to increase css specificity in case it's needed. Default to 1.\n */\n\nexport function applyRegistration(registration, specificityMultiplier) {\n  if (specificityMultiplier === void 0) {\n    specificityMultiplier = 1;\n  }\n\n  var stylesheet = Stylesheet.getInstance();\n  var className = registration.className,\n      key = registration.key,\n      args = registration.args,\n      rulesToInsert = registration.rulesToInsert;\n\n  if (rulesToInsert) {\n    // rulesToInsert is an ordered array of selector/rule pairs.\n    for (var i = 0; i < rulesToInsert.length; i += 2) {\n      var rules = rulesToInsert[i + 1];\n\n      if (rules) {\n        var selector = rulesToInsert[i];\n        selector = selector.replace(/&/g, repeatString(\".\" + registration.className, specificityMultiplier)); // Insert. Note if a media query, we must close the query with a final bracket.\n\n        var processedRule = selector + \"{\" + rules + \"}\" + (selector.indexOf('@') === 0 ? '}' : '');\n        stylesheet.insertRule(processedRule);\n      }\n    }\n\n    stylesheet.cacheClassName(className, key, args, rulesToInsert);\n  }\n}\nexport function styleToClassName(options) {\n  var args = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n\n  var registration = styleToRegistration.apply(void 0, __spreadArrays([options], args));\n\n  if (registration) {\n    applyRegistration(registration, options.specificityMultiplier);\n    return registration.className;\n  }\n\n  return '';\n}","map":{"version":3,"sources":["styleToClassName.ts"],"names":[],"mappings":"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","sourcesContent":["import { IStyle } from './IStyle';\nimport { IRawStyle } from './IRawStyle';\n\nimport { Stylesheet } from './Stylesheet';\nimport { kebabRules } from './transforms/kebabRules';\nimport { prefixRules } from './transforms/prefixRules';\nimport { provideUnits } from './transforms/provideUnits';\nimport { rtlifyRules } from './transforms/rtlifyRules';\nimport { IStyleOptions } from './IStyleOptions';\n\nconst DISPLAY_NAME = 'displayName';\n\ntype IDictionary = { [key: string]: any };\n\ninterface IRuleSet {\n  __order: string[];\n  [key: string]: IDictionary;\n}\n\nfunction getDisplayName(rules?: { [key: string]: IRawStyle }): string | undefined {\n  const rootStyle: IStyle = rules && rules['&'];\n\n  return rootStyle ? (rootStyle as IRawStyle).displayName : undefined;\n}\n\nconst globalSelectorRegExp = /\\:global\\((.+?)\\)/g;\n\ntype ReplacementInfo = [number, number, string];\n\n/**\n * Finds comma separated selectors in a :global() e.g. \":global(.class1, .class2, .class3)\"\n * and wraps them each in their own global \":global(.class1), :global(.class2), :global(.class3)\"\n *\n * @param selectorWithGlobals The selector to process\n * @returns The updated selector\n */\nfunction expandCommaSeparatedGlobals(selectorWithGlobals: string): string {\n  // We the selector does not have a :global() we can shortcut\n  if (!globalSelectorRegExp.test(selectorWithGlobals)) {\n    return selectorWithGlobals;\n  }\n\n  const replacementInfo: ReplacementInfo[] = [];\n\n  const findGlobal = /\\:global\\((.+?)\\)/g;\n  let match = null;\n  // Create a result list for global selectors so we can replace them.\n  while ((match = findGlobal.exec(selectorWithGlobals))) {\n    // Only if the found selector is a comma separated list we'll process it.\n    if (match[1].indexOf(',') > -1) {\n      replacementInfo.push([\n        match.index,\n        match.index + match[0].length,\n        // Wrap each of the found selectors in :global()\n        match[1]\n          .split(',')\n          .map((v: string) => `:global(${v.trim()})`)\n          .join(', '),\n      ]);\n    }\n  }\n\n  // Replace the found selectors with their wrapped variants in reverse order\n  return replacementInfo\n    .reverse()\n    .reduce((selector: string, [matchIndex, matchEndIndex, replacement]: ReplacementInfo) => {\n      const prefix = selector.slice(0, matchIndex);\n      const suffix = selector.slice(matchEndIndex);\n\n      return prefix + replacement + suffix;\n    }, selectorWithGlobals);\n}\n\nfunction expandSelector(newSelector: string, currentSelector: string): string {\n  if (newSelector.indexOf(':global(') >= 0) {\n    return newSelector.replace(globalSelectorRegExp, '$1');\n  } else if (newSelector.indexOf(':') === 0) {\n    return currentSelector + newSelector;\n  } else if (newSelector.indexOf('&') < 0) {\n    return currentSelector + ' ' + newSelector;\n  }\n\n  return newSelector;\n}\n\nfunction extractSelector(currentSelector: string, rules: IRuleSet = { __order: [] }, selector: string, value: IStyle) {\n  if (selector.indexOf('@') === 0) {\n    selector = selector + '{' + currentSelector;\n    extractRules([value], rules, selector);\n  } else if (selector.indexOf(',') > -1) {\n    expandCommaSeparatedGlobals(selector)\n      .split(',')\n      .map((s: string) => s.trim())\n      .forEach((separatedSelector: string) =>\n        extractRules([value], rules, expandSelector(separatedSelector, currentSelector)),\n      );\n  } else {\n    extractRules([value], rules, expandSelector(selector, currentSelector));\n  }\n}\n\nfunction extractRules(args: IStyle[], rules: IRuleSet = { __order: [] }, currentSelector: string = '&'): IRuleSet {\n  const stylesheet = Stylesheet.getInstance();\n  let currentRules: IDictionary | undefined = rules[currentSelector] as IDictionary;\n\n  if (!currentRules) {\n    currentRules = {};\n    rules[currentSelector] = currentRules;\n    rules.__order.push(currentSelector);\n  }\n\n  for (const arg of args) {\n    // If the arg is a string, we need to look up the class map and merge.\n    if (typeof arg === 'string') {\n      const expandedRules = stylesheet.argsFromClassName(arg);\n\n      if (expandedRules) {\n        extractRules(expandedRules, rules, currentSelector);\n      }\n      // Else if the arg is an array, we need to recurse in.\n    } else if (Array.isArray(arg)) {\n      extractRules(arg, rules, currentSelector);\n    } else {\n      for (const prop in arg as any) {\n        if ((arg as any).hasOwnProperty(prop)) {\n          const propValue = (arg as any)[prop];\n\n          if (prop === 'selectors') {\n            // every child is a selector.\n            const selectors: { [key: string]: IStyle } = (arg as any).selectors;\n\n            for (const newSelector in selectors) {\n              if (selectors.hasOwnProperty(newSelector)) {\n                extractSelector(currentSelector, rules, newSelector, selectors[newSelector]);\n              }\n            }\n          } else if (typeof propValue === 'object') {\n            // prop is a selector.\n            if (propValue !== null) {\n              extractSelector(currentSelector, rules, prop, propValue);\n            }\n          } else {\n            if (propValue !== undefined) {\n              // Else, add the rule to the currentSelector.\n              if (prop === 'margin' || prop === 'padding') {\n                expandQuads(currentRules, prop, propValue);\n              } else {\n                (currentRules as any)[prop] = propValue;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return rules;\n}\n\nfunction expandQuads(currentRules: IDictionary, name: string, value: string): void {\n  const parts = typeof value === 'string' ? value.split(' ') : [value];\n\n  currentRules[name + 'Top'] = parts[0];\n  currentRules[name + 'Right'] = parts[1] || parts[0];\n  currentRules[name + 'Bottom'] = parts[2] || parts[0];\n  currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];\n}\n\nfunction getKeyForRules(options: IStyleOptions, rules: IRuleSet): string | undefined {\n  const serialized: string[] = [options.rtl ? 'rtl' : 'ltr'];\n  let hasProps = false;\n\n  for (const selector of rules.__order) {\n    serialized.push(selector);\n    const rulesForSelector = rules[selector];\n\n    for (const propName in rulesForSelector) {\n      if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== undefined) {\n        hasProps = true;\n        serialized.push(propName, rulesForSelector[propName]);\n      }\n    }\n  }\n\n  return hasProps ? serialized.join('') : undefined;\n}\n\nfunction repeatString(target: string, count: number): string {\n  if (count <= 0) {\n    return '';\n  }\n\n  if (count === 1) {\n    return target;\n  }\n\n  return target + repeatString(target, count - 1);\n}\n\nexport function serializeRuleEntries(options: IStyleOptions, ruleEntries: { [key: string]: string | number }): string {\n  if (!ruleEntries) {\n    return '';\n  }\n\n  const allEntries: (string | number)[] = [];\n\n  for (const entry in ruleEntries) {\n    if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== undefined) {\n      allEntries.push(entry, ruleEntries[entry]);\n    }\n  }\n\n  // Apply transforms.\n  for (let i = 0; i < allEntries.length; i += 2) {\n    kebabRules(allEntries, i);\n    provideUnits(allEntries, i);\n    rtlifyRules(options, allEntries, i);\n    prefixRules(allEntries, i);\n  }\n\n  // Apply punctuation.\n  for (let i = 1; i < allEntries.length; i += 4) {\n    allEntries.splice(i, 1, ':', allEntries[i], ';');\n  }\n\n  return allEntries.join('');\n}\n\nexport interface IRegistration {\n  className: string;\n  key: string;\n  args: IStyle[];\n  rulesToInsert: string[];\n}\n\nexport function styleToRegistration(options: IStyleOptions, ...args: IStyle[]): IRegistration | undefined {\n  const rules: IRuleSet = extractRules(args);\n  const key = getKeyForRules(options, rules);\n\n  if (key) {\n    const stylesheet = Stylesheet.getInstance();\n    const registration: Partial<IRegistration> = {\n      className: stylesheet.classNameFromKey(key),\n      key,\n      args,\n    };\n\n    if (!registration.className) {\n      registration.className = stylesheet.getClassName(getDisplayName(rules));\n      const rulesToInsert: string[] = [];\n\n      for (const selector of rules.__order) {\n        rulesToInsert.push(selector, serializeRuleEntries(options, rules[selector]));\n      }\n      registration.rulesToInsert = rulesToInsert;\n    }\n\n    return registration as IRegistration;\n  }\n\n  return undefined;\n}\n\n/**\n * Insert style to stylesheet.\n * @param registration Style registration.\n * @param specificityMultiplier Number of times classname selector is repeated in the css rule.\n * This is to increase css specificity in case it's needed. Default to 1.\n */\nexport function applyRegistration(registration: IRegistration, specificityMultiplier: number = 1): void {\n  const stylesheet = Stylesheet.getInstance();\n  const { className, key, args, rulesToInsert } = registration;\n\n  if (rulesToInsert) {\n    // rulesToInsert is an ordered array of selector/rule pairs.\n    for (let i = 0; i < rulesToInsert.length; i += 2) {\n      const rules = rulesToInsert[i + 1];\n      if (rules) {\n        let selector = rulesToInsert[i];\n        selector = selector.replace(/&/g, repeatString(`.${registration.className}`, specificityMultiplier));\n\n        // Insert. Note if a media query, we must close the query with a final bracket.\n        const processedRule = `${selector}{${rules}}${selector.indexOf('@') === 0 ? '}' : ''}`;\n        stylesheet.insertRule(processedRule);\n      }\n    }\n    stylesheet.cacheClassName(className!, key!, args!, rulesToInsert);\n  }\n}\n\nexport function styleToClassName(options: IStyleOptions, ...args: IStyle[]): string {\n  const registration = styleToRegistration(options, ...args);\n  if (registration) {\n    applyRegistration(registration, options.specificityMultiplier);\n\n    return registration.className;\n  }\n\n  return '';\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}