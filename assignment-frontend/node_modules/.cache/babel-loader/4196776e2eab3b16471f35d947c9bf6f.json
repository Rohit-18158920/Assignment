{"ast":null,"code":"/**\n * Simple deep merge function. Takes all arguments and returns a deep copy of the objects merged\n * together in the order provided. If an object creates a circular reference, it will assign the\n * original reference.\n */\nexport function merge(target) {\n  var args = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n\n  for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n    var arg = args_1[_a];\n\n    _merge(target || {}, arg);\n  }\n\n  return target;\n}\n/**\n * The _merge helper iterates through all props on source and assigns them to target.\n * When the value is an object, we will create a deep clone of the object. However if\n * there is a circular reference, the value will not be deep cloned and will persist\n * the reference.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nfunction _merge(target, source, circularReferences) {\n  if (circularReferences === void 0) {\n    circularReferences = [];\n  }\n\n  circularReferences.push(source);\n\n  for (var name_1 in source) {\n    if (source.hasOwnProperty(name_1)) {\n      if (name_1 !== '__proto__' && name_1 !== 'constructor' && name_1 !== 'prototype') {\n        var value = source[name_1];\n\n        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n          var isCircularReference = circularReferences.indexOf(value) > -1;\n          target[name_1] = isCircularReference ? value : _merge(target[name_1] || {}, value, circularReferences);\n        } else {\n          target[name_1] = value;\n        }\n      }\n    }\n  }\n\n  circularReferences.pop();\n  return target;\n}","map":{"version":3,"sources":["merge.ts"],"names":[],"mappings":"AAAA;;;;AAIG;AACH,OAAM,SAAU,KAAV,CAAwB,MAAxB,EAA0C;AAAE,MAAA,IAAA,GAAA,EAAA;;OAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAkD;AAAlD,IAAA,IAAA,CAAA,EAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AAChD,OAAkB,IAAA,EAAA,GAAA,CAAA,EAAA,MAAA,GAAA,IAAlB,EAAkB,EAAA,GAAA,MAAA,CAAA,MAAlB,EAAkB,EAAA,EAAlB,EAAwB;AAAnB,QAAM,GAAG,GAAA,MAAA,CAAA,EAAA,CAAT;;AACH,IAAA,MAAM,CAAC,MAAM,IAAI,EAAX,EAAe,GAAf,CAAN;AACD;;AAED,SAAO,MAAP;AACD;AAED;;;;;AAKG;AACH;;AACA,SAAS,MAAT,CAAkC,MAAlC,EAA6C,MAA7C,EAAwD,kBAAxD,EAAsF;AAA9B,MAAA,kBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,kBAAA,GAAA,EAAA;AAA8B;;AACpF,EAAA,kBAAkB,CAAC,IAAnB,CAAwB,MAAxB;;AAEA,OAAK,IAAI,MAAT,IAAiB,MAAjB,EAAyB;AACvB,QAAI,MAAM,CAAC,cAAP,CAAsB,MAAtB,CAAJ,EAAiC;AAC/B,UAAI,MAAI,KAAK,WAAT,IAAwB,MAAI,KAAK,aAAjC,IAAkD,MAAI,KAAK,WAA/D,EAA4E;AAC1E,YAAM,KAAK,GAAgC,MAAM,CAAC,MAAD,CAAjD;;AACA,YAAI,OAAO,KAAP,KAAiB,QAAjB,IAA6B,KAAK,KAAK,IAAvC,IAA+C,CAAC,KAAK,CAAC,OAAN,CAAc,KAAd,CAApD,EAA0E;AACxE,cAAM,mBAAmB,GAAG,kBAAkB,CAAC,OAAnB,CAA2B,KAA3B,IAAoC,CAAC,CAAjE;AACA,UAAA,MAAM,CAAC,MAAD,CAAN,GAAgB,mBAAmB,GAC/B,KAD+B,GAE/B,MAAM,CAAC,MAAM,CAAC,MAAD,CAAN,IAAgB,EAAjB,EAAqB,KAArB,EAA4B,kBAA5B,CAFV;AAGD,SALD,MAKO;AACL,UAAA,MAAM,CAAC,MAAD,CAAN,GAAe,KAAf;AACD;AACF;AACF;AACF;;AAED,EAAA,kBAAkB,CAAC,GAAnB;AAEA,SAAO,MAAP;AACD","sourcesContent":["/**\n * Simple deep merge function. Takes all arguments and returns a deep copy of the objects merged\n * together in the order provided. If an object creates a circular reference, it will assign the\n * original reference.\n */\nexport function merge<T = {}>(target: Partial<T>, ...args: (Partial<T> | null | undefined | false)[]): T {\n  for (const arg of args) {\n    _merge(target || {}, arg as Partial<T>);\n  }\n\n  return target as T;\n}\n\n/**\n * The _merge helper iterates through all props on source and assigns them to target.\n * When the value is an object, we will create a deep clone of the object. However if\n * there is a circular reference, the value will not be deep cloned and will persist\n * the reference.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _merge<T extends Object>(target: T, source: T, circularReferences: any[] = []): T {\n  circularReferences.push(source);\n\n  for (let name in source) {\n    if (source.hasOwnProperty(name)) {\n      if (name !== '__proto__' && name !== 'constructor' && name !== 'prototype') {\n        const value: T[Extract<keyof T, string>] = source[name];\n        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n          const isCircularReference = circularReferences.indexOf(value) > -1;\n          target[name] = (isCircularReference\n            ? value\n            : _merge(target[name] || {}, value, circularReferences)) as T[Extract<keyof T, string>];\n        } else {\n          target[name] = value;\n        }\n      }\n    }\n  }\n\n  circularReferences.pop();\n\n  return target;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}