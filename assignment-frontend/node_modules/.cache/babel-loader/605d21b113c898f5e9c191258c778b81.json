{"ast":null,"code":"import { __assign, __spreadArrays } from \"tslib\";\nimport * as React from 'react';\nimport { mergeCss } from '@uifabric/merge-styles';\nimport { getRTL, memoizeFunction } from '@uifabric/utilities';\nimport { assign } from './utilities';\n/**\n * This function is required for any module that uses slots.\n *\n * This function is a slot resolver that automatically evaluates slot functions to generate React elements.\n * A byproduct of this resolver is that it removes slots from the React hierarchy by bypassing React.createElement.\n *\n * To use this function on a per-file basis, use the jsx directive targeting withSlots.\n * This directive must be the FIRST LINE in the file to work correctly.\n * Usage of this pragma also requires withSlots import statement.\n *\n * See React.createElement\n */\n// Can't use typeof on React.createElement since it's overloaded. Approximate createElement's signature for now\n// and widen as needed.\n\nexport function withSlots(type, props) {\n  var children = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    children[_i - 2] = arguments[_i];\n  }\n\n  var slotType = type;\n\n  if (slotType.isSlot) {\n    // Since we are bypassing createElement, use React.Children.toArray to make sure children are\n    // properly assigned keys.\n    // TODO: should this be mutating? does React mutate children subprop with createElement?\n    // TODO: will toArray clobber existing keys?\n    // TODO: React generates warnings because it doesn't detect hidden member _store that is set in createElement.\n    //        Even children passed to createElement without keys don't generate this warning.\n    //        Is there a better way to prevent slots from appearing in hierarchy? toArray doesn't address root issue.\n    children = React.Children.toArray(children); // TODO: There is something weird going on here with children embedded in props vs. rest args.\n    // Comment out these lines to see. Make sure this function is doing the right things.\n\n    if (children.length === 0) {\n      return slotType(props);\n    }\n\n    return slotType(__assign(__assign({}, props), {\n      children: children\n    }));\n  } else {\n    // TODO: Are there some cases where children should NOT be spread? Also, spreading reraises perf question.\n    //        Children had to be spread to avoid breaking KeytipData in Toggle.view:\n    //        react-dom.development.js:18931 Uncaught TypeError: children is not a function\n    //        Without spread, function child is a child array of one element\n    // TODO: is there a reason this can't be:\n    // return React.createElement.apply(this, arguments);\n    return React.createElement.apply(React, __spreadArrays([type, props], children));\n  }\n}\n/**\n * This function creates factories that render ouput depending on the user ISlotProp props passed in.\n * @param DefaultComponent - Base component to render when not overridden by user props.\n * @param options - Factory options, including defaultProp value for shorthand prop mapping.\n * @returns ISlotFactory function used for rendering slots.\n */\n\nexport function createFactory(DefaultComponent, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.defaultProp,\n      defaultProp = _a === void 0 ? 'children' : _a;\n\n  var result = function (componentProps, userProps, userSlotOptions, defaultStyles, theme) {\n    // If they passed in raw JSX, just return that.\n    if (React.isValidElement(userProps)) {\n      return userProps;\n    }\n\n    var flattenedUserProps = _translateShorthand(defaultProp, userProps);\n\n    var finalProps = _constructFinalProps(defaultStyles, theme, componentProps, flattenedUserProps);\n\n    if (userSlotOptions) {\n      if (userSlotOptions.component) {\n        // TODO: Remove cast if possible. This cast is needed because TS errors on the intrinsic portion of ReactType.\n        // return <userSlotOptions.component {...finalProps} />;\n        var UserComponent = userSlotOptions.component;\n        return React.createElement(UserComponent, __assign({}, finalProps));\n      }\n\n      if (userSlotOptions.render) {\n        return userSlotOptions.render(finalProps, DefaultComponent);\n      }\n    }\n\n    return React.createElement(DefaultComponent, __assign({}, finalProps));\n  };\n\n  return result;\n}\n/**\n * Default factory for components without explicit factories.\n */\n\nvar defaultFactory = memoizeFunction(function (type) {\n  return createFactory(type);\n});\n/**\n * This function generates slots that can be used in JSX given a definition of slots and their corresponding types.\n * @param userProps - Props as pass to component.\n * @param slots - Slot definition object defining the default slot component for each slot.\n * @returns A set of created slots that components can render in JSX.\n */\n\nexport function getSlots(userProps, slots) {\n  var result = {}; // userProps already has default props mixed in by createComponent. Recast here to gain typing for this function.\n\n  var mixedProps = userProps;\n\n  var _loop_1 = function (name_1) {\n    if (slots.hasOwnProperty(name_1)) {\n      // This closure method requires the use of withSlots to prevent unnecessary rerenders. This is because React\n      // detects each closure as a different component (since it is a new instance) from the previous one and then\n      // forces a rerender of the entire slot subtree. For now, the only way to avoid this is to use withSlots, which\n      // bypasses the call to React.createElement.\n      var slot = function (componentProps) {\n        var args = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments[_i];\n        }\n\n        if (args.length > 0) {\n          // If React.createElement is being incorrectly used with slots, there will be additional arguments.\n          // We can detect these additional arguments and error on their presence.\n          throw new Error('Any module using getSlots must use withSlots. Please see withSlots javadoc for more info.');\n        } // TODO: having TS infer types here seems to cause infinite loop.\n        //   use explicit types or casting to preserve typing if possible.\n        // TODO: this should be a lookup on TProps property instead of being TProps directly, which is probably\n        //   causing the infinite loop\n\n\n        return _renderSlot(slots[name_1], // TODO: this cast to any is hiding a relationship issue between the first two args\n        componentProps, mixedProps[name_1], mixedProps.slots && mixedProps.slots[name_1], // _defaultStyles should always be present, but a check for existence is added to make view tests\n        // easier to use.\n        mixedProps._defaultStyles && mixedProps._defaultStyles[name_1], mixedProps.theme);\n      };\n\n      slot.isSlot = true;\n      result[name_1] = slot;\n    }\n  };\n\n  for (var name_1 in slots) {\n    _loop_1(name_1);\n  }\n\n  return result;\n}\n/**\n * Helper function that translates shorthand as needed.\n * @param defaultProp\n * @param slotProps\n */\n\nfunction _translateShorthand(defaultProp, slotProps) {\n  var _a;\n\n  var transformedProps;\n\n  if (typeof slotProps === 'string' || typeof slotProps === 'number' || typeof slotProps === 'boolean') {\n    transformedProps = (_a = {}, _a[defaultProp] = slotProps, _a);\n  } else {\n    transformedProps = slotProps;\n  }\n\n  return transformedProps;\n}\n/**\n * Helper function that constructs final styles and props given a series of props ordered by increasing priority.\n */\n\n\nfunction _constructFinalProps(defaultStyles, theme) {\n  var allProps = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    allProps[_i - 2] = arguments[_i];\n  }\n\n  var finalProps = {};\n  var classNames = [];\n\n  for (var _a = 0, allProps_1 = allProps; _a < allProps_1.length; _a++) {\n    var props = allProps_1[_a];\n    classNames.push(props && props.className);\n    assign(finalProps, props);\n  }\n\n  finalProps.className = mergeCss([defaultStyles, classNames], {\n    rtl: getRTL(theme)\n  });\n  return finalProps;\n}\n/**\n * Render a slot given component and user props. Uses component factory if available, otherwise falls back\n * to default factory.\n * @param ComponentType Factory component type.\n * @param componentProps The properties passed into slot from within the component.\n * @param userProps The user properties passed in from outside of the component.\n */\n\n\nfunction _renderSlot(ComponentType, componentProps, userProps, slotOptions, defaultStyles, theme) {\n  if (ComponentType.create !== undefined) {\n    return ComponentType.create(componentProps, userProps, slotOptions, defaultStyles);\n  } else {\n    // TODO: need to resolve typing / generic issues passing through memoizeFunction. for now, cast to 'unknown'\n    return defaultFactory(ComponentType)(componentProps, userProps, slotOptions, defaultStyles, theme);\n  }\n}","map":{"version":3,"sources":["slots.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { mergeCss } from '@uifabric/merge-styles';\nimport { IStyle, ITheme } from '@uifabric/styling';\nimport { getRTL, memoizeFunction } from '@uifabric/utilities';\nimport { assign } from './utilities';\nimport { IFactoryOptions } from './IComponent';\nimport {\n  ISlottableReactType,\n  ISlot,\n  ISlots,\n  ISlotDefinition,\n  ISlotFactory,\n  ISlotProp,\n  ISlottableProps,\n  ISlotOptions,\n  IDefaultSlotProps,\n  IProcessedSlotProps,\n  ValidProps,\n  ValidShorthand,\n} from './ISlots';\n\n/**\n * This function is required for any module that uses slots.\n *\n * This function is a slot resolver that automatically evaluates slot functions to generate React elements.\n * A byproduct of this resolver is that it removes slots from the React hierarchy by bypassing React.createElement.\n *\n * To use this function on a per-file basis, use the jsx directive targeting withSlots.\n * This directive must be the FIRST LINE in the file to work correctly.\n * Usage of this pragma also requires withSlots import statement.\n *\n * See React.createElement\n */\n// Can't use typeof on React.createElement since it's overloaded. Approximate createElement's signature for now\n// and widen as needed.\nexport function withSlots<P>(\n  type: ISlot<P> | React.FunctionComponent<P> | string,\n  props?: (React.Attributes & P) | null,\n  ...children: React.ReactNode[]\n): ReturnType<React.FunctionComponent<P>> {\n  const slotType = type as ISlot<P>;\n  if (slotType.isSlot) {\n    // Since we are bypassing createElement, use React.Children.toArray to make sure children are\n    // properly assigned keys.\n    // TODO: should this be mutating? does React mutate children subprop with createElement?\n    // TODO: will toArray clobber existing keys?\n    // TODO: React generates warnings because it doesn't detect hidden member _store that is set in createElement.\n    //        Even children passed to createElement without keys don't generate this warning.\n    //        Is there a better way to prevent slots from appearing in hierarchy? toArray doesn't address root issue.\n    children = React.Children.toArray(children);\n\n    // TODO: There is something weird going on here with children embedded in props vs. rest args.\n    // Comment out these lines to see. Make sure this function is doing the right things.\n    if (children.length === 0) {\n      return slotType(props);\n    }\n\n    return slotType({ ...(props as any), children });\n  } else {\n    // TODO: Are there some cases where children should NOT be spread? Also, spreading reraises perf question.\n    //        Children had to be spread to avoid breaking KeytipData in Toggle.view:\n    //        react-dom.development.js:18931 Uncaught TypeError: children is not a function\n    //        Without spread, function child is a child array of one element\n    // TODO: is there a reason this can't be:\n    // return React.createElement.apply(this, arguments);\n    return React.createElement(type, props, ...children);\n  }\n}\n\n/**\n * This function creates factories that render ouput depending on the user ISlotProp props passed in.\n * @param DefaultComponent - Base component to render when not overridden by user props.\n * @param options - Factory options, including defaultProp value for shorthand prop mapping.\n * @returns ISlotFactory function used for rendering slots.\n */\nexport function createFactory<TProps extends ValidProps, TShorthandProp extends ValidShorthand = never>(\n  DefaultComponent: React.ComponentType<TProps>,\n  options: IFactoryOptions<TProps> = {},\n): ISlotFactory<TProps, TShorthandProp> {\n  const { defaultProp = 'children' } = options;\n\n  const result: ISlotFactory<TProps, TShorthandProp> = (\n    componentProps,\n    userProps,\n    userSlotOptions,\n    defaultStyles,\n    theme,\n  ) => {\n    // If they passed in raw JSX, just return that.\n    if (React.isValidElement(userProps)) {\n      return userProps;\n    }\n\n    const flattenedUserProps: TProps | undefined = _translateShorthand(defaultProp as string, userProps);\n    const finalProps = _constructFinalProps(defaultStyles, theme, componentProps, flattenedUserProps);\n\n    if (userSlotOptions) {\n      if (userSlotOptions.component) {\n        // TODO: Remove cast if possible. This cast is needed because TS errors on the intrinsic portion of ReactType.\n        // return <userSlotOptions.component {...finalProps} />;\n        const UserComponent = userSlotOptions.component as React.ComponentType<TProps>;\n        return <UserComponent {...finalProps} />;\n      }\n\n      if (userSlotOptions.render) {\n        return userSlotOptions.render(finalProps, DefaultComponent);\n      }\n    }\n\n    return <DefaultComponent {...finalProps} />;\n  };\n\n  return result;\n}\n\n/**\n * Default factory for components without explicit factories.\n */\nconst defaultFactory = memoizeFunction(type => createFactory(type));\n\n/**\n * This function generates slots that can be used in JSX given a definition of slots and their corresponding types.\n * @param userProps - Props as pass to component.\n * @param slots - Slot definition object defining the default slot component for each slot.\n * @returns A set of created slots that components can render in JSX.\n */\nexport function getSlots<TComponentProps extends ISlottableProps<TComponentSlots>, TComponentSlots>(\n  userProps: TComponentProps,\n  slots: ISlotDefinition<Required<TComponentSlots>>,\n): ISlots<Required<TComponentSlots>> {\n  const result: ISlots<Required<TComponentSlots>> = {} as ISlots<Required<TComponentSlots>>;\n\n  // userProps already has default props mixed in by createComponent. Recast here to gain typing for this function.\n  const mixedProps = userProps as TComponentProps & IDefaultSlotProps<TComponentSlots>;\n\n  for (const name in slots) {\n    if (slots.hasOwnProperty(name)) {\n      // This closure method requires the use of withSlots to prevent unnecessary rerenders. This is because React\n      // detects each closure as a different component (since it is a new instance) from the previous one and then\n      // forces a rerender of the entire slot subtree. For now, the only way to avoid this is to use withSlots, which\n      // bypasses the call to React.createElement.\n      const slot: ISlots<Required<TComponentSlots>>[keyof TComponentSlots] = (componentProps, ...args: any[]) => {\n        if (args.length > 0) {\n          // If React.createElement is being incorrectly used with slots, there will be additional arguments.\n          // We can detect these additional arguments and error on their presence.\n          throw new Error('Any module using getSlots must use withSlots. Please see withSlots javadoc for more info.');\n        }\n        // TODO: having TS infer types here seems to cause infinite loop.\n        //   use explicit types or casting to preserve typing if possible.\n        // TODO: this should be a lookup on TProps property instead of being TProps directly, which is probably\n        //   causing the infinite loop\n        return _renderSlot<any, any, any>(\n          slots[name],\n          // TODO: this cast to any is hiding a relationship issue between the first two args\n          componentProps as any,\n          mixedProps[name],\n          mixedProps.slots && mixedProps.slots[name],\n          // _defaultStyles should always be present, but a check for existence is added to make view tests\n          // easier to use.\n          mixedProps._defaultStyles && mixedProps._defaultStyles[name],\n          (mixedProps as any).theme,\n        );\n      };\n      slot.isSlot = true;\n      result[name] = slot;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Helper function that translates shorthand as needed.\n * @param defaultProp\n * @param slotProps\n */\nfunction _translateShorthand<TProps extends ValidProps, TShorthandProp extends ValidShorthand>(\n  defaultProp: string,\n  slotProps: ISlotProp<TProps, TShorthandProp>,\n): TProps | undefined {\n  let transformedProps: TProps | undefined;\n\n  if (typeof slotProps === 'string' || typeof slotProps === 'number' || typeof slotProps === 'boolean') {\n    transformedProps = {\n      [defaultProp]: slotProps as any,\n    } as TProps;\n  } else {\n    transformedProps = slotProps as TProps;\n  }\n\n  return transformedProps;\n}\n\n/**\n * Helper function that constructs final styles and props given a series of props ordered by increasing priority.\n */\nfunction _constructFinalProps<TProps extends IProcessedSlotProps>(\n  defaultStyles: IStyle,\n  theme?: ITheme,\n  ...allProps: (TProps | undefined)[]\n): TProps {\n  const finalProps: TProps = {} as any;\n  const classNames: (string | undefined)[] = [];\n\n  for (const props of allProps) {\n    classNames.push(props && props.className);\n    assign(finalProps, props);\n  }\n\n  finalProps.className = mergeCss([defaultStyles, classNames], { rtl: getRTL(theme) });\n\n  return finalProps;\n}\n\n/**\n * Render a slot given component and user props. Uses component factory if available, otherwise falls back\n * to default factory.\n * @param ComponentType Factory component type.\n * @param componentProps The properties passed into slot from within the component.\n * @param userProps The user properties passed in from outside of the component.\n */\nfunction _renderSlot<\n  TSlotComponent extends ISlottableReactType<TSlotProps, TSlotShorthand>,\n  TSlotProps extends ValidProps,\n  TSlotShorthand extends ValidShorthand\n>(\n  ComponentType: TSlotComponent,\n  componentProps: TSlotProps,\n  userProps: ISlotProp<TSlotProps, TSlotShorthand>,\n  slotOptions: ISlotOptions<TSlotProps> | undefined,\n  defaultStyles: IStyle,\n  theme?: ITheme,\n): ReturnType<React.FunctionComponent> {\n  if (ComponentType.create !== undefined) {\n    return ComponentType.create(componentProps, userProps, slotOptions, defaultStyles);\n  } else {\n    // TODO: need to resolve typing / generic issues passing through memoizeFunction. for now, cast to 'unknown'\n    return ((defaultFactory(ComponentType) as unknown) as ISlotFactory<TSlotProps, TSlotShorthand>)(\n      componentProps,\n      userProps,\n      slotOptions,\n      defaultStyles,\n      theme,\n    );\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}