{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, classNamesFunction, divProperties, getNativeProps, getRTL, initializeComponentRef } from '../../Utilities';\nimport { ScrollablePaneContext } from './ScrollablePane.types';\nvar getClassNames = classNamesFunction();\n\nvar ScrollablePaneBase =\n/** @class */\nfunction (_super) {\n  __extends(ScrollablePaneBase, _super);\n\n  function ScrollablePaneBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    _this._stickyAboveRef = React.createRef();\n    _this._stickyBelowRef = React.createRef();\n    _this._contentContainer = React.createRef();\n\n    _this.subscribe = function (handler) {\n      _this._subscribers.add(handler);\n    };\n\n    _this.unsubscribe = function (handler) {\n      _this._subscribers.delete(handler);\n    };\n\n    _this.addSticky = function (sticky) {\n      _this._stickies.add(sticky); // If ScrollablePane is mounted, then sort sticky in correct place\n\n\n      if (_this.contentContainer) {\n        sticky.setDistanceFromTop(_this.contentContainer);\n\n        _this.sortSticky(sticky);\n      }\n    };\n\n    _this.removeSticky = function (sticky) {\n      _this._stickies.delete(sticky);\n\n      _this._removeStickyFromContainers(sticky);\n\n      _this.notifySubscribers();\n    };\n\n    _this.sortSticky = function (sticky, sortAgain) {\n      if (_this.stickyAbove && _this.stickyBelow) {\n        if (sortAgain) {\n          _this._removeStickyFromContainers(sticky);\n        }\n\n        if (sticky.canStickyTop && sticky.stickyContentTop) {\n          _this._addToStickyContainer(sticky, _this.stickyAbove, sticky.stickyContentTop);\n        }\n\n        if (sticky.canStickyBottom && sticky.stickyContentBottom) {\n          _this._addToStickyContainer(sticky, _this.stickyBelow, sticky.stickyContentBottom);\n        }\n      }\n    };\n\n    _this.updateStickyRefHeights = function () {\n      var stickyItems = _this._stickies;\n      var stickyTopHeight = 0;\n      var stickyBottomHeight = 0;\n      stickyItems.forEach(function (sticky) {\n        var _a = sticky.state,\n            isStickyTop = _a.isStickyTop,\n            isStickyBottom = _a.isStickyBottom;\n\n        if (sticky.nonStickyContent) {\n          if (isStickyTop) {\n            stickyTopHeight += sticky.nonStickyContent.offsetHeight;\n          }\n\n          if (isStickyBottom) {\n            stickyBottomHeight += sticky.nonStickyContent.offsetHeight;\n          }\n\n          _this._checkStickyStatus(sticky);\n        }\n      });\n\n      _this.setState({\n        stickyTopHeight: stickyTopHeight,\n        stickyBottomHeight: stickyBottomHeight\n      });\n    };\n\n    _this.notifySubscribers = function () {\n      if (_this.contentContainer) {\n        _this._subscribers.forEach(function (handle) {\n          // this.stickyBelow is passed in for calculating distance to determine Sticky status\n          handle(_this.contentContainer, _this.stickyBelow);\n        });\n      }\n    };\n\n    _this.getScrollPosition = function () {\n      if (_this.contentContainer) {\n        return _this.contentContainer.scrollTop;\n      }\n\n      return 0;\n    };\n\n    _this.syncScrollSticky = function (sticky) {\n      if (sticky && _this.contentContainer) {\n        sticky.syncScroll(_this.contentContainer);\n      }\n    };\n\n    _this._getScrollablePaneContext = function () {\n      return {\n        scrollablePane: {\n          subscribe: _this.subscribe,\n          unsubscribe: _this.unsubscribe,\n          addSticky: _this.addSticky,\n          removeSticky: _this.removeSticky,\n          updateStickyRefHeights: _this.updateStickyRefHeights,\n          sortSticky: _this.sortSticky,\n          notifySubscribers: _this.notifySubscribers,\n          syncScrollSticky: _this.syncScrollSticky\n        }\n      };\n    };\n\n    _this._addToStickyContainer = function (sticky, stickyContainer, stickyContentToAdd) {\n      // If there's no children, append child to list, otherwise, sort though array and append at correct position\n      if (!stickyContainer.children.length) {\n        stickyContainer.appendChild(stickyContentToAdd);\n      } else {\n        // If stickyContentToAdd isn't a child element of target container, then append\n        if (!stickyContainer.contains(stickyContentToAdd)) {\n          var stickyChildrenElements_1 = [].slice.call(stickyContainer.children);\n          var stickyList_1 = []; // Get stickies.  Filter by canStickyTop/Bottom, then sort by distance from top, and then\n          // filter by elements that are in the stickyContainer already.\n\n          _this._stickies.forEach(function (stickyItem) {\n            if (stickyContainer === _this.stickyAbove && sticky.canStickyTop) {\n              stickyList_1.push(stickyItem);\n            } else if (sticky.canStickyBottom) {\n              stickyList_1.push(stickyItem);\n            }\n          });\n\n          var stickyListSorted = stickyList_1.sort(function (a, b) {\n            return (a.state.distanceFromTop || 0) - (b.state.distanceFromTop || 0);\n          }).filter(function (item) {\n            var stickyContent = stickyContainer === _this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;\n\n            if (stickyContent) {\n              return stickyChildrenElements_1.indexOf(stickyContent) > -1;\n            }\n\n            return false;\n          }); // Get first element that has a distance from top that is further than our sticky that is being added\n\n          var targetStickyToAppendBefore = undefined;\n\n          for (var _i = 0, stickyListSorted_1 = stickyListSorted; _i < stickyListSorted_1.length; _i++) {\n            var stickyListItem = stickyListSorted_1[_i];\n\n            if ((stickyListItem.state.distanceFromTop || 0) >= (sticky.state.distanceFromTop || 0)) {\n              targetStickyToAppendBefore = stickyListItem;\n              break;\n            }\n          } // If target element to append before is known, grab respective stickyContentTop/Bottom element\n          // and insert before\n\n\n          var targetContainer = null;\n\n          if (targetStickyToAppendBefore) {\n            targetContainer = stickyContainer === _this.stickyAbove ? targetStickyToAppendBefore.stickyContentTop : targetStickyToAppendBefore.stickyContentBottom;\n          }\n\n          stickyContainer.insertBefore(stickyContentToAdd, targetContainer);\n        }\n      }\n    };\n\n    _this._removeStickyFromContainers = function (sticky) {\n      if (_this.stickyAbove && sticky.stickyContentTop && _this.stickyAbove.contains(sticky.stickyContentTop)) {\n        _this.stickyAbove.removeChild(sticky.stickyContentTop);\n      }\n\n      if (_this.stickyBelow && sticky.stickyContentBottom && _this.stickyBelow.contains(sticky.stickyContentBottom)) {\n        _this.stickyBelow.removeChild(sticky.stickyContentBottom);\n      }\n    };\n\n    _this._onWindowResize = function () {\n      var scrollbarWidth = _this._getScrollbarWidth();\n\n      var scrollbarHeight = _this._getScrollbarHeight();\n\n      _this.setState({\n        scrollbarWidth: scrollbarWidth,\n        scrollbarHeight: scrollbarHeight\n      });\n\n      _this.notifySubscribers();\n    };\n\n    _this._getStickyContainerStyle = function (height, isTop) {\n      return __assign(__assign({\n        height: height\n      }, getRTL(_this.props.theme) ? {\n        right: '0',\n        left: (_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0) + \"px\"\n      } : {\n        left: '0',\n        right: (_this.state.scrollbarWidth || _this._getScrollbarWidth() || 0) + \"px\"\n      }), isTop ? {\n        top: '0'\n      } : {\n        bottom: (_this.state.scrollbarHeight || _this._getScrollbarHeight() || 0) + \"px\"\n      });\n    };\n\n    _this._onScroll = function () {\n      var contentContainer = _this.contentContainer;\n\n      if (contentContainer) {\n        _this._stickies.forEach(function (sticky) {\n          sticky.syncScroll(contentContainer);\n        });\n      }\n\n      _this._notifyThrottled();\n    };\n\n    _this._subscribers = new Set();\n    _this._stickies = new Set();\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this.state = {\n      stickyTopHeight: 0,\n      stickyBottomHeight: 0,\n      scrollbarWidth: 0,\n      scrollbarHeight: 0\n    };\n    _this._notifyThrottled = _this._async.throttle(_this.notifySubscribers, 50);\n    return _this;\n  }\n\n  Object.defineProperty(ScrollablePaneBase.prototype, \"root\", {\n    get: function () {\n      return this._root.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"stickyAbove\", {\n    get: function () {\n      return this._stickyAboveRef.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"stickyBelow\", {\n    get: function () {\n      return this._stickyBelowRef.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ScrollablePaneBase.prototype, \"contentContainer\", {\n    get: function () {\n      return this._contentContainer.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ScrollablePaneBase.prototype.componentDidMount = function () {\n    var _this = this;\n\n    var initialScrollPosition = this.props.initialScrollPosition;\n\n    this._events.on(this.contentContainer, 'scroll', this._onScroll);\n\n    this._events.on(window, 'resize', this._onWindowResize);\n\n    if (this.contentContainer && initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    } // Set sticky distances from top property, then sort in correct order and notify subscribers\n\n\n    this.setStickiesDistanceFromTop();\n\n    this._stickies.forEach(function (sticky) {\n      _this.sortSticky(sticky);\n    });\n\n    this.notifySubscribers();\n\n    if ('MutationObserver' in window) {\n      this._mutationObserver = new MutationObserver(function (mutation) {\n        // Function to check if mutation is occuring in stickyAbove or stickyBelow\n        function checkIfMutationIsSticky(mutationRecord) {\n          if (this.stickyAbove !== null && this.stickyBelow !== null) {\n            return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);\n          }\n\n          return false;\n        } // Compute the scrollbar height, which might have changed if the content's width changed and caused overflow\n\n\n        var scrollbarHeight = _this._getScrollbarHeight(); // If the scrollbar height changed, update state so it's postioned correctly below sticky footer\n\n\n        if (scrollbarHeight !== _this.state.scrollbarHeight) {\n          _this.setState({\n            scrollbarHeight: scrollbarHeight\n          });\n        } // Notify subscribers again to re-check whether Sticky should be Sticky'd or not\n\n\n        _this.notifySubscribers(); // If mutation occurs in sticky header or footer, then update sticky top/bottom heights\n\n\n        if (mutation.some(checkIfMutationIsSticky.bind(_this))) {\n          _this.updateStickyRefHeights();\n        } else {\n          // If mutation occurs in scrollable region, then find Sticky it belongs to and force update\n          var stickyList_2 = [];\n\n          _this._stickies.forEach(function (sticky) {\n            if (sticky.root && sticky.root.contains(mutation[0].target)) {\n              stickyList_2.push(sticky);\n            }\n          });\n\n          if (stickyList_2.length) {\n            stickyList_2.forEach(function (sticky) {\n              sticky.forceUpdate();\n            });\n          }\n        }\n      });\n\n      if (this.root) {\n        this._mutationObserver.observe(this.root, {\n          childList: true,\n          attributes: true,\n          subtree: true,\n          characterData: true\n        });\n      }\n    }\n  };\n\n  ScrollablePaneBase.prototype.componentWillUnmount = function () {\n    this._events.dispose();\n\n    this._async.dispose();\n\n    if (this._mutationObserver) {\n      this._mutationObserver.disconnect();\n    }\n  }; // Only updates if props/state change, just to prevent excessive setState with updateStickyRefHeights\n\n\n  ScrollablePaneBase.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    return this.props.children !== nextProps.children || this.props.initialScrollPosition !== nextProps.initialScrollPosition || this.props.className !== nextProps.className || this.state.stickyTopHeight !== nextState.stickyTopHeight || this.state.stickyBottomHeight !== nextState.stickyBottomHeight || this.state.scrollbarWidth !== nextState.scrollbarWidth || this.state.scrollbarHeight !== nextState.scrollbarHeight;\n  };\n\n  ScrollablePaneBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var initialScrollPosition = this.props.initialScrollPosition;\n\n    if (this.contentContainer && typeof initialScrollPosition === 'number' && prevProps.initialScrollPosition !== initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    } // Update subscribers when stickyTopHeight/stickyBottomHeight changes\n\n\n    if (prevState.stickyTopHeight !== this.state.stickyTopHeight || prevState.stickyBottomHeight !== this.state.stickyBottomHeight) {\n      this.notifySubscribers();\n    }\n\n    this._async.setTimeout(this._onWindowResize, 0);\n  };\n\n  ScrollablePaneBase.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        theme = _a.theme,\n        styles = _a.styles;\n    var _b = this.state,\n        stickyTopHeight = _b.stickyTopHeight,\n        stickyBottomHeight = _b.stickyBottomHeight;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      scrollbarVisibility: this.props.scrollbarVisibility\n    });\n    return React.createElement(\"div\", __assign({}, getNativeProps(this.props, divProperties), {\n      ref: this._root,\n      className: classNames.root\n    }), React.createElement(\"div\", {\n      ref: this._stickyAboveRef,\n      className: classNames.stickyAbove,\n      style: this._getStickyContainerStyle(stickyTopHeight, true)\n    }), React.createElement(\"div\", {\n      ref: this._contentContainer,\n      className: classNames.contentContainer,\n      \"data-is-scrollable\": true\n    }, React.createElement(ScrollablePaneContext.Provider, {\n      value: this._getScrollablePaneContext()\n    }, this.props.children)), React.createElement(\"div\", {\n      className: classNames.stickyBelow,\n      style: this._getStickyContainerStyle(stickyBottomHeight, false)\n    }, React.createElement(\"div\", {\n      ref: this._stickyBelowRef,\n      className: classNames.stickyBelowItems\n    })));\n  };\n\n  ScrollablePaneBase.prototype.setStickiesDistanceFromTop = function () {\n    var _this = this;\n\n    if (this.contentContainer) {\n      this._stickies.forEach(function (sticky) {\n        sticky.setDistanceFromTop(_this.contentContainer);\n      });\n    }\n  };\n\n  ScrollablePaneBase.prototype.forceLayoutUpdate = function () {\n    this._onWindowResize();\n  };\n\n  ScrollablePaneBase.prototype._checkStickyStatus = function (sticky) {\n    if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {\n      // If sticky is sticky, then append content to appropriate container\n      if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {\n        if (sticky.state.isStickyTop && !this.stickyAbove.contains(sticky.nonStickyContent) && sticky.stickyContentTop) {\n          sticky.addSticky(sticky.stickyContentTop);\n        }\n\n        if (sticky.state.isStickyBottom && !this.stickyBelow.contains(sticky.nonStickyContent) && sticky.stickyContentBottom) {\n          sticky.addSticky(sticky.stickyContentBottom);\n        }\n      } else if (!this.contentContainer.contains(sticky.nonStickyContent)) {\n        // Reset sticky if it's not sticky and not in the contentContainer element\n        sticky.resetSticky();\n      }\n    }\n  };\n\n  ScrollablePaneBase.prototype._getScrollbarWidth = function () {\n    var contentContainer = this.contentContainer;\n    return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : 0;\n  };\n\n  ScrollablePaneBase.prototype._getScrollbarHeight = function () {\n    var contentContainer = this.contentContainer;\n    return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : 0;\n  };\n\n  return ScrollablePaneBase;\n}(React.Component);\n\nexport { ScrollablePaneBase };","map":{"version":3,"sources":["components/ScrollablePane/ScrollablePane.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  EventGroup,\n  classNamesFunction,\n  divProperties,\n  getNativeProps,\n  getRTL,\n  initializeComponentRef,\n} from '../../Utilities';\nimport {\n  IScrollablePane,\n  IScrollablePaneContext,\n  IScrollablePaneProps,\n  IScrollablePaneStyleProps,\n  IScrollablePaneStyles,\n  ScrollablePaneContext,\n} from './ScrollablePane.types';\nimport { Sticky } from '../../Sticky';\n\nexport interface IScrollablePaneState {\n  stickyTopHeight: number;\n  stickyBottomHeight: number;\n  scrollbarWidth: number;\n  scrollbarHeight: number;\n}\n\nconst getClassNames = classNamesFunction<IScrollablePaneStyleProps, IScrollablePaneStyles>();\n\nexport class ScrollablePaneBase extends React.Component<IScrollablePaneProps, IScrollablePaneState>\n  implements IScrollablePane {\n  private _root = React.createRef<HTMLDivElement>();\n  private _stickyAboveRef = React.createRef<HTMLDivElement>();\n  private _stickyBelowRef = React.createRef<HTMLDivElement>();\n  private _contentContainer = React.createRef<HTMLDivElement>();\n  private _subscribers: Set<Function>;\n  private _stickies: Set<Sticky>;\n  private _mutationObserver: MutationObserver;\n  private _notifyThrottled: () => void;\n  private _async: Async;\n  private _events: EventGroup;\n\n  constructor(props: IScrollablePaneProps) {\n    super(props);\n    this._subscribers = new Set<Function>();\n    this._stickies = new Set<Sticky>();\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n    this._events = new EventGroup(this);\n\n    this.state = {\n      stickyTopHeight: 0,\n      stickyBottomHeight: 0,\n      scrollbarWidth: 0,\n      scrollbarHeight: 0,\n    };\n\n    this._notifyThrottled = this._async.throttle(this.notifySubscribers, 50);\n  }\n\n  public get root(): HTMLDivElement | null {\n    return this._root.current;\n  }\n\n  public get stickyAbove(): HTMLDivElement | null {\n    return this._stickyAboveRef.current;\n  }\n\n  public get stickyBelow(): HTMLDivElement | null {\n    return this._stickyBelowRef.current;\n  }\n\n  public get contentContainer(): HTMLDivElement | null {\n    return this._contentContainer.current;\n  }\n\n  public componentDidMount() {\n    const { initialScrollPosition } = this.props;\n    this._events.on(this.contentContainer, 'scroll', this._onScroll);\n    this._events.on(window, 'resize', this._onWindowResize);\n    if (this.contentContainer && initialScrollPosition) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n\n    // Set sticky distances from top property, then sort in correct order and notify subscribers\n    this.setStickiesDistanceFromTop();\n    this._stickies.forEach(sticky => {\n      this.sortSticky(sticky);\n    });\n    this.notifySubscribers();\n\n    if ('MutationObserver' in window) {\n      this._mutationObserver = new MutationObserver(mutation => {\n        // Function to check if mutation is occuring in stickyAbove or stickyBelow\n        function checkIfMutationIsSticky(mutationRecord: MutationRecord): boolean {\n          if (this.stickyAbove !== null && this.stickyBelow !== null) {\n            return this.stickyAbove.contains(mutationRecord.target) || this.stickyBelow.contains(mutationRecord.target);\n          }\n          return false;\n        }\n\n        // Compute the scrollbar height, which might have changed if the content's width changed and caused overflow\n        const scrollbarHeight = this._getScrollbarHeight();\n        // If the scrollbar height changed, update state so it's postioned correctly below sticky footer\n        if (scrollbarHeight !== this.state.scrollbarHeight) {\n          this.setState({\n            scrollbarHeight: scrollbarHeight,\n          });\n        }\n\n        // Notify subscribers again to re-check whether Sticky should be Sticky'd or not\n        this.notifySubscribers();\n\n        // If mutation occurs in sticky header or footer, then update sticky top/bottom heights\n        if (mutation.some(checkIfMutationIsSticky.bind(this))) {\n          this.updateStickyRefHeights();\n        } else {\n          // If mutation occurs in scrollable region, then find Sticky it belongs to and force update\n          const stickyList: Sticky[] = [];\n          this._stickies.forEach(sticky => {\n            if (sticky.root && sticky.root.contains(mutation[0].target)) {\n              stickyList.push(sticky);\n            }\n          });\n          if (stickyList.length) {\n            stickyList.forEach(sticky => {\n              sticky.forceUpdate();\n            });\n          }\n        }\n      });\n\n      if (this.root) {\n        this._mutationObserver.observe(this.root, {\n          childList: true,\n          attributes: true,\n          subtree: true,\n          characterData: true,\n        });\n      }\n    }\n  }\n\n  public componentWillUnmount() {\n    this._events.dispose();\n    this._async.dispose();\n\n    if (this._mutationObserver) {\n      this._mutationObserver.disconnect();\n    }\n  }\n\n  // Only updates if props/state change, just to prevent excessive setState with updateStickyRefHeights\n  public shouldComponentUpdate(nextProps: IScrollablePaneProps, nextState: IScrollablePaneState): boolean {\n    return (\n      this.props.children !== nextProps.children ||\n      this.props.initialScrollPosition !== nextProps.initialScrollPosition ||\n      this.props.className !== nextProps.className ||\n      this.state.stickyTopHeight !== nextState.stickyTopHeight ||\n      this.state.stickyBottomHeight !== nextState.stickyBottomHeight ||\n      this.state.scrollbarWidth !== nextState.scrollbarWidth ||\n      this.state.scrollbarHeight !== nextState.scrollbarHeight\n    );\n  }\n\n  public componentDidUpdate(prevProps: IScrollablePaneProps, prevState: IScrollablePaneState) {\n    const initialScrollPosition = this.props.initialScrollPosition;\n    if (\n      this.contentContainer &&\n      typeof initialScrollPosition === 'number' &&\n      prevProps.initialScrollPosition !== initialScrollPosition\n    ) {\n      this.contentContainer.scrollTop = initialScrollPosition;\n    }\n\n    // Update subscribers when stickyTopHeight/stickyBottomHeight changes\n    if (\n      prevState.stickyTopHeight !== this.state.stickyTopHeight ||\n      prevState.stickyBottomHeight !== this.state.stickyBottomHeight\n    ) {\n      this.notifySubscribers();\n    }\n\n    this._async.setTimeout(this._onWindowResize, 0);\n  }\n\n  public render(): JSX.Element {\n    const { className, theme, styles } = this.props;\n    const { stickyTopHeight, stickyBottomHeight } = this.state;\n    const classNames = getClassNames(styles!, {\n      theme: theme!,\n      className,\n      scrollbarVisibility: this.props.scrollbarVisibility,\n    });\n\n    return (\n      <div {...getNativeProps(this.props, divProperties)} ref={this._root} className={classNames.root}>\n        <div\n          ref={this._stickyAboveRef}\n          className={classNames.stickyAbove}\n          style={this._getStickyContainerStyle(stickyTopHeight, true)}\n        />\n        <div ref={this._contentContainer} className={classNames.contentContainer} data-is-scrollable={true}>\n          <ScrollablePaneContext.Provider value={this._getScrollablePaneContext()}>\n            {this.props.children}\n          </ScrollablePaneContext.Provider>\n        </div>\n        <div className={classNames.stickyBelow} style={this._getStickyContainerStyle(stickyBottomHeight, false)}>\n          <div ref={this._stickyBelowRef} className={classNames.stickyBelowItems} />\n        </div>\n      </div>\n    );\n  }\n\n  public setStickiesDistanceFromTop(): void {\n    if (this.contentContainer) {\n      this._stickies.forEach(sticky => {\n        sticky.setDistanceFromTop(this.contentContainer as HTMLDivElement);\n      });\n    }\n  }\n\n  public forceLayoutUpdate() {\n    this._onWindowResize();\n  }\n\n  public subscribe = (handler: Function): void => {\n    this._subscribers.add(handler);\n  };\n\n  public unsubscribe = (handler: Function): void => {\n    this._subscribers.delete(handler);\n  };\n\n  public addSticky = (sticky: Sticky): void => {\n    this._stickies.add(sticky);\n\n    // If ScrollablePane is mounted, then sort sticky in correct place\n    if (this.contentContainer) {\n      sticky.setDistanceFromTop(this.contentContainer);\n      this.sortSticky(sticky);\n    }\n  };\n\n  public removeSticky = (sticky: Sticky): void => {\n    this._stickies.delete(sticky);\n    this._removeStickyFromContainers(sticky);\n    this.notifySubscribers();\n  };\n\n  public sortSticky = (sticky: Sticky, sortAgain?: boolean): void => {\n    if (this.stickyAbove && this.stickyBelow) {\n      if (sortAgain) {\n        this._removeStickyFromContainers(sticky);\n      }\n      if (sticky.canStickyTop && sticky.stickyContentTop) {\n        this._addToStickyContainer(sticky, this.stickyAbove, sticky.stickyContentTop);\n      }\n\n      if (sticky.canStickyBottom && sticky.stickyContentBottom) {\n        this._addToStickyContainer(sticky, this.stickyBelow, sticky.stickyContentBottom);\n      }\n    }\n  };\n\n  public updateStickyRefHeights = (): void => {\n    const stickyItems = this._stickies;\n\n    let stickyTopHeight = 0;\n    let stickyBottomHeight = 0;\n\n    stickyItems.forEach((sticky: Sticky) => {\n      const { isStickyTop, isStickyBottom } = sticky.state;\n      if (sticky.nonStickyContent) {\n        if (isStickyTop) {\n          stickyTopHeight += sticky.nonStickyContent.offsetHeight;\n        }\n        if (isStickyBottom) {\n          stickyBottomHeight += sticky.nonStickyContent.offsetHeight;\n        }\n        this._checkStickyStatus(sticky);\n      }\n    });\n\n    this.setState({\n      stickyTopHeight: stickyTopHeight,\n      stickyBottomHeight: stickyBottomHeight,\n    });\n  };\n\n  public notifySubscribers = (): void => {\n    if (this.contentContainer) {\n      this._subscribers.forEach(handle => {\n        // this.stickyBelow is passed in for calculating distance to determine Sticky status\n        handle(this.contentContainer, this.stickyBelow);\n      });\n    }\n  };\n\n  public getScrollPosition = (): number => {\n    if (this.contentContainer) {\n      return this.contentContainer.scrollTop;\n    }\n\n    return 0;\n  };\n\n  public syncScrollSticky = (sticky: Sticky): void => {\n    if (sticky && this.contentContainer) {\n      sticky.syncScroll(this.contentContainer);\n    }\n  };\n\n  private _getScrollablePaneContext = (): IScrollablePaneContext => {\n    return {\n      scrollablePane: {\n        subscribe: this.subscribe,\n        unsubscribe: this.unsubscribe,\n        addSticky: this.addSticky,\n        removeSticky: this.removeSticky,\n        updateStickyRefHeights: this.updateStickyRefHeights,\n        sortSticky: this.sortSticky,\n        notifySubscribers: this.notifySubscribers,\n        syncScrollSticky: this.syncScrollSticky,\n      },\n    };\n  };\n\n  private _checkStickyStatus(sticky: Sticky): void {\n    if (this.stickyAbove && this.stickyBelow && this.contentContainer && sticky.nonStickyContent) {\n      // If sticky is sticky, then append content to appropriate container\n      if (sticky.state.isStickyTop || sticky.state.isStickyBottom) {\n        if (\n          sticky.state.isStickyTop &&\n          !this.stickyAbove.contains(sticky.nonStickyContent) &&\n          sticky.stickyContentTop\n        ) {\n          sticky.addSticky(sticky.stickyContentTop);\n        }\n\n        if (\n          sticky.state.isStickyBottom &&\n          !this.stickyBelow.contains(sticky.nonStickyContent) &&\n          sticky.stickyContentBottom\n        ) {\n          sticky.addSticky(sticky.stickyContentBottom);\n        }\n      } else if (!this.contentContainer.contains(sticky.nonStickyContent)) {\n        // Reset sticky if it's not sticky and not in the contentContainer element\n        sticky.resetSticky();\n      }\n    }\n  }\n\n  private _addToStickyContainer = (\n    sticky: Sticky,\n    stickyContainer: HTMLDivElement,\n    stickyContentToAdd: HTMLDivElement,\n  ): void => {\n    // If there's no children, append child to list, otherwise, sort though array and append at correct position\n    if (!stickyContainer.children.length) {\n      stickyContainer.appendChild(stickyContentToAdd);\n    } else {\n      // If stickyContentToAdd isn't a child element of target container, then append\n      if (!stickyContainer.contains(stickyContentToAdd)) {\n        const stickyChildrenElements: Element[] = [].slice.call(stickyContainer.children);\n\n        const stickyList: Sticky[] = [];\n        // Get stickies.  Filter by canStickyTop/Bottom, then sort by distance from top, and then\n        // filter by elements that are in the stickyContainer already.\n        this._stickies.forEach(stickyItem => {\n          if (stickyContainer === this.stickyAbove && sticky.canStickyTop) {\n            stickyList.push(stickyItem);\n          } else if (sticky.canStickyBottom) {\n            stickyList.push(stickyItem);\n          }\n        });\n\n        const stickyListSorted = stickyList\n          .sort((a, b) => {\n            return (a.state.distanceFromTop || 0) - (b.state.distanceFromTop || 0);\n          })\n          .filter(item => {\n            const stickyContent =\n              stickyContainer === this.stickyAbove ? item.stickyContentTop : item.stickyContentBottom;\n            if (stickyContent) {\n              return stickyChildrenElements.indexOf(stickyContent) > -1;\n            }\n            return false;\n          });\n\n        // Get first element that has a distance from top that is further than our sticky that is being added\n        let targetStickyToAppendBefore: Sticky | undefined = undefined;\n        for (const stickyListItem of stickyListSorted) {\n          if ((stickyListItem.state.distanceFromTop || 0) >= (sticky.state.distanceFromTop || 0)) {\n            targetStickyToAppendBefore = stickyListItem;\n            break;\n          }\n        }\n\n        // If target element to append before is known, grab respective stickyContentTop/Bottom element\n        // and insert before\n        let targetContainer: HTMLDivElement | null = null;\n        if (targetStickyToAppendBefore) {\n          targetContainer =\n            stickyContainer === this.stickyAbove\n              ? targetStickyToAppendBefore.stickyContentTop\n              : targetStickyToAppendBefore.stickyContentBottom;\n        }\n        stickyContainer.insertBefore(stickyContentToAdd, targetContainer);\n      }\n    }\n  };\n\n  private _removeStickyFromContainers = (sticky: Sticky): void => {\n    if (this.stickyAbove && sticky.stickyContentTop && this.stickyAbove.contains(sticky.stickyContentTop)) {\n      this.stickyAbove.removeChild(sticky.stickyContentTop);\n    }\n    if (this.stickyBelow && sticky.stickyContentBottom && this.stickyBelow.contains(sticky.stickyContentBottom)) {\n      this.stickyBelow.removeChild(sticky.stickyContentBottom);\n    }\n  };\n\n  private _onWindowResize = (): void => {\n    const scrollbarWidth = this._getScrollbarWidth();\n    const scrollbarHeight = this._getScrollbarHeight();\n\n    this.setState({\n      scrollbarWidth,\n      scrollbarHeight,\n    });\n\n    this.notifySubscribers();\n  };\n\n  private _getStickyContainerStyle = (height: number, isTop: boolean): React.CSSProperties => {\n    return {\n      height: height,\n      ...(getRTL(this.props.theme)\n        ? {\n            right: '0',\n            left: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`,\n          }\n        : {\n            left: '0',\n            right: `${this.state.scrollbarWidth || this._getScrollbarWidth() || 0}px`,\n          }),\n      ...(isTop\n        ? {\n            top: '0',\n          }\n        : {\n            bottom: `${this.state.scrollbarHeight || this._getScrollbarHeight() || 0}px`,\n          }),\n    };\n  };\n\n  private _getScrollbarWidth(): number {\n    const { contentContainer } = this;\n    return contentContainer ? contentContainer.offsetWidth - contentContainer.clientWidth : 0;\n  }\n\n  private _getScrollbarHeight(): number {\n    const { contentContainer } = this;\n    return contentContainer ? contentContainer.offsetHeight - contentContainer.clientHeight : 0;\n  }\n\n  private _onScroll = () => {\n    const { contentContainer } = this;\n\n    if (contentContainer) {\n      this._stickies.forEach((sticky: Sticky) => {\n        sticky.syncScroll(contentContainer);\n      });\n    }\n\n    this._notifyThrottled();\n  };\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}