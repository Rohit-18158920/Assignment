{"ast":null,"code":"import { SELECTION_CHANGE, SelectionMode } from './Selection.types';\nimport { EventGroup } from '../EventGroup';\n/**\n * {@docCategory Selection}\n */\n\nvar Selection =\n/** @class */\nfunction () {\n  /**\n   * Create a new Selection. If `TItem` does not have a `key` property, you must provide an options\n   * object with a `getKey` implementation. Providing options is optional otherwise.\n   * (At most one `options` object is accepted.)\n   */\n  function Selection() {\n    var options = []; // Otherwise, arguments require options with `getKey`.\n\n    for (var _i = 0 // Otherwise, arguments require options with `getKey`.\n    ; _i < arguments.length // Otherwise, arguments require options with `getKey`.\n    ; _i++ // Otherwise, arguments require options with `getKey`.\n    ) {\n      options[_i] = arguments[_i]; // Otherwise, arguments require options with `getKey`.\n    }\n\n    var _a = options[0] || {},\n        onSelectionChanged = _a.onSelectionChanged,\n        getKey = _a.getKey,\n        _b = _a.canSelectItem,\n        canSelectItem = _b === void 0 ? function () {\n      return true;\n    } : _b,\n        items = _a.items,\n        _c = _a.selectionMode,\n        selectionMode = _c === void 0 ? SelectionMode.multiple : _c;\n\n    this.mode = selectionMode;\n    this._getKey = getKey || defaultGetKey;\n    this._changeEventSuppressionCount = 0;\n    this._exemptedCount = 0;\n    this._anchoredIndex = 0;\n    this._unselectableCount = 0;\n    this._onSelectionChanged = onSelectionChanged;\n    this._canSelectItem = canSelectItem;\n    this._isModal = false;\n    this.setItems(items || [], true);\n    this.count = this.getSelectedCount();\n  }\n\n  Selection.prototype.canSelectItem = function (item, index) {\n    if (typeof index === 'number' && index < 0) {\n      return false;\n    }\n\n    return this._canSelectItem(item, index);\n  };\n\n  Selection.prototype.getKey = function (item, index) {\n    var key = this._getKey(item, index);\n\n    return typeof key === 'number' || key ? \"\" + key : '';\n  };\n\n  Selection.prototype.setChangeEvents = function (isEnabled, suppressChange) {\n    this._changeEventSuppressionCount += isEnabled ? -1 : 1;\n\n    if (this._changeEventSuppressionCount === 0 && this._hasChanged) {\n      this._hasChanged = false;\n\n      if (!suppressChange) {\n        this._change();\n      }\n    }\n  };\n\n  Selection.prototype.isModal = function () {\n    return this._isModal;\n  };\n\n  Selection.prototype.setModal = function (isModal) {\n    if (this._isModal !== isModal) {\n      this.setChangeEvents(false);\n      this._isModal = isModal;\n\n      if (!isModal) {\n        this.setAllSelected(false);\n      }\n\n      this._change();\n\n      this.setChangeEvents(true);\n    }\n  };\n  /**\n   * Selection needs the items, call this method to set them. If the set\n   * of items is the same, this will re-evaluate selection and index maps.\n   * Otherwise, shouldClear should be set to true, so that selection is\n   * cleared.\n   */\n\n\n  Selection.prototype.setItems = function (items, shouldClear) {\n    if (shouldClear === void 0) {\n      shouldClear = true;\n    }\n\n    var newKeyToIndexMap = {};\n    var newUnselectableIndices = {};\n    var hasSelectionChanged = false;\n    this.setChangeEvents(false); // Reset the unselectable count.\n\n    this._unselectableCount = 0; // Build lookup table for quick selection evaluation.\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (item) {\n        var key = this.getKey(item, i);\n\n        if (key) {\n          newKeyToIndexMap[key] = i;\n        }\n      }\n\n      newUnselectableIndices[i] = item && !this.canSelectItem(item);\n\n      if (newUnselectableIndices[i]) {\n        this._unselectableCount++;\n      }\n    }\n\n    if (shouldClear || items.length === 0) {\n      this._setAllSelected(false, true);\n    } // Check the exemption list for discrepencies.\n\n\n    var newExemptedIndicies = {};\n    var newExemptedCount = 0;\n\n    for (var indexProperty in this._exemptedIndices) {\n      if (this._exemptedIndices.hasOwnProperty(indexProperty)) {\n        var index = Number(indexProperty);\n        var item = this._items[index];\n        var exemptKey = item ? this.getKey(item, Number(index)) : undefined;\n        var newIndex = exemptKey ? newKeyToIndexMap[exemptKey] : index;\n\n        if (newIndex === undefined) {\n          // The item has likely been replaced or removed.\n          hasSelectionChanged = true;\n        } else {\n          // We know the new index of the item. update the existing exemption table.\n          newExemptedIndicies[newIndex] = true;\n          newExemptedCount++;\n          hasSelectionChanged = hasSelectionChanged || newIndex !== index;\n        }\n      }\n    }\n\n    if (this._items && this._exemptedCount === 0 && items.length !== this._items.length && this._isAllSelected) {\n      // If everything was selected but the number of items has changed, selection has changed.\n      hasSelectionChanged = true;\n    }\n\n    this._exemptedIndices = newExemptedIndicies;\n    this._exemptedCount = newExemptedCount;\n    this._keyToIndexMap = newKeyToIndexMap;\n    this._unselectableIndices = newUnselectableIndices;\n    this._items = items;\n    this._selectedItems = null;\n\n    if (hasSelectionChanged) {\n      this._updateCount();\n\n      this._change();\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype.getItems = function () {\n    return this._items;\n  };\n\n  Selection.prototype.getSelection = function () {\n    if (!this._selectedItems) {\n      this._selectedItems = [];\n      var items = this._items;\n\n      if (items) {\n        for (var i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedItems.push(items[i]);\n          }\n        }\n      }\n    }\n\n    return this._selectedItems;\n  };\n\n  Selection.prototype.getSelectedCount = function () {\n    return this._isAllSelected ? this._items.length - this._exemptedCount - this._unselectableCount : this._exemptedCount;\n  };\n\n  Selection.prototype.getSelectedIndices = function () {\n    if (!this._selectedIndices) {\n      this._selectedIndices = [];\n      var items = this._items;\n\n      if (items) {\n        for (var i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedIndices.push(i);\n          }\n        }\n      }\n    }\n\n    return this._selectedIndices;\n  };\n\n  Selection.prototype.isRangeSelected = function (fromIndex, count) {\n    if (count === 0) {\n      return false;\n    }\n\n    var endIndex = fromIndex + count;\n\n    for (var i = fromIndex; i < endIndex; i++) {\n      if (!this.isIndexSelected(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Selection.prototype.isAllSelected = function () {\n    var selectableCount = this._items.length - this._unselectableCount; // In single mode, we can only have a max of 1 item.\n\n    if (this.mode === SelectionMode.single) {\n      selectableCount = Math.min(selectableCount, 1);\n    }\n\n    return this.count > 0 && this._isAllSelected && this._exemptedCount === 0 || !this._isAllSelected && this._exemptedCount === selectableCount && selectableCount > 0;\n  };\n\n  Selection.prototype.isKeySelected = function (key) {\n    var index = this._keyToIndexMap[key];\n    return this.isIndexSelected(index);\n  };\n\n  Selection.prototype.isIndexSelected = function (index) {\n    return !!(this.count > 0 && this._isAllSelected && !this._exemptedIndices[index] && !this._unselectableIndices[index] || !this._isAllSelected && this._exemptedIndices[index]);\n  };\n\n  Selection.prototype.setAllSelected = function (isAllSelected) {\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n\n    var selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n    this.setChangeEvents(false);\n\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n\n        this._change();\n      }\n\n      this._updateCount();\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype.setKeySelected = function (key, isSelected, shouldAnchor) {\n    var index = this._keyToIndexMap[key];\n\n    if (index >= 0) {\n      this.setIndexSelected(index, isSelected, shouldAnchor);\n    }\n  };\n\n  Selection.prototype.setIndexSelected = function (index, isSelected, shouldAnchor) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    } // Clamp the index.\n\n\n    index = Math.min(Math.max(0, index), this._items.length - 1); // No-op on out of bounds selections.\n\n    if (index < 0 || index >= this._items.length) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n    var isExempt = this._exemptedIndices[index];\n    var canSelect = !this._unselectableIndices[index];\n\n    if (canSelect) {\n      if (isSelected && this.mode === SelectionMode.single) {\n        // If this is single-select, the previous selection should be removed.\n        this._setAllSelected(false, true);\n      } // Determine if we need to remove the exemption.\n\n\n      if (isExempt && (isSelected && this._isAllSelected || !isSelected && !this._isAllSelected)) {\n        delete this._exemptedIndices[index];\n        this._exemptedCount--;\n      } // Determine if we need to add the exemption.\n\n\n      if (!isExempt && (isSelected && !this._isAllSelected || !isSelected && this._isAllSelected)) {\n        this._exemptedIndices[index] = true;\n        this._exemptedCount++;\n      }\n\n      if (shouldAnchor) {\n        this._anchoredIndex = index;\n      }\n    }\n\n    this._updateCount();\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype.selectToKey = function (key, clearSelection) {\n    this.selectToIndex(this._keyToIndexMap[key], clearSelection);\n  };\n\n  Selection.prototype.selectToIndex = function (index, clearSelection) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    if (this.mode === SelectionMode.single) {\n      this.setIndexSelected(index, true, true);\n      return;\n    }\n\n    var anchorIndex = this._anchoredIndex || 0;\n    var startIndex = Math.min(index, anchorIndex);\n    var endIndex = Math.max(index, anchorIndex);\n    this.setChangeEvents(false);\n\n    if (clearSelection) {\n      this._setAllSelected(false, true);\n    }\n\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, true, false);\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype.toggleAllSelected = function () {\n    this.setAllSelected(!this.isAllSelected());\n  };\n\n  Selection.prototype.toggleKeySelected = function (key) {\n    this.setKeySelected(key, !this.isKeySelected(key), true);\n  };\n\n  Selection.prototype.toggleIndexSelected = function (index) {\n    this.setIndexSelected(index, !this.isIndexSelected(index), true);\n  };\n\n  Selection.prototype.toggleRangeSelected = function (fromIndex, count) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    var isRangeSelected = this.isRangeSelected(fromIndex, count);\n    var endIndex = fromIndex + count;\n\n    if (this.mode === SelectionMode.single && count > 1) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n\n    for (var i = fromIndex; i < endIndex; i++) {\n      this.setIndexSelected(i, !isRangeSelected, false);\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype._updateCount = function (preserveModalState) {\n    if (preserveModalState === void 0) {\n      preserveModalState = false;\n    }\n\n    var count = this.getSelectedCount();\n\n    if (count !== this.count) {\n      this.count = count;\n\n      this._change();\n    }\n\n    if (!this.count && !preserveModalState) {\n      this.setModal(false);\n    }\n  };\n\n  Selection.prototype._setAllSelected = function (isAllSelected, preserveModalState) {\n    if (preserveModalState === void 0) {\n      preserveModalState = false;\n    }\n\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n\n    var selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n    this.setChangeEvents(false);\n\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n\n        this._change();\n      }\n\n      this._updateCount(preserveModalState);\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype._change = function () {\n    if (this._changeEventSuppressionCount === 0) {\n      this._selectedItems = null;\n      this._selectedIndices = undefined;\n      EventGroup.raise(this, SELECTION_CHANGE);\n\n      if (this._onSelectionChanged) {\n        this._onSelectionChanged();\n      }\n    } else {\n      this._hasChanged = true;\n    }\n  };\n\n  return Selection;\n}();\n\nexport { Selection };\n\nfunction defaultGetKey(item, index) {\n  // 0 may be used as a key\n  var _a = (item || {}).key,\n      key = _a === void 0 ? \"\" + index : _a;\n  return key;\n}","map":{"version":3,"sources":["selection/Selection.ts"],"names":[],"mappings":"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","sourcesContent":["import { IObjectWithKey, ISelection, SELECTION_CHANGE, SelectionMode } from './Selection.types';\nimport { EventGroup } from '../EventGroup';\n\n/**\n * {@docCategory Selection}\n */\nexport interface ISelectionOptions<TItem = IObjectWithKey> {\n  onSelectionChanged?: () => void;\n  /** Custom logic to generate item keys. Required if `TItem` does not have a `key` property. */\n  getKey?: (item: TItem, index?: number) => string | number;\n  canSelectItem?: (item: TItem, index?: number) => boolean;\n  selectionMode?: SelectionMode;\n  items?: TItem[];\n}\n\n/**\n * Selection options with required `getKey` property.\n * {@docCategory Selection}\n */\nexport type ISelectionOptionsWithRequiredGetKey<TItem> = ISelectionOptions<TItem> &\n  Required<Pick<ISelectionOptions<TItem>, 'getKey'>>;\n\n/**\n * {@docCategory Selection}\n */\nexport class Selection<TItem = IObjectWithKey> implements ISelection<TItem> {\n  /** Number of items selected. Do not modify. */\n  public count: number;\n  public readonly mode: SelectionMode;\n\n  private _getKey: (item: TItem, index?: number) => string | number;\n  private _canSelectItem: (item: TItem, index?: number) => boolean;\n\n  private _changeEventSuppressionCount: number;\n  private _items: TItem[];\n  private _selectedItems: TItem[] | null;\n  private _selectedIndices: number[] | undefined;\n  private _isAllSelected: boolean;\n  private _exemptedIndices: { [index: string]: boolean };\n  private _exemptedCount: number;\n  private _keyToIndexMap: { [key: string]: number };\n  private _anchoredIndex: number;\n  private _onSelectionChanged: (() => void) | undefined;\n  private _hasChanged: boolean;\n  private _unselectableIndices: { [index: string]: boolean };\n  private _unselectableCount: number;\n  private _isModal: boolean;\n\n  /**\n   * Create a new Selection. If `TItem` does not have a `key` property, you must provide an options\n   * object with a `getKey` implementation. Providing options is optional otherwise.\n   * (At most one `options` object is accepted.)\n   */\n  constructor(\n    ...options: TItem extends IObjectWithKey // If the item type has a built-in key...\n      ? [] | [ISelectionOptions<TItem>] // Then the arguments can be empty or have the options without `getKey`\n      : [ISelectionOptionsWithRequiredGetKey<TItem>] // Otherwise, arguments require options with `getKey`.\n  ) {\n    const { onSelectionChanged, getKey, canSelectItem = () => true, items, selectionMode = SelectionMode.multiple } =\n      options[0] || ({} as ISelectionOptions<TItem>);\n\n    this.mode = selectionMode;\n\n    this._getKey = getKey || defaultGetKey;\n\n    this._changeEventSuppressionCount = 0;\n    this._exemptedCount = 0;\n    this._anchoredIndex = 0;\n    this._unselectableCount = 0;\n\n    this._onSelectionChanged = onSelectionChanged;\n    this._canSelectItem = canSelectItem;\n\n    this._isModal = false;\n\n    this.setItems(items || [], true);\n\n    this.count = this.getSelectedCount();\n  }\n\n  public canSelectItem(item: TItem, index?: number): boolean {\n    if (typeof index === 'number' && index < 0) {\n      return false;\n    }\n\n    return this._canSelectItem(item, index);\n  }\n\n  public getKey(item: TItem, index?: number): string {\n    const key = this._getKey(item, index);\n\n    return typeof key === 'number' || key ? `${key}` : '';\n  }\n\n  public setChangeEvents(isEnabled: boolean, suppressChange?: boolean): void {\n    this._changeEventSuppressionCount += isEnabled ? -1 : 1;\n\n    if (this._changeEventSuppressionCount === 0 && this._hasChanged) {\n      this._hasChanged = false;\n\n      if (!suppressChange) {\n        this._change();\n      }\n    }\n  }\n\n  public isModal(): boolean {\n    return this._isModal;\n  }\n\n  public setModal(isModal: boolean): void {\n    if (this._isModal !== isModal) {\n      this.setChangeEvents(false);\n\n      this._isModal = isModal;\n\n      if (!isModal) {\n        this.setAllSelected(false);\n      }\n\n      this._change();\n\n      this.setChangeEvents(true);\n    }\n  }\n\n  /**\n   * Selection needs the items, call this method to set them. If the set\n   * of items is the same, this will re-evaluate selection and index maps.\n   * Otherwise, shouldClear should be set to true, so that selection is\n   * cleared.\n   */\n  public setItems(items: TItem[], shouldClear: boolean = true): void {\n    const newKeyToIndexMap: { [key: string]: number } = {};\n    const newUnselectableIndices: { [key: string]: boolean } = {};\n    let hasSelectionChanged = false;\n\n    this.setChangeEvents(false);\n\n    // Reset the unselectable count.\n    this._unselectableCount = 0;\n\n    // Build lookup table for quick selection evaluation.\n    for (let i = 0; i < items.length; i++) {\n      const item = items[i];\n\n      if (item) {\n        const key = this.getKey(item, i);\n\n        if (key) {\n          newKeyToIndexMap[key] = i;\n        }\n      }\n\n      newUnselectableIndices[i] = item && !this.canSelectItem(item);\n      if (newUnselectableIndices[i]) {\n        this._unselectableCount++;\n      }\n    }\n\n    if (shouldClear || items.length === 0) {\n      this._setAllSelected(false, true);\n    }\n\n    // Check the exemption list for discrepencies.\n    const newExemptedIndicies: { [key: string]: boolean } = {};\n    let newExemptedCount = 0;\n\n    for (const indexProperty in this._exemptedIndices) {\n      if (this._exemptedIndices.hasOwnProperty(indexProperty)) {\n        const index = Number(indexProperty);\n        const item = this._items[index];\n        const exemptKey = item ? this.getKey(item, Number(index)) : undefined;\n        const newIndex = exemptKey ? newKeyToIndexMap[exemptKey] : index;\n\n        if (newIndex === undefined) {\n          // The item has likely been replaced or removed.\n          hasSelectionChanged = true;\n        } else {\n          // We know the new index of the item. update the existing exemption table.\n          newExemptedIndicies[newIndex] = true;\n          newExemptedCount++;\n          hasSelectionChanged = hasSelectionChanged || newIndex !== index;\n        }\n      }\n    }\n\n    if (this._items && this._exemptedCount === 0 && items.length !== this._items.length && this._isAllSelected) {\n      // If everything was selected but the number of items has changed, selection has changed.\n      hasSelectionChanged = true;\n    }\n\n    this._exemptedIndices = newExemptedIndicies;\n    this._exemptedCount = newExemptedCount;\n    this._keyToIndexMap = newKeyToIndexMap;\n    this._unselectableIndices = newUnselectableIndices;\n    this._items = items;\n    this._selectedItems = null;\n\n    if (hasSelectionChanged) {\n      this._updateCount();\n      this._change();\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public getItems(): TItem[] {\n    return this._items;\n  }\n\n  public getSelection(): TItem[] {\n    if (!this._selectedItems) {\n      this._selectedItems = [];\n\n      const items = this._items;\n\n      if (items) {\n        for (let i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedItems.push(items[i]);\n          }\n        }\n      }\n    }\n\n    return this._selectedItems;\n  }\n\n  public getSelectedCount(): number {\n    return this._isAllSelected\n      ? this._items.length - this._exemptedCount - this._unselectableCount\n      : this._exemptedCount;\n  }\n\n  public getSelectedIndices(): number[] {\n    if (!this._selectedIndices) {\n      this._selectedIndices = [];\n\n      const items = this._items;\n\n      if (items) {\n        for (let i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedIndices.push(i);\n          }\n        }\n      }\n    }\n\n    return this._selectedIndices;\n  }\n\n  public isRangeSelected(fromIndex: number, count: number): boolean {\n    if (count === 0) {\n      return false;\n    }\n\n    const endIndex = fromIndex + count;\n\n    for (let i = fromIndex; i < endIndex; i++) {\n      if (!this.isIndexSelected(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public isAllSelected(): boolean {\n    let selectableCount = this._items.length - this._unselectableCount;\n\n    // In single mode, we can only have a max of 1 item.\n    if (this.mode === SelectionMode.single) {\n      selectableCount = Math.min(selectableCount, 1);\n    }\n\n    return (\n      (this.count > 0 && this._isAllSelected && this._exemptedCount === 0) ||\n      (!this._isAllSelected && this._exemptedCount === selectableCount && selectableCount > 0)\n    );\n  }\n\n  public isKeySelected(key: string): boolean {\n    const index = this._keyToIndexMap[key];\n\n    return this.isIndexSelected(index);\n  }\n\n  public isIndexSelected(index: number): boolean {\n    return !!(\n      (this.count > 0 && this._isAllSelected && !this._exemptedIndices[index] && !this._unselectableIndices[index]) ||\n      (!this._isAllSelected && this._exemptedIndices[index])\n    );\n  }\n\n  public setAllSelected(isAllSelected: boolean): void {\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n\n    const selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n\n    this.setChangeEvents(false);\n\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n        this._change();\n      }\n\n      this._updateCount();\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public setKeySelected(key: string, isSelected: boolean, shouldAnchor: boolean): void {\n    const index = this._keyToIndexMap[key];\n\n    if (index >= 0) {\n      this.setIndexSelected(index, isSelected, shouldAnchor);\n    }\n  }\n\n  public setIndexSelected(index: number, isSelected: boolean, shouldAnchor: boolean): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    // Clamp the index.\n    index = Math.min(Math.max(0, index), this._items.length - 1);\n\n    // No-op on out of bounds selections.\n    if (index < 0 || index >= this._items.length) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n\n    const isExempt = this._exemptedIndices[index];\n    const canSelect = !this._unselectableIndices[index];\n\n    if (canSelect) {\n      if (isSelected && this.mode === SelectionMode.single) {\n        // If this is single-select, the previous selection should be removed.\n        this._setAllSelected(false, true);\n      }\n\n      // Determine if we need to remove the exemption.\n      if (isExempt && ((isSelected && this._isAllSelected) || (!isSelected && !this._isAllSelected))) {\n        delete this._exemptedIndices[index];\n        this._exemptedCount--;\n      }\n\n      // Determine if we need to add the exemption.\n      if (!isExempt && ((isSelected && !this._isAllSelected) || (!isSelected && this._isAllSelected))) {\n        this._exemptedIndices[index] = true;\n        this._exemptedCount++;\n      }\n\n      if (shouldAnchor) {\n        this._anchoredIndex = index;\n      }\n    }\n\n    this._updateCount();\n\n    this.setChangeEvents(true);\n  }\n\n  public selectToKey(key: string, clearSelection?: boolean): void {\n    this.selectToIndex(this._keyToIndexMap[key], clearSelection);\n  }\n\n  public selectToIndex(index: number, clearSelection?: boolean): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    if (this.mode === SelectionMode.single) {\n      this.setIndexSelected(index, true, true);\n      return;\n    }\n\n    const anchorIndex = this._anchoredIndex || 0;\n    let startIndex = Math.min(index, anchorIndex);\n    const endIndex = Math.max(index, anchorIndex);\n\n    this.setChangeEvents(false);\n\n    if (clearSelection) {\n      this._setAllSelected(false, true);\n    }\n\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, true, false);\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  public toggleAllSelected(): void {\n    this.setAllSelected(!this.isAllSelected());\n  }\n\n  public toggleKeySelected(key: string): void {\n    this.setKeySelected(key, !this.isKeySelected(key), true);\n  }\n\n  public toggleIndexSelected(index: number): void {\n    this.setIndexSelected(index, !this.isIndexSelected(index), true);\n  }\n\n  public toggleRangeSelected(fromIndex: number, count: number): void {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    const isRangeSelected = this.isRangeSelected(fromIndex, count);\n    const endIndex = fromIndex + count;\n\n    if (this.mode === SelectionMode.single && count > 1) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n    for (let i = fromIndex; i < endIndex; i++) {\n      this.setIndexSelected(i, !isRangeSelected, false);\n    }\n    this.setChangeEvents(true);\n  }\n\n  private _updateCount(preserveModalState: boolean = false): void {\n    const count = this.getSelectedCount();\n\n    if (count !== this.count) {\n      this.count = count;\n      this._change();\n    }\n\n    if (!this.count && !preserveModalState) {\n      this.setModal(false);\n    }\n  }\n\n  private _setAllSelected(isAllSelected: boolean, preserveModalState: boolean = false): void {\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n\n    const selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n\n    this.setChangeEvents(false);\n\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n        this._change();\n      }\n\n      this._updateCount(preserveModalState);\n    }\n\n    this.setChangeEvents(true);\n  }\n\n  private _change(): void {\n    if (this._changeEventSuppressionCount === 0) {\n      this._selectedItems = null;\n      this._selectedIndices = undefined;\n\n      EventGroup.raise(this, SELECTION_CHANGE);\n\n      if (this._onSelectionChanged) {\n        this._onSelectionChanged();\n      }\n    } else {\n      this._hasChanged = true;\n    }\n  }\n}\n\nfunction defaultGetKey<TItem = IObjectWithKey>(item: TItem, index?: number): string | number {\n  // 0 may be used as a key\n  const { key = `${index}` } = (item || {}) as IObjectWithKey;\n  return key;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}