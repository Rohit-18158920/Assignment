{"ast":null,"code":"/**\n * asAsync - a HOC for async loading components.\n *\n * Usage:\n *\n * const AsyncDialog = asAsync({\n *   load: () => import('Dialog').then(result => result.default),\n * });\n *\n * React.render(domElement, <AsyncDialog asyncPlaceholder={ () => <Spinner/> } { ...dialogProps } />);\n *\n * Note the `asyncPlaceholder` prop will be respected when rendering the async component and it hasn't\n * been loaded yet.\n */\nimport { __assign, __extends, __rest } from \"tslib\";\nimport * as React from 'react';\n/**\n * If possible, use a WeakMap to maintain a cache of loaded components.\n * This can be used to synchronously render components that have already been loaded,\n * rather than having to wait for at least one async tick.\n */\n\nvar _syncModuleCache = typeof WeakMap !== 'undefined' ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\nnew WeakMap() : undefined;\n/**\n * Produces a component which internally loads the target component before first mount.\n * The component passes all props through to the loaded component.\n *\n * This overload accepts a module with a default export for the component.\n */\n\n\nexport function asAsync(options) {\n  var Async =\n  /** @class */\n  function (_super) {\n    __extends(Async, _super);\n\n    function Async() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.state = {\n        Component: _syncModuleCache ? _syncModuleCache.get(options.load) : undefined\n      };\n      return _this;\n    }\n\n    Async.prototype.render = function () {\n      // Typescript issue: the rest can't be pulled without the any cast, as TypeScript fails with rest on generics.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      var _a = this.props,\n          forwardedRef = _a.forwardedRef,\n          Placeholder = _a.asyncPlaceholder,\n          rest = __rest(_a, [\"forwardedRef\", \"asyncPlaceholder\"]);\n\n      var Component = this.state.Component;\n      return Component ? React.createElement(Component, __assign(__assign({}, rest), {\n        ref: forwardedRef\n      })) : Placeholder ? React.createElement(Placeholder, null) : null;\n    };\n\n    Async.prototype.componentDidMount = function () {\n      var _this = this;\n\n      var Component = this.state.Component;\n\n      if (!Component) {\n        options.load().then(function (LoadedComponent) {\n          if (LoadedComponent) {\n            // Cache component for future reference.\n            _syncModuleCache && _syncModuleCache.set(options.load, LoadedComponent); // Set state.\n\n            _this.setState({\n              Component: LoadedComponent\n            }, options.onLoad);\n          }\n        }).catch(options.onError);\n      }\n    };\n\n    return Async;\n  }(React.Component);\n\n  return React.forwardRef(function (props, ref) {\n    return React.createElement(Async, __assign({}, props, {\n      forwardedRef: ref\n    }));\n  });\n}","map":{"version":3,"sources":["asAsync.tsx"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;AAaG;;AAEH,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AAmBA;;;;AAIG;;AACH,IAAM,gBAAgB,GACpB,OAAO,OAAP,KAAmB,WAAnB,GACI;AACA,IAAI,OAAJ,EAFJ,GAGI,SAJN;AAMA;;;;;AAKG;;;AACH,OAAM,SAAU,OAAV,CAA0B,OAA1B,EAA0D;AAC9D,MAAA,KAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAAoB,IAAA,SAAA,CAAA,KAAA,EAAA,MAAA,CAAA;;AAApB,aAAA,KAAA,GAAA;AAAA,UAAA,KAAA,GAAA,MAAA,KAAA,IAAA,IAAA,MAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA,CAAA,IAAA,IAAA;;AAOS,MAAA,KAAA,CAAA,KAAA,GAAQ;AACb,QAAA,SAAS,EAAE,gBAAgB,GAAI,gBAAgB,CAAC,GAAjB,CAAqB,OAAO,CAAC,IAA7B,CAAJ,GAAuE;AADrF,OAAR;;AAuCR;;AAnCQ,IAAA,KAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACE;AACA;AACA,UAAM,EAAA,GAAA,KAAA,KAAN;AAAA,UAAQ,YAAA,GAAA,EAAA,CAAA,YAAR;AAAA,UAAsB,WAAA,GAAA,EAAA,CAAA,gBAAtB;AAAA,UAAqD,IAAA,GAAA,MAAA,CAAA,EAAA,EAAA,CAAA,cAAA,EAAA,kBAAA,CAAA,CAArD;;AACQ,UAAA,SAAA,GAAA,KAAA,KAAA,CAAA,SAAA;AACR,aAAO,SAAS,GACd,KAAK,CAAC,aAAN,CAAoB,SAApB,EAA6B,QAAA,CAAA,QAAA,CAAA,EAAA,EAAO,IAAP,CAAA,EAAW;AAAE,QAAA,GAAG,EAAE;AAAP,OAAX,CAA7B,CADc,GAEZ,WAAW,GACb,KAAA,CAAA,aAAA,CAAC,WAAD,EAAY,IAAZ,CADa,GAEX,IAJJ;AAKD,KAVM;;AAYA,IAAA,KAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,YAAA;AAAA,UAAA,KAAA,GAAA,IAAA;;AACQ,UAAA,SAAA,GAAA,KAAA,KAAA,CAAA,SAAA;;AAEN,UAAI,CAAC,SAAL,EAAgB;AACd,QAAA,OAAO,CACJ,IADH,GAEG,IAFH,CAEQ,UAAC,eAAD,EAA2C;AAC/C,cAAI,eAAJ,EAAqB;AACnB;AACA,YAAA,gBAAgB,IAAI,gBAAgB,CAAC,GAAjB,CAAqB,OAAO,CAAC,IAA7B,EAAmC,eAAnC,CAApB,CAFmB,CAInB;;AACA,YAAA,KAAI,CAAC,QAAL,CACE;AACE,cAAA,SAAS,EAAE;AADb,aADF,EAIE,OAAO,CAAC,MAJV;AAMD;AACF,SAfH,EAgBG,KAhBH,CAgBS,OAAO,CAAC,OAhBjB;AAiBD;AACF,KAtBM;;AAuBT,WAAA,KAAA;AAAC,GA9CD,CAAoB,KAAK,CAAC,SAA1B,CAAA;;AAgDA,SAAO,KAAK,CAAC,UAAN,CACL,UAAC,KAAD,EAAQ,GAAR,EAAW;AAAK,WAAA,KAAA,CAAA,aAAA,CAAC,KAAD,EAAM,QAAA,CAAA,EAAA,EAAK,KAAL,EAAU;AAAE,MAAA,YAAY,EAA9B;AAAgB,KAAV,CAAN,CAAA;AAAuC,GADlD,CAAP;AAGD","sourcesContent":["/**\n * asAsync - a HOC for async loading components.\n *\n * Usage:\n *\n * const AsyncDialog = asAsync({\n *   load: () => import('Dialog').then(result => result.default),\n * });\n *\n * React.render(domElement, <AsyncDialog asyncPlaceholder={ () => <Spinner/> } { ...dialogProps } />);\n *\n * Note the `asyncPlaceholder` prop will be respected when rendering the async component and it hasn't\n * been loaded yet.\n */\n\nimport * as React from 'react';\n\nexport interface IAsAsyncOptions<TProps> {\n  /**\n   * Callback which returns a promise resolving an object which exports the component.\n   */\n  load: () => Promise<React.ElementType<TProps>>;\n\n  /**\n   * Callback executed when async loading is complete.\n   */\n  onLoad?: () => void;\n\n  /**\n   * Callback when async loading fails.\n   */\n  onError?: (error: Error) => void;\n}\n\n/**\n * If possible, use a WeakMap to maintain a cache of loaded components.\n * This can be used to synchronously render components that have already been loaded,\n * rather than having to wait for at least one async tick.\n */\nconst _syncModuleCache =\n  typeof WeakMap !== 'undefined'\n    ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      new WeakMap<() => Promise<React.ElementType<any>>, React.ElementType<any> | undefined>()\n    : undefined;\n\n/**\n * Produces a component which internally loads the target component before first mount.\n * The component passes all props through to the loaded component.\n *\n * This overload accepts a module with a default export for the component.\n */\nexport function asAsync<TProps>(options: IAsAsyncOptions<TProps>) {\n  class Async extends React.Component<\n    TProps & {\n      asyncPlaceholder?: React.ElementType;\n      forwardedRef: React.Ref<React.ElementType<TProps>>;\n    },\n    { Component?: React.ElementType<TProps> }\n  > {\n    public state = {\n      Component: _syncModuleCache ? (_syncModuleCache.get(options.load) as React.ElementType<TProps>) : undefined,\n    };\n\n    public render(): JSX.Element | null {\n      // Typescript issue: the rest can't be pulled without the any cast, as TypeScript fails with rest on generics.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const { forwardedRef, asyncPlaceholder: Placeholder, ...rest } = this.props as any;\n      const { Component } = this.state;\n      return Component ? (\n        React.createElement(Component, { ...rest, ref: forwardedRef })\n      ) : Placeholder ? (\n        <Placeholder />\n      ) : null;\n    }\n\n    public componentDidMount(): void {\n      let { Component } = this.state;\n\n      if (!Component) {\n        options\n          .load()\n          .then((LoadedComponent: React.ElementType<TProps>) => {\n            if (LoadedComponent) {\n              // Cache component for future reference.\n              _syncModuleCache && _syncModuleCache.set(options.load, LoadedComponent);\n\n              // Set state.\n              this.setState(\n                {\n                  Component: LoadedComponent,\n                },\n                options.onLoad,\n              );\n            }\n          })\n          .catch(options.onError);\n      }\n    }\n  }\n\n  return React.forwardRef<React.ElementType<TProps>, TProps & { asyncPlaceholder?: React.ElementType }>(\n    (props, ref) => <Async {...props} forwardedRef={ref} />,\n  );\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}