{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport { DropdownMenuItemType } from '../Dropdown.types';\n/**\n * A utility class to cache size and position in cache.\n *\n * Dropdown options has non-selectable display types. It is therefore not cheap to determine\n * the total number of actual selectable options as well as the position an option is in the\n * list of options - O(n) cost for each lookup.\n *\n * Given that we potentially have to make this determination on every single render pass, this\n * cache should provide a little bit of relief.\n */\n\nvar DropdownSizePosCache =\n/** @class */\nfunction () {\n  function DropdownSizePosCache() {\n    this._size = 0;\n  }\n  /**\n   * Invalidates the cache and recalculate the size of selectable options.\n   */\n\n\n  DropdownSizePosCache.prototype.updateOptions = function (options) {\n    var displayOnlyOptionsCache = [];\n    var size = 0;\n\n    for (var i = 0; i < options.length; i++) {\n      if (options[i].itemType === DropdownMenuItemType.Divider || options[i].itemType === DropdownMenuItemType.Header) {\n        displayOnlyOptionsCache.push(i);\n      } else if (!options[i].hidden) {\n        size++;\n      }\n    }\n\n    this._size = size;\n    this._displayOnlyOptionsCache = displayOnlyOptionsCache;\n    this._cachedOptions = __spreadArrays(options);\n  };\n\n  Object.defineProperty(DropdownSizePosCache.prototype, \"optionSetSize\", {\n    /**\n     * The size of all the selectable options.\n     */\n    get: function () {\n      return this._size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DropdownSizePosCache.prototype, \"cachedOptions\", {\n    /**\n     * The chached options array.\n     */\n    get: function () {\n      return this._cachedOptions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns the position of this option element relative to the full set of selectable option elements.\n   * Note: the first selectable element is position 1 in the set.\n   * @param index The raw index of the option element.\n   */\n\n  DropdownSizePosCache.prototype.positionInSet = function (index) {\n    if (index === undefined) {\n      return undefined;\n    } // we could possibly memoize this too but this should be good enough, most of the time (the expectation is that\n    // when you have a lot of options, the selectable options will heavily dominate over the non-selectable options.\n\n\n    var offset = 0;\n\n    while (index > this._displayOnlyOptionsCache[offset]) {\n      offset++;\n    }\n\n    if (this._displayOnlyOptionsCache[offset] === index) {\n      throw new Error(\"Unexpected: Option at index \" + index + \" is not a selectable element.\");\n    }\n\n    return index - offset + 1;\n  };\n\n  return DropdownSizePosCache;\n}();\n\nexport { DropdownSizePosCache };","map":{"version":3,"sources":["components/Dropdown/utilities/DropdownSizePosCache.ts"],"names":[],"mappings":";AAAA,SAA0B,oBAA1B,QAAsD,mBAAtD;AAEA;;;;;;;;;AASG;;AACH,IAAA,oBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,oBAAA,GAAA;AAGU,SAAA,KAAA,GAAQ,CAAR;AA0DT;AAxDC;;AAEG;;;AACI,EAAA,oBAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,OAArB,EAA+C;AAC7C,QAAM,uBAAuB,GAAG,EAAhC;AACA,QAAI,IAAI,GAAG,CAAX;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAAO,CAAC,MAA5B,EAAoC,CAAC,EAArC,EAAyC;AACvC,UAAI,OAAO,CAAC,CAAD,CAAP,CAAW,QAAX,KAAwB,oBAAoB,CAAC,OAA7C,IAAwD,OAAO,CAAC,CAAD,CAAP,CAAW,QAAX,KAAwB,oBAAoB,CAAC,MAAzG,EAAiH;AAC/G,QAAA,uBAAuB,CAAC,IAAxB,CAA6B,CAA7B;AACD,OAFD,MAEO,IAAI,CAAC,OAAO,CAAC,CAAD,CAAP,CAAW,MAAhB,EAAwB;AAC7B,QAAA,IAAI;AACL;AACF;;AAED,SAAK,KAAL,GAAa,IAAb;AACA,SAAK,wBAAL,GAAgC,uBAAhC;AACA,SAAK,cAAL,GAAmB,cAAA,CAAO,OAAP,CAAnB;AACD,GAdM;;AAmBP,EAAA,MAAA,CAAA,cAAA,CAAW,oBAAA,CAAA,SAAX,EAAW,eAAX,EAAwB;AAHxB;;AAEG;SACH,YAAA;AACE,aAAO,KAAK,KAAZ;AACD,KAFuB;oBAAA;;AAAA,GAAxB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAW,oBAAA,CAAA,SAAX,EAAW,eAAX,EAAwB;AAHxB;;AAEG;SACH,YAAA;AACE,aAAO,KAAK,cAAZ;AACD,KAFuB;oBAAA;;AAAA,GAAxB;AAIA;;;;AAIG;;AACI,EAAA,oBAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,KAArB,EAA8C;AAC5C,QAAI,KAAK,KAAK,SAAd,EAAyB;AACvB,aAAO,SAAP;AACD,KAH2C,CAK5C;AACA;;;AACA,QAAI,MAAM,GAAG,CAAb;;AACA,WAAO,KAAK,GAAG,KAAK,wBAAL,CAA8B,MAA9B,CAAf,EAAsD;AACpD,MAAA,MAAM;AACP;;AAED,QAAI,KAAK,wBAAL,CAA8B,MAA9B,MAA0C,KAA9C,EAAqD;AACnD,YAAM,IAAI,KAAJ,CAAU,iCAA+B,KAA/B,GAAoC,+BAA9C,CAAN;AACD;;AAED,WAAO,KAAK,GAAG,MAAR,GAAiB,CAAxB;AACD,GAjBM;;AAkBT,SAAA,oBAAA;AAAC,CA7DD,EAAA","sourcesContent":["import { IDropdownOption, DropdownMenuItemType } from '../Dropdown.types';\n\n/**\n * A utility class to cache size and position in cache.\n *\n * Dropdown options has non-selectable display types. It is therefore not cheap to determine\n * the total number of actual selectable options as well as the position an option is in the\n * list of options - O(n) cost for each lookup.\n *\n * Given that we potentially have to make this determination on every single render pass, this\n * cache should provide a little bit of relief.\n */\nexport class DropdownSizePosCache {\n  private _cachedOptions: IDropdownOption[];\n  private _displayOnlyOptionsCache: number[];\n  private _size = 0;\n\n  /**\n   * Invalidates the cache and recalculate the size of selectable options.\n   */\n  public updateOptions(options: IDropdownOption[]) {\n    const displayOnlyOptionsCache = [];\n    let size = 0;\n    for (let i = 0; i < options.length; i++) {\n      if (options[i].itemType === DropdownMenuItemType.Divider || options[i].itemType === DropdownMenuItemType.Header) {\n        displayOnlyOptionsCache.push(i);\n      } else if (!options[i].hidden) {\n        size++;\n      }\n    }\n\n    this._size = size;\n    this._displayOnlyOptionsCache = displayOnlyOptionsCache;\n    this._cachedOptions = [...options];\n  }\n\n  /**\n   * The size of all the selectable options.\n   */\n  public get optionSetSize(): number {\n    return this._size;\n  }\n\n  /**\n   * The chached options array.\n   */\n  public get cachedOptions(): IDropdownOption[] {\n    return this._cachedOptions;\n  }\n\n  /**\n   * Returns the position of this option element relative to the full set of selectable option elements.\n   * Note: the first selectable element is position 1 in the set.\n   * @param index The raw index of the option element.\n   */\n  public positionInSet(index: number | undefined): number | undefined {\n    if (index === undefined) {\n      return undefined;\n    }\n\n    // we could possibly memoize this too but this should be good enough, most of the time (the expectation is that\n    // when you have a lot of options, the selectable options will heavily dominate over the non-selectable options.\n    let offset = 0;\n    while (index > this._displayOnlyOptionsCache[offset]) {\n      offset++;\n    }\n\n    if (this._displayOnlyOptionsCache[offset] === index) {\n      throw new Error(`Unexpected: Option at index ${index} is not a selectable element.`);\n    }\n\n    return index - offset + 1;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}