{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { getClassNames } from './DraggableZone.styles';\nimport { on } from '../../Utilities';\nvar eventMapping = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup'\n  }\n};\n\nvar DraggableZone =\n/** @class */\nfunction (_super) {\n  __extends(DraggableZone, _super);\n\n  function DraggableZone(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._currentEventType = eventMapping.mouse;\n    _this._events = [];\n\n    _this._onMouseDown = function (event) {\n      var onMouseDown = React.Children.only(_this.props.children).props.onMouseDown;\n\n      if (onMouseDown) {\n        onMouseDown(event);\n      }\n\n      _this._currentEventType = eventMapping.mouse;\n      return _this._onDragStart(event);\n    };\n\n    _this._onMouseUp = function (event) {\n      var onMouseUp = React.Children.only(_this.props.children).props.onMouseUp;\n\n      if (onMouseUp) {\n        onMouseUp(event);\n      }\n\n      _this._currentEventType = eventMapping.mouse;\n      return _this._onDragStop(event);\n    };\n\n    _this._onTouchStart = function (event) {\n      var onTouchStart = React.Children.only(_this.props.children).props.onTouchStart;\n\n      if (onTouchStart) {\n        onTouchStart(event);\n      }\n\n      _this._currentEventType = eventMapping.touch;\n      return _this._onDragStart(event);\n    };\n\n    _this._onTouchEnd = function (event) {\n      var onTouchEnd = React.Children.only(_this.props.children).props.onTouchEnd;\n\n      if (onTouchEnd) {\n        onTouchEnd(event);\n      }\n\n      _this._currentEventType = eventMapping.touch;\n\n      _this._onDragStop(event);\n    };\n\n    _this._onDragStart = function (event) {\n      // Only handle left click for dragging\n      if (typeof event.button === 'number' && event.button !== 0) {\n        return false;\n      } // If the target doesn't match the handleSelector OR\n      // if the target does match the preventDragSelector, bail out\n\n\n      if (_this.props.handleSelector && !_this._matchesSelector(event.target, _this.props.handleSelector) || _this.props.preventDragSelector && _this._matchesSelector(event.target, _this.props.preventDragSelector)) {\n        return;\n      } // Remember the touch identifier if this is a touch event so we can\n      // distinguish between individual touches in multitouch scenarios\n      // by remembering which touch point we were given\n\n\n      _this._touchId = _this._getTouchId(event);\n\n      var position = _this._getControlPosition(event);\n\n      if (position === undefined) {\n        return;\n      }\n\n      var dragData = _this._createDragDataFromPosition(position);\n\n      _this.props.onStart && _this.props.onStart(event, dragData);\n\n      _this.setState({\n        isDragging: true,\n        lastPosition: position\n      }); // hook up the appropriate mouse/touch events to the body to ensure\n      // smooth dragging\n\n\n      _this._events = [on(document.body, _this._currentEventType.move, _this._onDrag, true\n      /* use capture phase */\n      ), on(document.body, _this._currentEventType.stop, _this._onDragStop, true\n      /* use capture phase */\n      )];\n    };\n\n    _this._onDrag = function (event) {\n      // Prevent scrolling on mobile devices\n      if (event.type === 'touchmove') {\n        event.preventDefault();\n      }\n\n      var position = _this._getControlPosition(event);\n\n      if (!position) {\n        return;\n      } // create the updated drag data from the position data\n\n\n      var updatedData = _this._createUpdatedDragData(_this._createDragDataFromPosition(position));\n\n      var updatedPosition = updatedData.position;\n      _this.props.onDragChange && _this.props.onDragChange(event, updatedData);\n\n      _this.setState({\n        position: updatedPosition,\n        lastPosition: position\n      });\n    };\n\n    _this._onDragStop = function (event) {\n      if (!_this.state.isDragging) {\n        return;\n      }\n\n      var position = _this._getControlPosition(event);\n\n      if (!position) {\n        return;\n      }\n\n      var baseDragData = _this._createDragDataFromPosition(position); // Set dragging to false and reset the lastPosition\n\n\n      _this.setState({\n        isDragging: false,\n        lastPosition: undefined\n      });\n\n      _this.props.onStop && _this.props.onStop(event, baseDragData);\n\n      if (_this.props.position) {\n        _this.setState({\n          position: _this.props.position\n        });\n      } // Remove event handlers\n\n\n      _this._events.forEach(function (dispose) {\n        return dispose();\n      });\n    };\n\n    _this.state = {\n      isDragging: false,\n      position: _this.props.position || {\n        x: 0,\n        y: 0\n      },\n      lastPosition: undefined\n    };\n    return _this;\n  }\n\n  DraggableZone.prototype.componentDidUpdate = function (prevProps) {\n    if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {\n      this.setState({\n        position: this.props.position\n      });\n    }\n  };\n\n  DraggableZone.prototype.componentWillUnmount = function () {\n    this._events.forEach(function (dispose) {\n      return dispose();\n    });\n  };\n\n  DraggableZone.prototype.render = function () {\n    var child = React.Children.only(this.props.children);\n    var props = child.props;\n    var position = this.props.position;\n    var _a = this.state,\n        statePosition = _a.position,\n        isDragging = _a.isDragging;\n    var x = statePosition.x;\n    var y = statePosition.y;\n\n    if (position && !isDragging) {\n      x = position.x;\n      y = position.y;\n    }\n\n    return React.cloneElement(child, {\n      style: __assign(__assign({}, props.style), {\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\"\n      }),\n      className: getClassNames(props.className, this.state.isDragging).root,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onTouchStart: this._onTouchStart,\n      onTouchEnd: this._onTouchEnd\n    });\n  };\n  /**\n   * Get the control position based off the event that fired\n   * @param event - The event to get offsets from\n   */\n\n\n  DraggableZone.prototype._getControlPosition = function (event) {\n    var touchObj = this._getActiveTouch(event); // did we get the right touch?\n\n\n    if (this._touchId !== undefined && !touchObj) {\n      return undefined;\n    }\n\n    var eventToGetOffset = touchObj || event;\n    return {\n      x: eventToGetOffset.clientX,\n      y: eventToGetOffset.clientY\n    };\n  };\n  /**\n   * Get the active touch point that we have saved from the event's TouchList\n   * @param event - The event used to get the TouchList for the active touch point\n   */\n\n\n  DraggableZone.prototype._getActiveTouch = function (event) {\n    return event.targetTouches && this._findTouchInTouchList(event.targetTouches) || event.changedTouches && this._findTouchInTouchList(event.changedTouches);\n  };\n  /**\n   * Get the initial touch identifier associated with the given event\n   * @param event - The event that contains the TouchList\n   */\n\n\n  DraggableZone.prototype._getTouchId = function (event) {\n    var touch = event.targetTouches && event.targetTouches[0] || event.changedTouches && event.changedTouches[0];\n\n    if (touch) {\n      return touch.identifier;\n    }\n  };\n  /**\n   * Returns if an element (or any of the element's parents) match the given selector\n   */\n\n\n  DraggableZone.prototype._matchesSelector = function (element, selector) {\n    if (!element || element === document.body) {\n      return false;\n    }\n\n    var matchesSelectorFn = element.matches || element.webkitMatchesSelector || element.msMatchesSelector\n    /* for IE */\n    ;\n\n    if (!matchesSelectorFn) {\n      return false;\n    }\n\n    return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);\n  };\n  /**\n   * Attempts to find the Touch that matches the identifier  we stored in dragStart\n   * @param touchList The TouchList to look for the stored identifier from dragStart\n   */\n\n\n  DraggableZone.prototype._findTouchInTouchList = function (touchList) {\n    if (this._touchId === undefined) {\n      return;\n    }\n\n    for (var i = 0; i < touchList.length; i++) {\n      if (touchList[i].identifier === this._touchId) {\n        return touchList[i];\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * Create DragData based off of the last known position and the new position passed in\n   * @param position The new position as part of the drag\n   */\n\n\n  DraggableZone.prototype._createDragDataFromPosition = function (position) {\n    var lastPosition = this.state.lastPosition; // If we have no lastPosition, use the given position\n    // for last position\n\n    if (lastPosition === undefined) {\n      return {\n        delta: {\n          x: 0,\n          y: 0\n        },\n        lastPosition: position,\n        position: position\n      };\n    }\n\n    return {\n      delta: {\n        x: position.x - lastPosition.x,\n        y: position.y - lastPosition.y\n      },\n      lastPosition: lastPosition,\n      position: position\n    };\n  };\n  /**\n   * Creates an updated DragData based off the current position and given baseDragData\n   * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions\n   */\n\n\n  DraggableZone.prototype._createUpdatedDragData = function (baseDragData) {\n    var position = this.state.position;\n    return {\n      position: {\n        x: position.x + baseDragData.delta.x,\n        y: position.y + baseDragData.delta.y\n      },\n      delta: baseDragData.delta,\n      lastPosition: position\n    };\n  };\n\n  return DraggableZone;\n}(React.Component);\n\nexport { DraggableZone };","map":{"version":3,"sources":["utilities/DraggableZone/DraggableZone.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { IDraggableZoneProps, ICoordinates, IDragData } from './DraggableZone.types';\nimport { getClassNames } from './DraggableZone.styles';\nimport { on } from '../../Utilities';\n\nexport interface IDraggableZoneState {\n  isDragging: boolean;\n  position: ICoordinates;\n  lastPosition?: ICoordinates;\n}\n\nconst eventMapping = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    stop: 'touchend',\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    stop: 'mouseup',\n  },\n};\n\n// These are needed so that we can generalize the events\n// and so we have access to clientX and clientY in the touch events\ntype MouseTouchEvent<T> = React.MouseEvent<T> & React.TouchEvent<T> & Event;\n\nexport class DraggableZone extends React.Component<IDraggableZoneProps, IDraggableZoneState> {\n  private _touchId?: number;\n  private _currentEventType = eventMapping.mouse;\n  private _events: (() => void)[] = [];\n\n  constructor(props: IDraggableZoneProps) {\n    super(props);\n\n    this.state = {\n      isDragging: false,\n      position: this.props.position || { x: 0, y: 0 },\n      lastPosition: undefined,\n    };\n  }\n\n  public componentDidUpdate(prevProps: IDraggableZoneProps) {\n    if (this.props.position && (!prevProps.position || this.props.position !== prevProps.position)) {\n      this.setState({ position: this.props.position });\n    }\n  }\n\n  public componentWillUnmount() {\n    this._events.forEach(dispose => dispose());\n  }\n\n  public render() {\n    const child: any = React.Children.only(this.props.children);\n    const { props } = child;\n    const { position } = this.props;\n    const { position: statePosition, isDragging } = this.state;\n    let x = statePosition.x;\n    let y = statePosition.y;\n\n    if (position && !isDragging) {\n      x = position.x;\n      y = position.y;\n    }\n\n    return React.cloneElement(child, {\n      style: {\n        ...props.style,\n        transform: `translate(${x}px, ${y}px)`,\n      },\n      className: getClassNames(props.className, this.state.isDragging).root,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onTouchStart: this._onTouchStart,\n      onTouchEnd: this._onTouchEnd,\n    });\n  }\n\n  private _onMouseDown = (event: MouseTouchEvent<HTMLElement>) => {\n    const onMouseDown = (React.Children.only(this.props.children) as any).props.onMouseDown;\n    if (onMouseDown) {\n      onMouseDown(event);\n    }\n\n    this._currentEventType = eventMapping.mouse;\n    return this._onDragStart(event);\n  };\n\n  private _onMouseUp = (event: MouseTouchEvent<HTMLElement>) => {\n    const onMouseUp = (React.Children.only(this.props.children) as any).props.onMouseUp;\n    if (onMouseUp) {\n      onMouseUp(event);\n    }\n\n    this._currentEventType = eventMapping.mouse;\n    return this._onDragStop(event);\n  };\n\n  private _onTouchStart = (event: MouseTouchEvent<HTMLElement>) => {\n    const onTouchStart = (React.Children.only(this.props.children) as any).props.onTouchStart;\n    if (onTouchStart) {\n      onTouchStart(event);\n    }\n\n    this._currentEventType = eventMapping.touch;\n    return this._onDragStart(event);\n  };\n\n  private _onTouchEnd = (event: MouseTouchEvent<HTMLElement>) => {\n    const onTouchEnd = (React.Children.only(this.props.children) as any).props.onTouchEnd;\n    if (onTouchEnd) {\n      onTouchEnd(event);\n    }\n\n    this._currentEventType = eventMapping.touch;\n    this._onDragStop(event);\n  };\n\n  private _onDragStart = (event: MouseTouchEvent<HTMLElement>) => {\n    // Only handle left click for dragging\n    if (typeof event.button === 'number' && event.button !== 0) {\n      return false;\n    }\n\n    // If the target doesn't match the handleSelector OR\n    // if the target does match the preventDragSelector, bail out\n    if (\n      (this.props.handleSelector && !this._matchesSelector(event.target as HTMLElement, this.props.handleSelector)) ||\n      (this.props.preventDragSelector &&\n        this._matchesSelector(event.target as HTMLElement, this.props.preventDragSelector))\n    ) {\n      return;\n    }\n\n    // Remember the touch identifier if this is a touch event so we can\n    // distinguish between individual touches in multitouch scenarios\n    // by remembering which touch point we were given\n    this._touchId = this._getTouchId(event);\n\n    const position = this._getControlPosition(event);\n    if (position === undefined) {\n      return;\n    }\n\n    const dragData = this._createDragDataFromPosition(position);\n    this.props.onStart && this.props.onStart(event, dragData);\n\n    this.setState({\n      isDragging: true,\n      lastPosition: position,\n    });\n\n    // hook up the appropriate mouse/touch events to the body to ensure\n    // smooth dragging\n    this._events = [\n      on(document.body, this._currentEventType.move, this._onDrag, true /* use capture phase */),\n      on(document.body, this._currentEventType.stop, this._onDragStop, true /* use capture phase */),\n    ];\n  };\n\n  private _onDrag = (event: MouseTouchEvent<HTMLElement>) => {\n    // Prevent scrolling on mobile devices\n    if (event.type === 'touchmove') {\n      event.preventDefault();\n    }\n\n    const position = this._getControlPosition(event);\n    if (!position) {\n      return;\n    }\n\n    // create the updated drag data from the position data\n    const updatedData = this._createUpdatedDragData(this._createDragDataFromPosition(position));\n    const updatedPosition = updatedData.position;\n\n    this.props.onDragChange && this.props.onDragChange(event, updatedData);\n\n    this.setState({\n      position: updatedPosition,\n      lastPosition: position,\n    });\n  };\n\n  private _onDragStop = (event: MouseTouchEvent<HTMLElement>) => {\n    if (!this.state.isDragging) {\n      return;\n    }\n\n    const position = this._getControlPosition(event);\n    if (!position) {\n      return;\n    }\n\n    const baseDragData = this._createDragDataFromPosition(position);\n\n    // Set dragging to false and reset the lastPosition\n    this.setState({\n      isDragging: false,\n      lastPosition: undefined,\n    });\n\n    this.props.onStop && this.props.onStop(event, baseDragData);\n\n    if (this.props.position) {\n      this.setState({\n        position: this.props.position,\n      });\n    }\n\n    // Remove event handlers\n    this._events.forEach(dispose => dispose());\n  };\n\n  /**\n   * Get the control position based off the event that fired\n   * @param event - The event to get offsets from\n   */\n  private _getControlPosition(event: MouseTouchEvent<HTMLElement>): ICoordinates | undefined {\n    const touchObj = this._getActiveTouch(event);\n\n    // did we get the right touch?\n    if (this._touchId !== undefined && !touchObj) {\n      return undefined;\n    }\n\n    const eventToGetOffset = touchObj || event;\n    return {\n      x: eventToGetOffset.clientX,\n      y: eventToGetOffset.clientY,\n    };\n  }\n\n  /**\n   * Get the active touch point that we have saved from the event's TouchList\n   * @param event - The event used to get the TouchList for the active touch point\n   */\n  private _getActiveTouch(event: MouseTouchEvent<HTMLElement>): React.Touch | undefined {\n    return (\n      (event.targetTouches && this._findTouchInTouchList(event.targetTouches)) ||\n      (event.changedTouches && this._findTouchInTouchList(event.changedTouches))\n    );\n  }\n\n  /**\n   * Get the initial touch identifier associated with the given event\n   * @param event - The event that contains the TouchList\n   */\n  private _getTouchId(event: MouseTouchEvent<HTMLElement>): number | undefined {\n    const touch: React.Touch | undefined =\n      (event.targetTouches && event.targetTouches[0]) || (event.changedTouches && event.changedTouches[0]);\n\n    if (touch) {\n      return touch.identifier;\n    }\n  }\n\n  /**\n   * Returns if an element (or any of the element's parents) match the given selector\n   */\n  private _matchesSelector(element: HTMLElement | null, selector: string): boolean {\n    if (!element || element === document.body) {\n      return false;\n    }\n\n    const matchesSelectorFn: Function =\n        element.matches || element.webkitMatchesSelector || (element as any).msMatchesSelector /* for IE */;\n\n    if (!matchesSelectorFn) {\n      return false;\n    }\n\n    return matchesSelectorFn.call(element, selector) || this._matchesSelector(element.parentElement, selector);\n  }\n\n  /**\n   * Attempts to find the Touch that matches the identifier  we stored in dragStart\n   * @param touchList The TouchList to look for the stored identifier from dragStart\n   */\n  private _findTouchInTouchList(touchList: React.TouchList): React.Touch | undefined {\n    if (this._touchId === undefined) {\n      return;\n    }\n\n    for (let i = 0; i < touchList.length; i++) {\n      if (touchList[i].identifier === this._touchId) {\n        return touchList[i];\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Create DragData based off of the last known position and the new position passed in\n   * @param position The new position as part of the drag\n   */\n  private _createDragDataFromPosition(position: ICoordinates): IDragData {\n    const { lastPosition } = this.state;\n\n    // If we have no lastPosition, use the given position\n    // for last position\n    if (lastPosition === undefined) {\n      return {\n        delta: { x: 0, y: 0 },\n        lastPosition: position,\n        position,\n      };\n    }\n\n    return {\n      delta: {\n        x: position.x - lastPosition.x,\n        y: position.y - lastPosition.y,\n      },\n      lastPosition,\n      position,\n    };\n  }\n\n  /**\n   * Creates an updated DragData based off the current position and given baseDragData\n   * @param baseDragData The base DragData (from _createDragDataFromPosition) used to calculate the updated positions\n   */\n  private _createUpdatedDragData(baseDragData: IDragData): IDragData {\n    const { position } = this.state;\n    return {\n      position: {\n        x: position.x + baseDragData.delta.x,\n        y: position.y + baseDragData.delta.y,\n      },\n      delta: baseDragData.delta,\n      lastPosition: position,\n    };\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}