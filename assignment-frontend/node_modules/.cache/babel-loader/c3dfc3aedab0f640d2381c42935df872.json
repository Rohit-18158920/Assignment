{"ast":null,"code":"import { arraysEqual } from './array';\n/**\n * Set up a ref resolver function given internal state managed for the ref.\n * @param local Set\n */\n\nvar createResolver = function createResolver(local) {\n  return function (newValue) {\n    for (var _i = 0, _a = local.refs; _i < _a.length; _i++) {\n      var ref = _a[_i];\n\n      if (typeof ref === 'function') {\n        ref(newValue);\n      } else if (ref) {\n        // work around the immutability of the React.Ref type\n        ref.current = newValue;\n      }\n    }\n  };\n};\n/**\n * Helper to merge refs from within class components.\n */\n\n\nexport var createMergedRef = function createMergedRef(value) {\n  var local = {\n    refs: []\n  };\n  return function () {\n    var newRefs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      newRefs[_i] = arguments[_i];\n    }\n\n    if (!local.resolver || !arraysEqual(local.refs, newRefs)) {\n      local.resolver = createResolver(local);\n    }\n\n    local.refs = newRefs;\n    return local.resolver;\n  };\n};","map":{"version":3,"sources":["createMergedRef.ts"],"names":[],"mappings":"AACA,SAAS,WAAT,QAA4B,SAA5B;AAUA;;;AAGG;;AACH,IAAM,cAAc,GAAG,SAAjB,cAAiB,CAAgB,KAAhB,EAAgD;AAAK,SAAA,UAAC,QAAD,EAAgC;AAC1G,SAAkB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,CAAC,IAAxB,EAAkB,EAAA,GAAA,EAAA,CAAA,MAAlB,EAAkB,EAAA,EAAlB,EAA8B;AAAzB,UAAM,GAAG,GAAA,EAAA,CAAA,EAAA,CAAT;;AACH,UAAI,OAAO,GAAP,KAAe,UAAnB,EAA+B;AAC7B,QAAA,GAAG,CAAC,QAAD,CAAH;AACD,OAFD,MAEO,IAAI,GAAJ,EAAS;AACd;AACE,QAAA,GAA6E,CAAC,OAA9E,GAAwF,QAAxF;AACH;AACF;AARyE,GAAA;AAS3E,CATD;AAWA;;AAEG;;;AACH,OAAO,IAAM,eAAe,GAAG,SAAlB,eAAkB,CAAuB,KAAvB,EAAqC;AAClE,MAAM,KAAK,GAA8B;AACvC,IAAA,IAAI,EAAE;AADiC,GAAzC;AAIA,SAAO,YAAA;AACL,QAAA,OAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAA4D;AAA5D,MAAA,OAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AAEA,QAAI,CAAC,KAAK,CAAC,QAAP,IAAmB,CAAC,WAAW,CAAC,KAAK,CAAC,IAAP,EAAa,OAAb,CAAnC,EAA0D;AACxD,MAAA,KAAK,CAAC,QAAN,GAAiB,cAAc,CAAgB,KAAhB,CAA/B;AACD;;AAED,IAAA,KAAK,CAAC,IAAN,GAAa,OAAb;AAEA,WAAO,KAAK,CAAC,QAAb;AACD,GAVD;AAWD,CAhBM","sourcesContent":["import * as React from 'react';\nimport { arraysEqual } from './array';\n\n/**\n * Internal state type for the ref.\n */\ntype LocalState<TType, TValue> = {\n  refs: (React.Ref<TType | null | TValue> | undefined)[];\n  resolver?: (newValue: TType | TValue | null) => void;\n};\n\n/**\n * Set up a ref resolver function given internal state managed for the ref.\n * @param local Set\n */\nconst createResolver = <TType, TValue>(local: LocalState<TType, TValue>) => (newValue: TType | TValue | null) => {\n  for (const ref of local.refs) {\n    if (typeof ref === 'function') {\n      ref(newValue);\n    } else if (ref) {\n      // work around the immutability of the React.Ref type\n      ((ref as unknown) as React.MutableRefObject<TType | TValue | null | undefined>).current = newValue;\n    }\n  }\n};\n\n/**\n * Helper to merge refs from within class components.\n */\nexport const createMergedRef = <TType, TValue = null>(value?: TValue) => {\n  const local: LocalState<TType, TValue> = {\n    refs: [] as LocalState<TType, TValue>['refs'],\n  };\n\n  return (\n    ...newRefs: (React.Ref<TType | null | TValue> | undefined)[]\n  ): ((newValue: TType | TValue | null) => void) => {\n    if (!local.resolver || !arraysEqual(local.refs, newRefs)) {\n      local.resolver = createResolver<TType, TValue>(local);\n    }\n\n    local.refs = newRefs;\n\n    return local.resolver!;\n  };\n};\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}