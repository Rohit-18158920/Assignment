{"ast":null,"code":"import { elementContainsAttribute } from './dom/elementContainsAttribute';\nimport { elementContains } from './dom/elementContains';\nimport { getParent } from './dom/getParent';\nimport { getWindow } from './dom/getWindow';\nimport { getDocument } from './dom/getDocument';\nvar IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nvar IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nvar FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nvar FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';\n/**\n * Gets the first focusable element.\n *\n * @public\n */\n\nexport function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones) {\n  return getNextElement(rootElement, currentElement, true\n  /*checkNode*/\n  , false\n  /*suppressParentTraversal*/\n  , false\n  /*suppressChildTraversal*/\n  , includeElementsInFocusZones);\n}\n/**\n * Gets the last focusable element.\n *\n * @public\n */\n\nexport function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones) {\n  return getPreviousElement(rootElement, currentElement, true\n  /*checkNode*/\n  , false\n  /*suppressParentTraversal*/\n  , true\n  /*traverseChildren*/\n  , includeElementsInFocusZones);\n}\n/**\n * Gets the first tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues forward.  Typical use passes rootElement.firstChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\n\nexport function getFirstTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode) {\n  if (checkNode === void 0) {\n    checkNode = true;\n  }\n\n  return getNextElement(rootElement, currentElement, checkNode, false\n  /*suppressParentTraversal*/\n  , false\n  /*suppressChildTraversal*/\n  , includeElementsInFocusZones, false\n  /*allowFocusRoot*/\n  , true\n  /*tabbable*/\n  );\n}\n/**\n * Gets the last tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues in reverse.  Typical use passes rootElement.lastChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\n\nexport function getLastTabbable(rootElement, currentElement, includeElementsInFocusZones, checkNode) {\n  if (checkNode === void 0) {\n    checkNode = true;\n  }\n\n  return getPreviousElement(rootElement, currentElement, checkNode, false\n  /*suppressParentTraversal*/\n  , true\n  /*traverseChildren*/\n  , includeElementsInFocusZones, false\n  /*allowFocusRoot*/\n  , true\n  /*tabbable*/\n  );\n}\n/**\n * Attempts to focus the first focusable element that is a child or child's child of the rootElement.\n *\n * @public\n * @param rootElement - Element to start the search for a focusable child.\n * @returns True if focus was set, false if it was not.\n */\n\nexport function focusFirstChild(rootElement) {\n  var element = getNextElement(rootElement, rootElement, true, false, false, true);\n\n  if (element) {\n    focusAsync(element);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Traverse to find the previous element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\n\nexport function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones, allowFocusRoot, tabbable) {\n  if (!currentElement || !allowFocusRoot && currentElement === rootElement) {\n    return null;\n  }\n\n  var isCurrentElementVisible = isElementVisible(currentElement); // Check its children.\n\n  if (traverseChildren && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {\n    var childMatch = getPreviousElement(rootElement, currentElement.lastElementChild, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);\n\n    if (childMatch) {\n      if (tabbable && isElementTabbable(childMatch, true) || !tabbable) {\n        return childMatch;\n      }\n\n      var childMatchSiblingMatch = getPreviousElement(rootElement, childMatch.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);\n\n      if (childMatchSiblingMatch) {\n        return childMatchSiblingMatch;\n      }\n\n      var childMatchParent = childMatch.parentElement; // At this point if we have not found any potential matches\n      // start looking at the rest of the subtree under the currentParent.\n      // NOTE: We do not want to recurse here because doing so could\n      // cause elements to get skipped.\n\n      while (childMatchParent && childMatchParent !== currentElement) {\n        var childMatchParentMatch = getPreviousElement(rootElement, childMatchParent.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);\n\n        if (childMatchParentMatch) {\n          return childMatchParentMatch;\n        }\n\n        childMatchParent = childMatchParent.parentElement;\n      }\n    }\n  } // Check the current node, if it's not the first traversal.\n\n\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  } // Check its previous sibling.\n\n\n  var siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);\n\n  if (siblingMatch) {\n    return siblingMatch;\n  } // Check its parent.\n\n\n  if (!suppressParentTraversal) {\n    return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones, allowFocusRoot, tabbable);\n  }\n\n  return null;\n}\n/**\n * Traverse to find the next focusable element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n * @param checkNode - Include currentElement in search when true.\n */\n\nexport function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot, tabbable) {\n  if (!currentElement || currentElement === rootElement && suppressChildTraversal && !allowFocusRoot) {\n    return null;\n  }\n\n  var isCurrentElementVisible = isElementVisible(currentElement); // Check the current node, if it's not the first traversal.\n\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  } // Check its children.\n\n\n  if (!suppressChildTraversal && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {\n    var childMatch = getNextElement(rootElement, currentElement.firstElementChild, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable);\n\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n\n  if (currentElement === rootElement) {\n    return null;\n  } // Check its sibling.\n\n\n  var siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable);\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  if (!suppressParentTraversal) {\n    return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones, allowFocusRoot, tabbable);\n  }\n\n  return null;\n}\n/**\n * Determines if an element is visible.\n *\n * @public\n */\n\nexport function isElementVisible(element) {\n  // If the element is not valid, return false.\n  if (!element || !element.getAttribute) {\n    return false;\n  }\n\n  var visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE); // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n    return visibilityAttribute === 'true';\n  } // Fallback to other methods of determining actual visibility.\n\n\n  return element.offsetHeight !== 0 || element.offsetParent !== null || // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  element.isVisible === true; // used as a workaround for testing.\n}\n/**\n * Determines if an element can receive focus programmatically or via a mouse click.\n * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key,\n * meaning tabIndex != -1.\n *\n * @public\n */\n\nexport function isElementTabbable(element, checkTabIndex) {\n  // If this element is null or is disabled, it is not considered tabbable.\n  if (!element || element.disabled) {\n    return false;\n  }\n\n  var tabIndex = 0;\n  var tabIndexAttributeValue = null;\n\n  if (element && element.getAttribute) {\n    tabIndexAttributeValue = element.getAttribute('tabIndex');\n\n    if (tabIndexAttributeValue) {\n      tabIndex = parseInt(tabIndexAttributeValue, 10);\n    }\n  }\n\n  var isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\n  var isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;\n  var result = !!element && isFocusableAttribute !== 'false' && (element.tagName === 'A' || element.tagName === 'BUTTON' || element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.tagName === 'SELECT' || isFocusableAttribute === 'true' || isTabIndexSet);\n  return checkTabIndex ? tabIndex !== -1 && result : result;\n}\n/**\n * Determines if a given element is a focus zone.\n *\n * @public\n */\n\nexport function isElementFocusZone(element) {\n  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));\n}\n/**\n * Determines if a given element is a focus sub zone.\n *\n * @public\n */\n\nexport function isElementFocusSubZone(element) {\n  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');\n}\n/**\n * Determines if an element, or any of its children, contain focus.\n *\n * @public\n */\n\nexport function doesElementContainFocus(element) {\n  var document = getDocument(element);\n  var currentActiveElement = document && document.activeElement;\n\n  if (currentActiveElement && elementContains(element, currentActiveElement)) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap\n * @param element - element to start searching from\n * @param noWrapDataAttribute - the no wrap data attribute to match (either)\n * @returns true if focus should wrap, false otherwise\n */\n\nexport function shouldWrapFocus(element, noWrapDataAttribute) {\n  return elementContainsAttribute(element, noWrapDataAttribute) === 'true' ? false : true;\n}\nvar targetToFocusOnNextRepaint = undefined;\n/**\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\n * only the latest called focusAsync element will actually be focused\n * @param element - The element to focus\n */\n\nexport function focusAsync(element) {\n  if (element) {\n    // An element was already queued to be focused, so replace that one with the new element\n    if (targetToFocusOnNextRepaint) {\n      targetToFocusOnNextRepaint = element;\n      return;\n    }\n\n    targetToFocusOnNextRepaint = element;\n    var win = getWindow(element);\n\n    if (win) {\n      // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\n      win.requestAnimationFrame(function () {\n        var focusableElement = targetToFocusOnNextRepaint; // We are done focusing for this frame, so reset the queued focus element\n\n        targetToFocusOnNextRepaint = undefined;\n\n        if (focusableElement) {\n          if (focusableElement.getAttribute && focusableElement.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n            // Normally, a FocusZone would be responsible for setting the tabindex values on all its descendants.\n            // However, even this animation frame callback can pre-empt the rendering of a FocusZone's child elements,\n            // so it may be necessary to set the tabindex directly here.\n            if (!focusableElement.getAttribute('tabindex')) {\n              focusableElement.setAttribute('tabindex', '0');\n            }\n          }\n\n          focusableElement.focus();\n        }\n      });\n    }\n  }\n}\n/**\n * Finds the closest focusable element via an index path from a parent. See\n * `getElementIndexPath` for getting an index path from an element to a child.\n */\n\nexport function getFocusableByIndexPath(parent, path) {\n  var element = parent;\n\n  for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n    var index = path_1[_i];\n    var nextChild = element.children[Math.min(index, element.children.length - 1)];\n\n    if (!nextChild) {\n      break;\n    }\n\n    element = nextChild;\n  }\n\n  element = isElementTabbable(element) && isElementVisible(element) ? element : getNextElement(parent, element, true) || getPreviousElement(parent, element);\n  return element;\n}\n/**\n * Finds the element index path from a parent element to a child element.\n *\n * If you had this node structure: \"A has children [B, C] and C has child D\",\n * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.\n */\n\nexport function getElementIndexPath(fromElement, toElement) {\n  var path = [];\n\n  while (toElement && fromElement && toElement !== fromElement) {\n    var parent_1 = getParent(toElement, true);\n\n    if (parent_1 === null) {\n      return [];\n    }\n\n    path.unshift(Array.prototype.indexOf.call(parent_1.children, toElement));\n    toElement = parent_1;\n  }\n\n  return path;\n}","map":{"version":3,"sources":["focus.ts"],"names":[],"mappings":"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","sourcesContent":["import { elementContainsAttribute } from './dom/elementContainsAttribute';\nimport { elementContains } from './dom/elementContains';\nimport { getParent } from './dom/getParent';\nimport { getWindow } from './dom/getWindow';\nimport { getDocument } from './dom/getDocument';\n\nconst IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nconst IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nconst FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nconst FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';\n\n/**\n * Gets the first focusable element.\n *\n * @public\n */\nexport function getFirstFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    true /*checkNode*/,\n    false /*suppressParentTraversal*/,\n    false /*suppressChildTraversal*/,\n    includeElementsInFocusZones,\n  );\n}\n\n/**\n * Gets the last focusable element.\n *\n * @public\n */\nexport function getLastFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    true /*checkNode*/,\n    false /*suppressParentTraversal*/,\n    true /*traverseChildren*/,\n    includeElementsInFocusZones,\n  );\n}\n\n/**\n * Gets the first tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues forward.  Typical use passes rootElement.firstChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\nexport function getFirstTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode: boolean = true,\n): HTMLElement | null {\n  return getNextElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /*suppressParentTraversal*/,\n    false /*suppressChildTraversal*/,\n    includeElementsInFocusZones,\n    false /*allowFocusRoot*/,\n    true /*tabbable*/,\n  );\n}\n\n/**\n * Gets the last tabbable element. (The difference between focusable and tabbable is that tabbable elements are\n * focusable elements that also have tabIndex != -1.)\n * @param rootElement - The parent element to search beneath.\n * @param currentElement - The descendant of rootElement to start the search at.  This element is the first one checked,\n * and iteration continues in reverse.  Typical use passes rootElement.lastChild.\n * @param includeElementsInFocusZones - true if traversal should go into FocusZone descendants.\n * @param checkNode - Include currentElement in search when true. Defaults to true.\n * @public\n */\nexport function getLastTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean,\n  checkNode: boolean = true,\n): HTMLElement | null {\n  return getPreviousElement(\n    rootElement,\n    currentElement,\n    checkNode,\n    false /*suppressParentTraversal*/,\n    true /*traverseChildren*/,\n    includeElementsInFocusZones,\n    false /*allowFocusRoot*/,\n    true /*tabbable*/,\n  );\n}\n\n/**\n * Attempts to focus the first focusable element that is a child or child's child of the rootElement.\n *\n * @public\n * @param rootElement - Element to start the search for a focusable child.\n * @returns True if focus was set, false if it was not.\n */\nexport function focusFirstChild(rootElement: HTMLElement): boolean {\n  let element: HTMLElement | null = getNextElement(rootElement, rootElement, true, false, false, true);\n\n  if (element) {\n    focusAsync(element);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Traverse to find the previous element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n */\nexport function getPreviousElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  traverseChildren?: boolean,\n  includeElementsInFocusZones?: boolean,\n  allowFocusRoot?: boolean,\n  tabbable?: boolean,\n): HTMLElement | null {\n  if (!currentElement || (!allowFocusRoot && currentElement === rootElement)) {\n    return null;\n  }\n\n  let isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check its children.\n  if (\n    traverseChildren &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const childMatch = getPreviousElement(\n      rootElement,\n      currentElement.lastElementChild as HTMLElement,\n      true,\n      true,\n      true,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n    );\n\n    if (childMatch) {\n      if ((tabbable && isElementTabbable(childMatch, true)) || !tabbable) {\n        return childMatch;\n      }\n\n      const childMatchSiblingMatch = getPreviousElement(\n        rootElement,\n        childMatch.previousElementSibling as HTMLElement,\n        true,\n        true,\n        true,\n        includeElementsInFocusZones,\n        allowFocusRoot,\n        tabbable,\n      );\n      if (childMatchSiblingMatch) {\n        return childMatchSiblingMatch;\n      }\n\n      let childMatchParent = childMatch.parentElement;\n\n      // At this point if we have not found any potential matches\n      // start looking at the rest of the subtree under the currentParent.\n      // NOTE: We do not want to recurse here because doing so could\n      // cause elements to get skipped.\n      while (childMatchParent && childMatchParent !== currentElement) {\n        const childMatchParentMatch = getPreviousElement(\n          rootElement,\n          childMatchParent.previousElementSibling as HTMLElement,\n          true,\n          true,\n          true,\n          includeElementsInFocusZones,\n          allowFocusRoot,\n          tabbable,\n        );\n\n        if (childMatchParentMatch) {\n          return childMatchParentMatch;\n        }\n\n        childMatchParent = childMatchParent.parentElement;\n      }\n    }\n  }\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  }\n\n  // Check its previous sibling.\n  const siblingMatch = getPreviousElement(\n    rootElement,\n    currentElement.previousElementSibling as HTMLElement,\n    true,\n    true,\n    true,\n    includeElementsInFocusZones,\n    allowFocusRoot,\n    tabbable,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  // Check its parent.\n  if (!suppressParentTraversal) {\n    return getPreviousElement(\n      rootElement,\n      currentElement.parentElement,\n      true,\n      false,\n      false,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Traverse to find the next focusable element.\n * If tabbable is true, the element must have tabIndex != -1.\n *\n * @public\n * @param checkNode - Include currentElement in search when true.\n */\nexport function getNextElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  suppressChildTraversal?: boolean,\n  includeElementsInFocusZones?: boolean,\n  allowFocusRoot?: boolean,\n  tabbable?: boolean,\n): HTMLElement | null {\n  if (!currentElement || (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {\n    return null;\n  }\n\n  let isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {\n    return currentElement;\n  }\n\n  // Check its children.\n  if (\n    !suppressChildTraversal &&\n    isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))\n  ) {\n    const childMatch = getNextElement(\n      rootElement,\n      currentElement.firstElementChild as HTMLElement,\n      true,\n      true,\n      false,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n    );\n\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n\n  if (currentElement === rootElement) {\n    return null;\n  }\n\n  // Check its sibling.\n  const siblingMatch = getNextElement(\n    rootElement,\n    currentElement.nextElementSibling as HTMLElement,\n    true,\n    true,\n    false,\n    includeElementsInFocusZones,\n    allowFocusRoot,\n    tabbable,\n  );\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  if (!suppressParentTraversal) {\n    return getNextElement(\n      rootElement,\n      currentElement.parentElement,\n      false,\n      false,\n      true,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable,\n    );\n  }\n\n  return null;\n}\n\n/**\n * Determines if an element is visible.\n *\n * @public\n */\nexport function isElementVisible(element: HTMLElement | undefined | null): boolean {\n  // If the element is not valid, return false.\n  if (!element || !element.getAttribute) {\n    return false;\n  }\n\n  const visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);\n\n  // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n    return visibilityAttribute === 'true';\n  }\n\n  // Fallback to other methods of determining actual visibility.\n  return (\n    element.offsetHeight !== 0 ||\n    element.offsetParent !== null ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (element as any).isVisible === true\n  ); // used as a workaround for testing.\n}\n\n/**\n * Determines if an element can receive focus programmatically or via a mouse click.\n * If checkTabIndex is true, additionally checks to ensure the element can be focused with the tab key,\n * meaning tabIndex != -1.\n *\n * @public\n */\nexport function isElementTabbable(element: HTMLElement, checkTabIndex?: boolean): boolean {\n  // If this element is null or is disabled, it is not considered tabbable.\n  if (!element || (element as HTMLButtonElement).disabled) {\n    return false;\n  }\n\n  let tabIndex = 0;\n  let tabIndexAttributeValue = null;\n\n  if (element && element.getAttribute) {\n    tabIndexAttributeValue = element.getAttribute('tabIndex');\n\n    if (tabIndexAttributeValue) {\n      tabIndex = parseInt(tabIndexAttributeValue, 10);\n    }\n  }\n\n  let isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\n  let isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;\n\n  const result =\n    !!element &&\n    isFocusableAttribute !== 'false' &&\n    (element.tagName === 'A' ||\n      element.tagName === 'BUTTON' ||\n      element.tagName === 'INPUT' ||\n      element.tagName === 'TEXTAREA' ||\n      element.tagName === 'SELECT' ||\n      isFocusableAttribute === 'true' ||\n      isTabIndexSet);\n\n  return checkTabIndex ? tabIndex !== -1 && result : result;\n}\n\n/**\n * Determines if a given element is a focus zone.\n *\n * @public\n */\nexport function isElementFocusZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));\n}\n\n/**\n * Determines if a given element is a focus sub zone.\n *\n * @public\n */\nexport function isElementFocusSubZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');\n}\n\n/**\n * Determines if an element, or any of its children, contain focus.\n *\n * @public\n */\nexport function doesElementContainFocus(element: HTMLElement): boolean {\n  let document = getDocument(element);\n  let currentActiveElement: HTMLElement | undefined = document && (document.activeElement as HTMLElement);\n  if (currentActiveElement && elementContains(element, currentActiveElement)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap\n * @param element - element to start searching from\n * @param noWrapDataAttribute - the no wrap data attribute to match (either)\n * @returns true if focus should wrap, false otherwise\n */\nexport function shouldWrapFocus(\n  element: HTMLElement,\n  noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap',\n): boolean {\n  return elementContainsAttribute(element, noWrapDataAttribute) === 'true' ? false : true;\n}\n\nlet targetToFocusOnNextRepaint: HTMLElement | { focus: () => void } | null | undefined = undefined;\n\n/**\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\n * only the latest called focusAsync element will actually be focused\n * @param element - The element to focus\n */\nexport function focusAsync(element: HTMLElement | { focus: () => void } | undefined | null): void {\n  if (element) {\n    // An element was already queued to be focused, so replace that one with the new element\n    if (targetToFocusOnNextRepaint) {\n      targetToFocusOnNextRepaint = element;\n      return;\n    }\n\n    targetToFocusOnNextRepaint = element;\n\n    const win = getWindow(element as Element);\n\n    if (win) {\n      // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\n      win.requestAnimationFrame(() => {\n        const focusableElement = targetToFocusOnNextRepaint as HTMLElement | null;\n\n        // We are done focusing for this frame, so reset the queued focus element\n        targetToFocusOnNextRepaint = undefined;\n\n        if (focusableElement) {\n          if (focusableElement.getAttribute && focusableElement.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n            // Normally, a FocusZone would be responsible for setting the tabindex values on all its descendants.\n            // However, even this animation frame callback can pre-empt the rendering of a FocusZone's child elements,\n            // so it may be necessary to set the tabindex directly here.\n            if (!focusableElement.getAttribute('tabindex')) {\n              focusableElement.setAttribute('tabindex', '0');\n            }\n          }\n\n          focusableElement.focus();\n        }\n      });\n    }\n  }\n}\n\n/**\n * Finds the closest focusable element via an index path from a parent. See\n * `getElementIndexPath` for getting an index path from an element to a child.\n */\nexport function getFocusableByIndexPath(parent: HTMLElement, path: number[]): HTMLElement | undefined {\n  let element = parent;\n\n  for (const index of path) {\n    const nextChild = element.children[Math.min(index, element.children.length - 1)] as HTMLElement;\n\n    if (!nextChild) {\n      break;\n    }\n    element = nextChild;\n  }\n\n  element =\n    isElementTabbable(element) && isElementVisible(element)\n      ? element\n      : getNextElement(parent, element, true) || getPreviousElement(parent, element)!;\n\n  return element as HTMLElement;\n}\n\n/**\n * Finds the element index path from a parent element to a child element.\n *\n * If you had this node structure: \"A has children [B, C] and C has child D\",\n * the index path from A to D would be [1, 0], or `parent.chidren[1].children[0]`.\n */\nexport function getElementIndexPath(fromElement: HTMLElement, toElement: HTMLElement): number[] {\n  const path: number[] = [];\n\n  while (toElement && fromElement && toElement !== fromElement) {\n    const parent = getParent(toElement, true);\n\n    if (parent === null) {\n      return [];\n    }\n\n    path.unshift(Array.prototype.indexOf.call(parent.children, toElement));\n    toElement = parent;\n  }\n\n  return path;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}