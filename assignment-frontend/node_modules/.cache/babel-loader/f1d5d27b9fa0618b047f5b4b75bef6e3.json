{"ast":null,"code":"import { mergeCssSets, Stylesheet } from '@uifabric/merge-styles';\nimport { getRTL } from './rtl';\nimport { getWindow } from './dom';\nvar MAX_CACHE_COUNT = 50;\nvar DEFAULT_SPECIFICITY_MULTIPLIER = 5;\nvar _memoizedClassNames = 0;\nvar stylesheet = Stylesheet.getInstance();\n\nif (stylesheet && stylesheet.onReset) {\n  stylesheet.onReset(function () {\n    return _memoizedClassNames++;\n  });\n} // Note that because of the caching nature within the classNames memoization,\n// I've disabled this rule to simply be able to work with any types.\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// This represents a prop we attach to each Map to indicate the cached return value\n// associated with the graph node.\n\n\nvar retVal = '__retval__';\n/**\n * Creates a getClassNames function which calls getStyles given the props, and injects them\n * into mergeStyleSets.\n *\n * Note that the props you pass in on every render should be in the same order and\n * immutable (numbers, strings, and booleans). This will allow the results to be memoized. Violating\n * these will cause extra recalcs to occur.\n */\n\nexport function classNamesFunction(options) {\n  // We build a trie where each node is a Map. The map entry key represents an argument\n  // value, and the entry value is another node (Map). Each node has a `__retval__`\n  // property which is used to hold the cached response.\n  if (options === void 0) {\n    options = {};\n  } // To derive the response, we can simply ensure the arguments are added or already\n  // exist in the trie. At the last node, if there is a `__retval__` we return that. Otherwise\n  // we call the `getStyles` api to evaluate, cache on the property, and return that.\n\n\n  var map = new Map();\n  var styleCalcCount = 0;\n  var getClassNamesCount = 0;\n  var currentMemoizedClassNames = _memoizedClassNames;\n\n  var getClassNames = function (styleFunctionOrObject, styleProps) {\n    if (styleProps === void 0) {\n      styleProps = {};\n    }\n\n    var _a, _b; // If useStaticStyles is true, styleFunctionOrObject returns slot to classname mappings.\n    // If there is also no style overrides, we can skip merge styles completely and\n    // simply return the result from the style funcion.\n\n\n    if (options.useStaticStyles && typeof styleFunctionOrObject === 'function' && styleFunctionOrObject.__noStyleOverride__) {\n      return styleFunctionOrObject(styleProps);\n    }\n\n    getClassNamesCount++;\n    var current = map;\n    var theme = styleProps.theme;\n    var rtl = theme && theme.rtl !== undefined ? theme.rtl : getRTL();\n    var disableCaching = options.disableCaching; // On reset of our stylesheet, reset memoized cache.\n\n    if (currentMemoizedClassNames !== _memoizedClassNames) {\n      currentMemoizedClassNames = _memoizedClassNames;\n      map = new Map();\n      styleCalcCount = 0;\n    }\n\n    if (!options.disableCaching) {\n      current = _traverseMap(map, styleFunctionOrObject);\n      current = _traverseMap(current, styleProps);\n    }\n\n    if (disableCaching || !current[retVal]) {\n      if (styleFunctionOrObject === undefined) {\n        current[retVal] = {};\n      } else {\n        current[retVal] = mergeCssSets([typeof styleFunctionOrObject === 'function' ? styleFunctionOrObject(styleProps) : styleFunctionOrObject], {\n          rtl: !!rtl,\n          specificityMultiplier: options.useStaticStyles ? DEFAULT_SPECIFICITY_MULTIPLIER : undefined\n        });\n      }\n\n      if (!disableCaching) {\n        styleCalcCount++;\n      }\n    }\n\n    if (styleCalcCount > (options.cacheSize || MAX_CACHE_COUNT)) {\n      var win = getWindow();\n\n      if ((_b = (_a = win) === null || _a === void 0 ? void 0 : _a.FabricConfig) === null || _b === void 0 ? void 0 : _b.enableClassNameCacheFullWarning) {\n        // eslint-disable-next-line no-console\n        console.warn(\"Styles are being recalculated too frequently. Cache miss rate is \" + styleCalcCount + \"/\" + getClassNamesCount + \".\"); // eslint-disable-next-line no-console\n\n        console.trace();\n      }\n\n      map.clear();\n      styleCalcCount = 0; // Mutate the options passed in, that's all we can do.\n\n      options.disableCaching = true;\n    } // Note: the retVal is an attached property on the Map; not a key in the Map. We use this attached property to\n    // cache the return value for this branch of the graph.\n\n\n    return current[retVal];\n  };\n\n  return getClassNames;\n}\n\nfunction _traverseEdge(current, value) {\n  value = _normalizeValue(value);\n\n  if (!current.has(value)) {\n    current.set(value, new Map());\n  }\n\n  return current.get(value);\n}\n\nfunction _traverseMap(current, inputs) {\n  if (typeof inputs === 'function') {\n    var cachedInputsFromStyled = inputs.__cachedInputs__;\n\n    if (cachedInputsFromStyled) {\n      // The styled helper will generate the styles function and will attach the cached\n      // inputs (consisting of the default styles, customzied styles, and user provided styles.)\n      // These should be used as cache keys for deriving the memoized value.\n      for (var _i = 0, _a = inputs.__cachedInputs__; _i < _a.length; _i++) {\n        var input = _a[_i];\n        current = _traverseEdge(current, input);\n      }\n    } else {\n      current = _traverseEdge(current, inputs);\n    }\n  } else if (typeof inputs === 'object') {\n    for (var propName in inputs) {\n      if (inputs.hasOwnProperty(propName)) {\n        current = _traverseEdge(current, inputs[propName]);\n      }\n    }\n  }\n\n  return current;\n}\n\nfunction _normalizeValue(value) {\n  switch (value) {\n    case undefined:\n      return '__undefined__';\n\n    case null:\n      return '__null__';\n\n    default:\n      return value;\n  }\n}","map":{"version":3,"sources":["classNamesFunction.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  mergeCssSets,\n  IStyleSet,\n  IProcessedStyleSet,\n  Stylesheet,\n  IStyleFunctionOrObject,\n} from '@uifabric/merge-styles';\nimport { getRTL } from './rtl';\nimport { getWindow } from './dom';\nimport { StyleFunction } from './styled';\n\nconst MAX_CACHE_COUNT = 50;\nconst DEFAULT_SPECIFICITY_MULTIPLIER = 5;\n\nlet _memoizedClassNames = 0;\n\nconst stylesheet = Stylesheet.getInstance();\n\nif (stylesheet && stylesheet.onReset) {\n  stylesheet.onReset(() => _memoizedClassNames++);\n}\n\n// Note that because of the caching nature within the classNames memoization,\n// I've disabled this rule to simply be able to work with any types.\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// This represents a prop we attach to each Map to indicate the cached return value\n// associated with the graph node.\nconst retVal = '__retval__';\n\ninterface IRecursiveMemoNode extends Map<any, IRecursiveMemoNode> {\n  [retVal]?: string;\n}\n\ntype AppWindow = (Window & { FabricConfig?: { enableClassNameCacheFullWarning?: boolean } }) | undefined;\n\nexport interface IClassNamesFunctionOptions {\n  /**\n   * Disables class caching for scenarios where styleProp parts mutate frequently.\n   */\n  disableCaching?: boolean;\n\n  /**\n   * Size of the cache. It overwrites default cache size when defined.\n   */\n  cacheSize?: number;\n\n  /**\n   * Set to true if component base styles are implemented in scss instead of css-in-js.\n   */\n  useStaticStyles?: boolean;\n}\n\n/**\n * Creates a getClassNames function which calls getStyles given the props, and injects them\n * into mergeStyleSets.\n *\n * Note that the props you pass in on every render should be in the same order and\n * immutable (numbers, strings, and booleans). This will allow the results to be memoized. Violating\n * these will cause extra recalcs to occur.\n */\nexport function classNamesFunction<TStyleProps extends {}, TStyleSet extends IStyleSet<TStyleSet>>(\n  options: IClassNamesFunctionOptions = {},\n): (\n  getStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined,\n  styleProps?: TStyleProps,\n) => IProcessedStyleSet<TStyleSet> {\n  // We build a trie where each node is a Map. The map entry key represents an argument\n  // value, and the entry value is another node (Map). Each node has a `__retval__`\n  // property which is used to hold the cached response.\n\n  // To derive the response, we can simply ensure the arguments are added or already\n  // exist in the trie. At the last node, if there is a `__retval__` we return that. Otherwise\n  // we call the `getStyles` api to evaluate, cache on the property, and return that.\n  let map: IRecursiveMemoNode = new Map();\n  let styleCalcCount = 0;\n  let getClassNamesCount = 0;\n  let currentMemoizedClassNames = _memoizedClassNames;\n\n  const getClassNames = (\n    styleFunctionOrObject: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined,\n    styleProps: TStyleProps = {} as TStyleProps,\n  ): IProcessedStyleSet<TStyleSet> => {\n    // If useStaticStyles is true, styleFunctionOrObject returns slot to classname mappings.\n    // If there is also no style overrides, we can skip merge styles completely and\n    // simply return the result from the style funcion.\n    if (\n      options.useStaticStyles &&\n      typeof styleFunctionOrObject === 'function' &&\n      (styleFunctionOrObject as StyleFunction<TStyleProps, TStyleSet>).__noStyleOverride__\n    ) {\n      return styleFunctionOrObject(styleProps) as IProcessedStyleSet<TStyleSet>;\n    }\n\n    getClassNamesCount++;\n    let current: Map<any, any> = map;\n    const { theme } = styleProps as any;\n    const rtl = theme && theme.rtl !== undefined ? theme.rtl : getRTL();\n\n    const disableCaching = options.disableCaching;\n\n    // On reset of our stylesheet, reset memoized cache.\n    if (currentMemoizedClassNames !== _memoizedClassNames) {\n      currentMemoizedClassNames = _memoizedClassNames;\n      map = new Map();\n      styleCalcCount = 0;\n    }\n\n    if (!options.disableCaching) {\n      current = _traverseMap(map, styleFunctionOrObject as any);\n      current = _traverseMap(current, styleProps);\n    }\n\n    if (disableCaching || !(current as any)[retVal]) {\n      if (styleFunctionOrObject === undefined) {\n        (current as any)[retVal] = {} as IProcessedStyleSet<TStyleSet>;\n      } else {\n        (current as any)[retVal] = mergeCssSets(\n          [\n            (typeof styleFunctionOrObject === 'function'\n              ? styleFunctionOrObject(styleProps)\n              : styleFunctionOrObject) as IStyleSet<TStyleSet>,\n          ],\n          { rtl: !!rtl, specificityMultiplier: options.useStaticStyles ? DEFAULT_SPECIFICITY_MULTIPLIER : undefined },\n        );\n      }\n\n      if (!disableCaching) {\n        styleCalcCount++;\n      }\n    }\n\n    if (styleCalcCount > (options.cacheSize || MAX_CACHE_COUNT)) {\n      const win = getWindow() as AppWindow;\n      if (win?.FabricConfig?.enableClassNameCacheFullWarning) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Styles are being recalculated too frequently. Cache miss rate is ${styleCalcCount}/${getClassNamesCount}.`,\n        );\n        // eslint-disable-next-line no-console\n        console.trace();\n      }\n\n      map.clear();\n      styleCalcCount = 0;\n\n      // Mutate the options passed in, that's all we can do.\n      options.disableCaching = true;\n    }\n\n    // Note: the retVal is an attached property on the Map; not a key in the Map. We use this attached property to\n    // cache the return value for this branch of the graph.\n    return (current as any)[retVal];\n  };\n\n  return getClassNames;\n}\n\nfunction _traverseEdge(current: Map<any, any>, value: any): Map<any, any> {\n  value = _normalizeValue(value);\n\n  if (!current.has(value)) {\n    current.set(value, new Map<any, any>());\n  }\n\n  return current.get(value);\n}\n\nfunction _traverseMap(current: Map<any, any>, inputs: any[] | Object): Map<any, any> {\n  if (typeof inputs === 'function') {\n    const cachedInputsFromStyled = (inputs as StyleFunction<any, any>).__cachedInputs__;\n    if (cachedInputsFromStyled) {\n      // The styled helper will generate the styles function and will attach the cached\n      // inputs (consisting of the default styles, customzied styles, and user provided styles.)\n      // These should be used as cache keys for deriving the memoized value.\n      for (const input of (inputs as any).__cachedInputs__) {\n        current = _traverseEdge(current, input);\n      }\n    } else {\n      current = _traverseEdge(current, inputs);\n    }\n  } else if (typeof inputs === 'object') {\n    for (const propName in inputs) {\n      if (inputs.hasOwnProperty(propName)) {\n        current = _traverseEdge(current, (inputs as any)[propName]);\n      }\n    }\n  }\n\n  return current;\n}\n\nfunction _normalizeValue(value: any): string {\n  switch (value) {\n    case undefined:\n      return '__undefined__';\n    case null:\n      return '__null__';\n    default:\n      return value;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}