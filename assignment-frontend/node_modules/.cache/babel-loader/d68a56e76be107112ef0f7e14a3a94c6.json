{"ast":null,"code":"var _a;\n\nvar LEFT = 'left';\nvar RIGHT = 'right';\nvar NO_FLIP = '@noflip';\nvar NAME_REPLACEMENTS = (_a = {}, _a[LEFT] = RIGHT, _a[RIGHT] = LEFT, _a);\nvar VALUE_REPLACEMENTS = {\n  'w-resize': 'e-resize',\n  'sw-resize': 'se-resize',\n  'nw-resize': 'ne-resize'\n};\n/**\n * RTLifies the rulePair in the array at the current index. This mutates the array for performance\n * reasons.\n */\n\nexport function rtlifyRules(options, rulePairs, index) {\n  if (options.rtl) {\n    var name_1 = rulePairs[index];\n\n    if (!name_1) {\n      return;\n    }\n\n    var value = rulePairs[index + 1];\n\n    if (typeof value === 'string' && value.indexOf(NO_FLIP) >= 0) {\n      rulePairs[index + 1] = value.replace(/\\s*(?:\\/\\*\\s*)?\\@noflip\\b(?:\\s*\\*\\/)?\\s*?/g, '');\n    } else if (name_1.indexOf(LEFT) >= 0) {\n      rulePairs[index] = name_1.replace(LEFT, RIGHT);\n    } else if (name_1.indexOf(RIGHT) >= 0) {\n      rulePairs[index] = name_1.replace(RIGHT, LEFT);\n    } else if (String(value).indexOf(LEFT) >= 0) {\n      rulePairs[index + 1] = value.replace(LEFT, RIGHT);\n    } else if (String(value).indexOf(RIGHT) >= 0) {\n      rulePairs[index + 1] = value.replace(RIGHT, LEFT);\n    } else if (NAME_REPLACEMENTS[name_1]) {\n      rulePairs[index] = NAME_REPLACEMENTS[name_1];\n    } else if (VALUE_REPLACEMENTS[value]) {\n      rulePairs[index + 1] = VALUE_REPLACEMENTS[value];\n    } else {\n      switch (name_1) {\n        case 'margin':\n        case 'padding':\n          rulePairs[index + 1] = flipQuad(value);\n          break;\n\n        case 'box-shadow':\n          rulePairs[index + 1] = negateNum(value, 0);\n          break;\n      }\n    }\n  }\n}\n/**\n * Given a string value in a space delimited format (e.g. \"1 2 3 4\"), negates a particular value.\n */\n\nfunction negateNum(value, partIndex) {\n  var parts = value.split(' ');\n  var numberVal = parseInt(parts[partIndex], 10);\n  parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));\n  return parts.join(' ');\n}\n/**\n * Given a string quad, flips the left and right values.\n */\n\n\nfunction flipQuad(value) {\n  if (typeof value === 'string') {\n    var parts = value.split(' ');\n\n    if (parts.length === 4) {\n      return parts[0] + \" \" + parts[3] + \" \" + parts[2] + \" \" + parts[1];\n    }\n  }\n\n  return value;\n}","map":{"version":3,"sources":["transforms/rtlifyRules.ts"],"names":[],"mappings":"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","sourcesContent":["import { IStyleOptions } from '../IStyleOptions';\n\nconst LEFT = 'left';\nconst RIGHT = 'right';\nconst NO_FLIP = '@noflip';\nconst NAME_REPLACEMENTS: { [key: string]: string } = {\n  [LEFT]: RIGHT,\n  [RIGHT]: LEFT,\n};\nconst VALUE_REPLACEMENTS: { [key: string]: string } = {\n  'w-resize': 'e-resize',\n  'sw-resize': 'se-resize',\n  'nw-resize': 'ne-resize',\n};\n\n/**\n * RTLifies the rulePair in the array at the current index. This mutates the array for performance\n * reasons.\n */\nexport function rtlifyRules(options: IStyleOptions, rulePairs: (string | number)[], index: number): void {\n  if (options.rtl) {\n    const name = rulePairs[index] as string;\n\n    if (!name) {\n      return;\n    }\n\n    const value = rulePairs[index + 1] as string;\n\n    if (typeof value === 'string' && value.indexOf(NO_FLIP) >= 0) {\n      rulePairs[index + 1] = value.replace(/\\s*(?:\\/\\*\\s*)?\\@noflip\\b(?:\\s*\\*\\/)?\\s*?/g, '');\n    } else if (name.indexOf(LEFT) >= 0) {\n      rulePairs[index] = name.replace(LEFT, RIGHT);\n    } else if (name.indexOf(RIGHT) >= 0) {\n      rulePairs[index] = name.replace(RIGHT, LEFT);\n    } else if (String(value).indexOf(LEFT) >= 0) {\n      rulePairs[index + 1] = value.replace(LEFT, RIGHT);\n    } else if (String(value).indexOf(RIGHT) >= 0) {\n      rulePairs[index + 1] = value.replace(RIGHT, LEFT);\n    } else if (NAME_REPLACEMENTS[name]) {\n      rulePairs[index] = NAME_REPLACEMENTS[name];\n    } else if (VALUE_REPLACEMENTS[value]) {\n      rulePairs[index + 1] = VALUE_REPLACEMENTS[value];\n    } else {\n      switch (name) {\n        case 'margin':\n        case 'padding':\n          rulePairs[index + 1] = flipQuad(value);\n          break;\n        case 'box-shadow':\n          rulePairs[index + 1] = negateNum(value, 0);\n          break;\n      }\n    }\n  }\n}\n\n/**\n * Given a string value in a space delimited format (e.g. \"1 2 3 4\"), negates a particular value.\n */\nfunction negateNum(value: string, partIndex: number): string {\n  const parts = value.split(' ');\n  const numberVal = parseInt(parts[partIndex], 10);\n\n  parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));\n\n  return parts.join(' ');\n}\n\n/**\n * Given a string quad, flips the left and right values.\n */\nfunction flipQuad(value: string): string {\n  if (typeof value === 'string') {\n    const parts = value.split(' ');\n\n    if (parts.length === 4) {\n      return `${parts[0]} ${parts[3]} ${parts[2]} ${parts[1]}`;\n    }\n  }\n\n  return value;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}