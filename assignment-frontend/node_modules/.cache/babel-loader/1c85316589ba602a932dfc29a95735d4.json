{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { modalize } from '@uifabric/utilities';\nimport { elementContains, getNativeProps, divProperties, getFirstTabbable, getLastTabbable, getNextElement, getDocument, focusAsync, initializeComponentRef, on } from '../../Utilities';\n\nvar FocusTrapZone =\n/** @class */\nfunction (_super) {\n  __extends(FocusTrapZone, _super);\n\n  function FocusTrapZone(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    _this._firstBumper = React.createRef();\n    _this._lastBumper = React.createRef();\n    _this._hasFocus = false;\n\n    _this._onRootFocus = function (ev) {\n      if (_this.props.onFocus) {\n        _this.props.onFocus(ev);\n      }\n\n      _this._hasFocus = true;\n    };\n\n    _this._onRootBlur = function (ev) {\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n\n      var relatedTarget = ev.relatedTarget;\n\n      if (ev.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = _this._getDocument().activeElement;\n      }\n\n      if (!elementContains(_this._root.current, relatedTarget)) {\n        _this._hasFocus = false;\n      }\n    };\n\n    _this._onFirstBumperFocus = function () {\n      _this._onBumperFocus(true);\n    };\n\n    _this._onLastBumperFocus = function () {\n      _this._onBumperFocus(false);\n    };\n\n    _this._onBumperFocus = function (isFirstBumper) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      var currentBumper = isFirstBumper === _this._hasFocus ? _this._lastBumper.current : _this._firstBumper.current;\n\n      if (_this._root.current) {\n        var nextFocusable = isFirstBumper === _this._hasFocus ? getLastTabbable(_this._root.current, currentBumper, true, false) : getFirstTabbable(_this._root.current, currentBumper, true, false);\n\n        if (nextFocusable) {\n          if (_this._isBumper(nextFocusable)) {\n            // This can happen when FTZ contains no tabbable elements.\n            // focus will take care of finding a focusable element in FTZ.\n            _this.focus();\n          } else {\n            nextFocusable.focus();\n          }\n        }\n      }\n    };\n\n    _this._onFocusCapture = function (ev) {\n      if (_this.props.onFocusCapture) {\n        _this.props.onFocusCapture(ev);\n      }\n\n      if (ev.target !== ev.currentTarget && !_this._isBumper(ev.target)) {\n        // every time focus changes within the trap zone, remember the focused element so that\n        // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n        _this._previouslyFocusedElementInTrapZone = ev.target;\n      }\n    };\n\n    _this._forceFocusInTrap = function (ev) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (FocusTrapZone._focusStack.length && _this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n        var focusedElement = _this._getDocument().activeElement;\n\n        if (!elementContains(_this._root.current, focusedElement)) {\n          _this.focus();\n\n          _this._hasFocus = true; // set focus here since we stop event propagation\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    _this._forceClickInTrap = function (ev) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (FocusTrapZone._focusStack.length && _this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n        var clickedElement = ev.target;\n\n        if (clickedElement && !elementContains(_this._root.current, clickedElement)) {\n          _this.focus();\n\n          _this._hasFocus = true; // set focus here since we stop event propagation\n\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n      }\n    };\n\n    initializeComponentRef(_this);\n    return _this;\n  }\n\n  FocusTrapZone.prototype.componentDidMount = function () {\n    this._bringFocusIntoZone();\n\n    this._updateEventHandlers(this.props);\n\n    if (!this.props.disabled && this._root.current && this.props.enableAriaHiddenSiblings) {\n      this._unmodalize = modalize(this._root.current);\n    }\n  };\n\n  FocusTrapZone.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    var elementToFocusOnDismiss = nextProps.elementToFocusOnDismiss;\n\n    if (elementToFocusOnDismiss && this._previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n\n    this._updateEventHandlers(nextProps);\n  };\n\n  FocusTrapZone.prototype.componentDidUpdate = function (prevProps) {\n    var prevForceFocusInsideTrap = prevProps.forceFocusInsideTrap !== undefined ? prevProps.forceFocusInsideTrap : true;\n    var newForceFocusInsideTrap = this.props.forceFocusInsideTrap !== undefined ? this.props.forceFocusInsideTrap : true;\n    var prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;\n    var newDisabled = this.props.disabled !== undefined ? this.props.disabled : false;\n\n    if (!prevForceFocusInsideTrap && newForceFocusInsideTrap || prevDisabled && !newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n      // Emulate what happens when a FocusTrapZone gets mounted.\n      this._bringFocusIntoZone();\n\n      if (!this._unmodalize && this._root.current && this.props.enableAriaHiddenSiblings) {\n        this._unmodalize = modalize(this._root.current);\n      }\n    } else if (prevForceFocusInsideTrap && !newForceFocusInsideTrap || !prevDisabled && newDisabled) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      // Emulate what happens when a FocusTrapZone gets unmounted.\n      this._returnFocusToInitiator();\n\n      if (this._unmodalize) {\n        this._unmodalize();\n      }\n    }\n  };\n\n  FocusTrapZone.prototype.componentWillUnmount = function () {\n    // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n    if (!this.props.disabled || this.props.forceFocusInsideTrap || !elementContains(this._root.current, this._getDocument().activeElement)) {\n      this._returnFocusToInitiator();\n    } // Dispose of event handlers so their closures can be garbage-collected\n\n\n    if (this._disposeClickHandler) {\n      this._disposeClickHandler();\n\n      this._disposeClickHandler = undefined;\n    }\n\n    if (this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (this._unmodalize) {\n      this._unmodalize();\n    } // Dispose of element references so the DOM Nodes can be garbage-collected\n\n\n    delete this._previouslyFocusedElementInTrapZone;\n    delete this._previouslyFocusedElementOutsideTrapZone;\n  };\n\n  FocusTrapZone.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        _b = _a.disabled,\n        disabled = _b === void 0 ? false : _b,\n        ariaLabelledBy = _a.ariaLabelledBy;\n    var divProps = getNativeProps(this.props, divProperties);\n    var bumperProps = {\n      'aria-hidden': true,\n      style: {\n        pointerEvents: 'none',\n        position: 'fixed'\n      },\n      tabIndex: disabled ? -1 : 0,\n      'data-is-visible': true\n    };\n    return React.createElement(\"div\", __assign({}, divProps, {\n      className: className,\n      ref: this._root,\n      \"aria-labelledby\": ariaLabelledBy,\n      onFocusCapture: this._onFocusCapture,\n      onFocus: this._onRootFocus,\n      onBlur: this._onRootBlur\n    }), React.createElement(\"div\", __assign({}, bumperProps, {\n      ref: this._firstBumper,\n      onFocus: this._onFirstBumperFocus\n    })), this.props.children, React.createElement(\"div\", __assign({}, bumperProps, {\n      ref: this._lastBumper,\n      onFocus: this._onLastBumperFocus\n    })));\n  };\n\n  FocusTrapZone.prototype.focus = function () {\n    // eslint-disable-next-line deprecation/deprecation\n    var _a = this.props,\n        focusPreviouslyFocusedInnerElement = _a.focusPreviouslyFocusedInnerElement,\n        firstFocusableSelector = _a.firstFocusableSelector,\n        firstFocusableTarget = _a.firstFocusableTarget;\n\n    if (focusPreviouslyFocusedInnerElement && this._previouslyFocusedElementInTrapZone && elementContains(this._root.current, this._previouslyFocusedElementInTrapZone)) {\n      // focus on the last item that had focus in the zone before we left the zone\n      this._focusAsync(this._previouslyFocusedElementInTrapZone);\n\n      return;\n    }\n\n    var focusSelector = typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector && firstFocusableSelector();\n    var _firstFocusableChild = null;\n\n    if (this._root.current) {\n      if (typeof firstFocusableTarget === 'string') {\n        _firstFocusableChild = this._root.current.querySelector(firstFocusableTarget);\n      } else if (firstFocusableTarget) {\n        _firstFocusableChild = firstFocusableTarget(this._root.current);\n      } else if (focusSelector) {\n        _firstFocusableChild = this._root.current.querySelector('.' + focusSelector);\n      } // Fall back to first element if query selector did not match any elements.\n\n\n      if (!_firstFocusableChild) {\n        _firstFocusableChild = getNextElement(this._root.current, this._root.current.firstChild, false, false, false, true);\n      }\n    }\n\n    if (_firstFocusableChild) {\n      this._focusAsync(_firstFocusableChild);\n    }\n  };\n\n  FocusTrapZone.prototype._focusAsync = function (element) {\n    if (!this._isBumper(element)) {\n      focusAsync(element);\n    }\n  };\n\n  FocusTrapZone.prototype._bringFocusIntoZone = function () {\n    var _a = this.props,\n        elementToFocusOnDismiss = _a.elementToFocusOnDismiss,\n        _b = _a.disabled,\n        disabled = _b === void 0 ? false : _b,\n        _c = _a.disableFirstFocus,\n        disableFirstFocus = _c === void 0 ? false : _c;\n\n    if (disabled) {\n      return;\n    }\n\n    FocusTrapZone._focusStack.push(this);\n\n    this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss ? elementToFocusOnDismiss : this._getDocument().activeElement;\n\n    if (!disableFirstFocus && !elementContains(this._root.current, this._previouslyFocusedElementOutsideTrapZone)) {\n      this.focus();\n    }\n  };\n\n  FocusTrapZone.prototype._returnFocusToInitiator = function () {\n    var _this = this;\n\n    var ignoreExternalFocusing = this.props.ignoreExternalFocusing;\n    FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter(function (value) {\n      return _this !== value;\n    });\n\n    var doc = this._getDocument();\n\n    var activeElement = doc.activeElement;\n\n    if (!ignoreExternalFocusing && this._previouslyFocusedElementOutsideTrapZone && typeof this._previouslyFocusedElementOutsideTrapZone.focus === 'function' && (elementContains(this._root.current, activeElement) || activeElement === doc.body)) {\n      this._focusAsync(this._previouslyFocusedElementOutsideTrapZone);\n    }\n  };\n\n  FocusTrapZone.prototype._updateEventHandlers = function (newProps) {\n    var _a = newProps.isClickableOutsideFocusTrap,\n        isClickableOutsideFocusTrap = _a === void 0 ? false : _a,\n        _b = newProps.forceFocusInsideTrap,\n        forceFocusInsideTrap = _b === void 0 ? true : _b;\n\n    if (forceFocusInsideTrap && !this._disposeFocusHandler) {\n      this._disposeFocusHandler = on(window, 'focus', this._forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !this._disposeClickHandler) {\n      this._disposeClickHandler = on(window, 'click', this._forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && this._disposeClickHandler) {\n      this._disposeClickHandler();\n\n      this._disposeClickHandler = undefined;\n    }\n  };\n\n  FocusTrapZone.prototype._isBumper = function (element) {\n    return element === this._firstBumper.current || element === this._lastBumper.current;\n  };\n\n  FocusTrapZone.prototype._getDocument = function () {\n    return getDocument(this._root.current);\n  };\n\n  FocusTrapZone._focusStack = [];\n  return FocusTrapZone;\n}(React.Component);\n\nexport { FocusTrapZone };","map":{"version":3,"sources":["components/FocusTrapZone/FocusTrapZone.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { modalize } from '@uifabric/utilities';\nimport {\n  elementContains,\n  getNativeProps,\n  divProperties,\n  getFirstTabbable,\n  getLastTabbable,\n  getNextElement,\n  getDocument,\n  focusAsync,\n  initializeComponentRef,\n  on,\n} from '../../Utilities';\nimport { IFocusTrapZone, IFocusTrapZoneProps } from './FocusTrapZone.types';\n\nexport class FocusTrapZone extends React.Component<IFocusTrapZoneProps, {}> implements IFocusTrapZone {\n  private static _focusStack: FocusTrapZone[] = [];\n\n  private _root = React.createRef<HTMLDivElement>();\n  private _firstBumper = React.createRef<HTMLDivElement>();\n  private _lastBumper = React.createRef<HTMLDivElement>();\n  private _hasFocus: boolean = false;\n  private _unmodalize?: () => void;\n\n  private _previouslyFocusedElementOutsideTrapZone: HTMLElement;\n  private _previouslyFocusedElementInTrapZone?: HTMLElement;\n  private _disposeFocusHandler: (() => void) | undefined;\n  private _disposeClickHandler: (() => void) | undefined;\n\n  public constructor(props: IFocusTrapZoneProps) {\n    super(props);\n    initializeComponentRef(this);\n  }\n\n  public componentDidMount(): void {\n    this._bringFocusIntoZone();\n    this._updateEventHandlers(this.props);\n\n    if (!this.props.disabled && this._root.current && this.props.enableAriaHiddenSiblings) {\n      this._unmodalize = modalize(this._root.current);\n    }\n  }\n\n  public UNSAFE_componentWillReceiveProps(nextProps: IFocusTrapZoneProps): void {\n    const { elementToFocusOnDismiss } = nextProps;\n    if (elementToFocusOnDismiss && this._previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n\n    this._updateEventHandlers(nextProps);\n  }\n\n  public componentDidUpdate(prevProps: IFocusTrapZoneProps) {\n    const prevForceFocusInsideTrap =\n      prevProps.forceFocusInsideTrap !== undefined ? prevProps.forceFocusInsideTrap : true;\n    const newForceFocusInsideTrap =\n      this.props.forceFocusInsideTrap !== undefined ? this.props.forceFocusInsideTrap : true;\n    const prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;\n    const newDisabled = this.props.disabled !== undefined ? this.props.disabled : false;\n\n    if ((!prevForceFocusInsideTrap && newForceFocusInsideTrap) || (prevDisabled && !newDisabled)) {\n      // Transition from forceFocusInsideTrap / FTZ disabled to enabled.\n      // Emulate what happens when a FocusTrapZone gets mounted.\n      this._bringFocusIntoZone();\n      if (!this._unmodalize && this._root.current && this.props.enableAriaHiddenSiblings) {\n        this._unmodalize = modalize(this._root.current);\n      }\n    } else if ((prevForceFocusInsideTrap && !newForceFocusInsideTrap) || (!prevDisabled && newDisabled)) {\n      // Transition from forceFocusInsideTrap / FTZ enabled to disabled.\n      // Emulate what happens when a FocusTrapZone gets unmounted.\n      this._returnFocusToInitiator();\n      if (this._unmodalize) {\n        this._unmodalize();\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    // don't handle return focus unless forceFocusInsideTrap is true or focus is still within FocusTrapZone\n    if (\n      !this.props.disabled ||\n      this.props.forceFocusInsideTrap ||\n      !elementContains(this._root.current, this._getDocument().activeElement as HTMLElement)\n    ) {\n      this._returnFocusToInitiator();\n    }\n\n    // Dispose of event handlers so their closures can be garbage-collected\n    if (this._disposeClickHandler) {\n      this._disposeClickHandler();\n      this._disposeClickHandler = undefined;\n    }\n\n    if (this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (this._unmodalize) {\n      this._unmodalize();\n    }\n\n    // Dispose of element references so the DOM Nodes can be garbage-collected\n    delete this._previouslyFocusedElementInTrapZone;\n    delete this._previouslyFocusedElementOutsideTrapZone;\n  }\n\n  public render(): JSX.Element {\n    const { className, disabled = false, ariaLabelledBy } = this.props;\n    const divProps = getNativeProps<React.HTMLAttributes<HTMLDivElement>>(this.props, divProperties);\n\n    const bumperProps = {\n      'aria-hidden': true,\n      style: {\n        pointerEvents: 'none',\n        position: 'fixed', // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them\n      },\n      tabIndex: disabled ? -1 : 0, // make bumpers tabbable only when enabled\n      'data-is-visible': true,\n    } as React.HTMLAttributes<HTMLDivElement>;\n\n    return (\n      <div\n        {...divProps}\n        className={className}\n        ref={this._root}\n        aria-labelledby={ariaLabelledBy}\n        onFocusCapture={this._onFocusCapture}\n        onFocus={this._onRootFocus}\n        onBlur={this._onRootBlur}\n      >\n        <div {...bumperProps} ref={this._firstBumper} onFocus={this._onFirstBumperFocus} />\n        {this.props.children}\n        <div {...bumperProps} ref={this._lastBumper} onFocus={this._onLastBumperFocus} />\n      </div>\n    );\n  }\n\n  public focus() {\n    // eslint-disable-next-line deprecation/deprecation\n    const { focusPreviouslyFocusedInnerElement, firstFocusableSelector, firstFocusableTarget } = this.props;\n\n    if (\n      focusPreviouslyFocusedInnerElement &&\n      this._previouslyFocusedElementInTrapZone &&\n      elementContains(this._root.current, this._previouslyFocusedElementInTrapZone)\n    ) {\n      // focus on the last item that had focus in the zone before we left the zone\n      this._focusAsync(this._previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    const focusSelector =\n      typeof firstFocusableSelector === 'string'\n        ? firstFocusableSelector\n        : firstFocusableSelector && firstFocusableSelector();\n\n    let _firstFocusableChild: HTMLElement | null = null;\n\n    if (this._root.current) {\n      if (typeof firstFocusableTarget === 'string') {\n        _firstFocusableChild = this._root.current.querySelector(firstFocusableTarget);\n      } else if (firstFocusableTarget) {\n        _firstFocusableChild = firstFocusableTarget(this._root.current);\n      } else if (focusSelector) {\n        _firstFocusableChild = this._root.current.querySelector('.' + focusSelector);\n      }\n\n      // Fall back to first element if query selector did not match any elements.\n      if (!_firstFocusableChild) {\n        _firstFocusableChild = getNextElement(\n          this._root.current,\n          this._root.current.firstChild as HTMLElement,\n          false,\n          false,\n          false,\n          true,\n        );\n      }\n    }\n    if (_firstFocusableChild) {\n      this._focusAsync(_firstFocusableChild);\n    }\n  }\n\n  private _focusAsync(element: HTMLElement): void {\n    if (!this._isBumper(element)) {\n      focusAsync(element);\n    }\n  }\n\n  private _onRootFocus = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onFocus) {\n      this.props.onFocus(ev);\n    }\n\n    this._hasFocus = true;\n  };\n\n  private _onRootBlur = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onBlur) {\n      this.props.onBlur(ev);\n    }\n\n    let relatedTarget = ev.relatedTarget;\n    if (ev.relatedTarget === null) {\n      // In IE11, due to lack of support, event.relatedTarget is always\n      // null making every onBlur call to be \"outside\" of the ComboBox\n      // even when it's not. Using document.activeElement is another way\n      // for us to be able to get what the relatedTarget without relying\n      // on the event\n      relatedTarget = this._getDocument().activeElement as Element;\n    }\n\n    if (!elementContains(this._root.current, relatedTarget as HTMLElement)) {\n      this._hasFocus = false;\n    }\n  };\n\n  private _onFirstBumperFocus = () => {\n    this._onBumperFocus(true);\n  };\n\n  private _onLastBumperFocus = () => {\n    this._onBumperFocus(false);\n  };\n\n  private _onBumperFocus = (isFirstBumper: boolean) => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    const currentBumper = (isFirstBumper === this._hasFocus\n      ? this._lastBumper.current\n      : this._firstBumper.current) as HTMLElement;\n\n    if (this._root.current) {\n      const nextFocusable =\n        isFirstBumper === this._hasFocus\n          ? getLastTabbable(this._root.current, currentBumper, true, false)\n          : getFirstTabbable(this._root.current, currentBumper, true, false);\n\n      if (nextFocusable) {\n        if (this._isBumper(nextFocusable)) {\n          // This can happen when FTZ contains no tabbable elements.\n          // focus will take care of finding a focusable element in FTZ.\n          this.focus();\n        } else {\n          nextFocusable.focus();\n        }\n      }\n    }\n  };\n\n  private _bringFocusIntoZone(): void {\n    const { elementToFocusOnDismiss, disabled = false, disableFirstFocus = false } = this.props;\n\n    if (disabled) {\n      return;\n    }\n\n    FocusTrapZone._focusStack.push(this);\n\n    this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss\n      ? elementToFocusOnDismiss\n      : (this._getDocument().activeElement as HTMLElement);\n    if (!disableFirstFocus && !elementContains(this._root.current, this._previouslyFocusedElementOutsideTrapZone)) {\n      this.focus();\n    }\n  }\n\n  private _returnFocusToInitiator(): void {\n    const { ignoreExternalFocusing } = this.props;\n\n    FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter((value: FocusTrapZone) => {\n      return this !== value;\n    });\n\n    const doc = this._getDocument();\n    const activeElement = doc.activeElement as HTMLElement;\n    if (\n      !ignoreExternalFocusing &&\n      this._previouslyFocusedElementOutsideTrapZone &&\n      typeof this._previouslyFocusedElementOutsideTrapZone.focus === 'function' &&\n      (elementContains(this._root.current, activeElement) || activeElement === doc.body)\n    ) {\n      this._focusAsync(this._previouslyFocusedElementOutsideTrapZone);\n    }\n  }\n\n  private _updateEventHandlers(newProps: IFocusTrapZoneProps): void {\n    const { isClickableOutsideFocusTrap = false, forceFocusInsideTrap = true } = newProps;\n\n    if (forceFocusInsideTrap && !this._disposeFocusHandler) {\n      this._disposeFocusHandler = on(window, 'focus', this._forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && this._disposeFocusHandler) {\n      this._disposeFocusHandler();\n      this._disposeFocusHandler = undefined;\n    }\n\n    if (!isClickableOutsideFocusTrap && !this._disposeClickHandler) {\n      this._disposeClickHandler = on(window, 'click', this._forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && this._disposeClickHandler) {\n      this._disposeClickHandler();\n      this._disposeClickHandler = undefined;\n    }\n  }\n\n  private _onFocusCapture = (ev: React.FocusEvent<HTMLDivElement>) => {\n    if (this.props.onFocusCapture) {\n      this.props.onFocusCapture(ev);\n    }\n\n    if (ev.target !== ev.currentTarget && !this._isBumper(ev.target)) {\n      // every time focus changes within the trap zone, remember the focused element so that\n      // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n      this._previouslyFocusedElementInTrapZone = ev.target as HTMLElement;\n    }\n  };\n\n  private _isBumper(element: HTMLElement): boolean {\n    return element === this._firstBumper.current || element === this._lastBumper.current;\n  }\n\n  private _forceFocusInTrap = (ev: FocusEvent): void => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n      const focusedElement = this._getDocument().activeElement as HTMLElement;\n\n      if (!elementContains(this._root.current, focusedElement)) {\n        this.focus();\n        this._hasFocus = true; // set focus here since we stop event propagation\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  private _forceClickInTrap = (ev: MouseEvent): void => {\n    if (this.props.disabled) {\n      return;\n    }\n\n    if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n      const clickedElement = ev.target as HTMLElement;\n\n      if (clickedElement && !elementContains(this._root.current, clickedElement)) {\n        this.focus();\n        this._hasFocus = true; // set focus here since we stop event propagation\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  private _getDocument(): Document {\n    return getDocument(this._root.current)!;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}