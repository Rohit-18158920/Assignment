{"ast":null,"code":"/**\n * Compares a to b and b to a.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function shallowCompare(a, b) {\n  for (var propName in a) {\n    if (a.hasOwnProperty(propName)) {\n      if (!b.hasOwnProperty(propName) || b[propName] !== a[propName]) {\n        return false;\n      }\n    }\n  }\n\n  for (var propName in b) {\n    if (b.hasOwnProperty(propName)) {\n      if (!a.hasOwnProperty(propName)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Makes a resulting merge of a bunch of objects. Pass in the target object followed by 1 or more\n * objects as arguments and they will be merged sequentially into the target. Note that this will\n * shallow merge; it will not create new cloned values for target members.\n *\n * @public\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function assign(target) {\n  var args = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n\n  return filteredAssign.apply(this, [null, target].concat(args));\n}\n/**\n * Makes a resulting merge of a bunch of objects, but allows a filter function to be passed in to filter\n * the resulting merges. This allows for scenarios where you want to merge \"everything except that one thing\"\n * or \"properties that start with data-\". Note that this will shallow merge; it will not create new cloned\n * values for target members.\n *\n * @public\n * @param isAllowed - Callback to determine if the given propName is allowed in the result.\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function filteredAssign(isAllowed, target) {\n  var args = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    args[_i - 2] = arguments[_i];\n  }\n\n  target = target || {};\n\n  for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n    var sourceObject = args_1[_a];\n\n    if (sourceObject) {\n      for (var propName in sourceObject) {\n        if (sourceObject.hasOwnProperty(propName) && (!isAllowed || isAllowed(propName))) {\n          target[propName] = sourceObject[propName];\n        }\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * Takes an enum and iterates over each value of the enum (as a string), running the callback on each,\n * returning a mapped array.\n * @param theEnum - Enum to iterate over\n * @param callback - The first parameter the name of the entry, and the second parameter is the value\n * of that entry, which is the value you'd normally use when using the enum (usually a number).\n */\n\nexport function mapEnumByName( // eslint-disable-next-line @typescript-eslint/no-explicit-any\ntheEnum, callback) {\n  // map<any> to satisfy compiler since it doesn't realize we strip out undefineds in the .filter() call\n  return Object.keys(theEnum).map(function (p) {\n    // map on each property name as a string\n    if (String(Number(p)) !== p) {\n      // if the property is not just a number (because enums in TypeScript will map both ways)\n      return callback(p, theEnum[p]);\n    }\n\n    return undefined;\n  }).filter(function (v) {\n    return !!v;\n  }); // only return elements with values\n}\n/**\n * Get all values in an object dictionary\n *\n * @param obj - The dictionary to get values for\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function values(obj) {\n  return Object.keys(obj).reduce(function (arr, key) {\n    arr.push(obj[key]);\n    return arr;\n  }, []);\n}\n/**\n * Tiny helper to do the minimal amount of work in duplicating an object but omitting some\n * props. This ends up faster than using object ...rest or reduce to filter.\n *\n * This behaves very much like filteredAssign, but does not merge many objects together,\n * uses an exclusion object map, and avoids spreads all for optimal performance.\n *\n * See perf test for background:\n * https://jsperf.com/omit-vs-rest-vs-reduce/1\n *\n * @param obj - The object to clone\n * @param exclusions - The array of keys to exclude\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function omit(obj, exclusions) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  var result = {};\n\n  for (var key in obj) {\n    if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) {\n      result[key] = obj[key];\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["object.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Compares a to b and b to a.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function shallowCompare<TA extends any, TB extends any>(a: TA, b: TB): boolean {\n  for (let propName in a) {\n    if (a.hasOwnProperty(propName)) {\n      if (!b.hasOwnProperty(propName) || b[propName] !== a[propName]) {\n        return false;\n      }\n    }\n  }\n  for (let propName in b) {\n    if (b.hasOwnProperty(propName)) {\n      if (!a.hasOwnProperty(propName)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Makes a resulting merge of a bunch of objects. Pass in the target object followed by 1 or more\n * objects as arguments and they will be merged sequentially into the target. Note that this will\n * shallow merge; it will not create new cloned values for target members.\n *\n * @public\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function assign(target: any, ...args: any[]): any {\n  return filteredAssign.apply(this, [null, target].concat(args));\n}\n\n/**\n * Makes a resulting merge of a bunch of objects, but allows a filter function to be passed in to filter\n * the resulting merges. This allows for scenarios where you want to merge \"everything except that one thing\"\n * or \"properties that start with data-\". Note that this will shallow merge; it will not create new cloned\n * values for target members.\n *\n * @public\n * @param isAllowed - Callback to determine if the given propName is allowed in the result.\n * @param target - Target object to merge following object arguments into.\n * @param args - One or more objects that will be mixed into the target in the order they are provided.\n * @returns Resulting merged target.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function filteredAssign(isAllowed: (propName: string) => boolean, target: any, ...args: any[]): any {\n  target = target || {};\n\n  for (let sourceObject of args) {\n    if (sourceObject) {\n      for (let propName in sourceObject) {\n        if (sourceObject.hasOwnProperty(propName) && (!isAllowed || isAllowed(propName))) {\n          target[propName] = sourceObject[propName];\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\n/**\n * Takes an enum and iterates over each value of the enum (as a string), running the callback on each,\n * returning a mapped array.\n * @param theEnum - Enum to iterate over\n * @param callback - The first parameter the name of the entry, and the second parameter is the value\n * of that entry, which is the value you'd normally use when using the enum (usually a number).\n */\nexport function mapEnumByName<T>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  theEnum: any,\n  callback: (name?: string, value?: string | number) => T | undefined,\n): (T | undefined)[] | undefined {\n  // map<any> to satisfy compiler since it doesn't realize we strip out undefineds in the .filter() call\n  return Object.keys(theEnum)\n    .map<T | undefined>((p: string | number) => {\n      // map on each property name as a string\n      if (String(Number(p)) !== p) {\n        // if the property is not just a number (because enums in TypeScript will map both ways)\n        return callback(p as string, theEnum[p]);\n      }\n      return undefined;\n    })\n    .filter((v: T | undefined) => !!v); // only return elements with values\n}\n\n/**\n * Get all values in an object dictionary\n *\n * @param obj - The dictionary to get values for\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function values<T>(obj: any): T[] {\n  return Object.keys(obj).reduce((arr: T[], key: string): T[] => {\n    arr.push(obj[key]);\n    return arr;\n  }, []);\n}\n\n/**\n * Tiny helper to do the minimal amount of work in duplicating an object but omitting some\n * props. This ends up faster than using object ...rest or reduce to filter.\n *\n * This behaves very much like filteredAssign, but does not merge many objects together,\n * uses an exclusion object map, and avoids spreads all for optimal performance.\n *\n * See perf test for background:\n * https://jsperf.com/omit-vs-rest-vs-reduce/1\n *\n * @param obj - The object to clone\n * @param exclusions - The array of keys to exclude\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function omit<TObj extends Record<string, any>>(obj: TObj, exclusions: (keyof TObj)[]): TObj {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const result: Record<string, any> = {};\n\n  for (const key in obj) {\n    if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) {\n      result[key] = obj[key];\n    }\n  }\n\n  return result as TObj;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}