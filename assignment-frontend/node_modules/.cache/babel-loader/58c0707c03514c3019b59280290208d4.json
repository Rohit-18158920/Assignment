{"ast":null,"code":"import { getWindow } from './dom/getWindow';\n/**\n * Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled.\n * This Async helper class solves these issues by tying async code to the lifetime of a disposable object.\n *\n * Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a\n * new instance of the class and remember to call dispose() during your code's dispose handler.\n *\n * @public\n */\n\nvar Async =\n/** @class */\nfunction () {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function Async(parent, onError) {\n    this._timeoutIds = null;\n    this._immediateIds = null;\n    this._intervalIds = null;\n    this._animationFrameIds = null;\n    this._isDisposed = false;\n    this._parent = parent || null;\n    this._onErrorHandler = onError;\n\n    this._noop = function () {\n      /* do nothing */\n    };\n  }\n  /**\n   * Dispose function, clears all async operations.\n   */\n\n\n  Async.prototype.dispose = function () {\n    var id;\n    this._isDisposed = true;\n    this._parent = null; // Clear timeouts.\n\n    if (this._timeoutIds) {\n      for (id in this._timeoutIds) {\n        if (this._timeoutIds.hasOwnProperty(id)) {\n          this.clearTimeout(parseInt(id, 10));\n        }\n      }\n\n      this._timeoutIds = null;\n    } // Clear immediates.\n\n\n    if (this._immediateIds) {\n      for (id in this._immediateIds) {\n        if (this._immediateIds.hasOwnProperty(id)) {\n          this.clearImmediate(parseInt(id, 10));\n        }\n      }\n\n      this._immediateIds = null;\n    } // Clear intervals.\n\n\n    if (this._intervalIds) {\n      for (id in this._intervalIds) {\n        if (this._intervalIds.hasOwnProperty(id)) {\n          this.clearInterval(parseInt(id, 10));\n        }\n      }\n\n      this._intervalIds = null;\n    } // Clear animation frames.\n\n\n    if (this._animationFrameIds) {\n      for (id in this._animationFrameIds) {\n        if (this._animationFrameIds.hasOwnProperty(id)) {\n          this.cancelAnimationFrame(parseInt(id, 10));\n        }\n      }\n\n      this._animationFrameIds = null;\n    }\n  };\n  /**\n   * SetTimeout override, which will auto cancel the timeout during dispose.\n   * @param callback - Callback to execute.\n   * @param duration - Duration in milliseconds.\n   * @returns The setTimeout id.\n   */\n\n\n  Async.prototype.setTimeout = function (callback, duration) {\n    var _this = this;\n\n    var timeoutId = 0;\n\n    if (!this._isDisposed) {\n      if (!this._timeoutIds) {\n        this._timeoutIds = {};\n      }\n\n      timeoutId = setTimeout(function () {\n        // Time to execute the timeout, enqueue it as a foreground task to be executed.\n        try {\n          // Now delete the record and call the callback.\n          if (_this._timeoutIds) {\n            delete _this._timeoutIds[timeoutId];\n          }\n\n          callback.apply(_this._parent);\n        } catch (e) {\n          if (_this._onErrorHandler) {\n            _this._onErrorHandler(e);\n          }\n        }\n      }, duration);\n      this._timeoutIds[timeoutId] = true;\n    }\n\n    return timeoutId;\n  };\n  /**\n   * Clears the timeout.\n   * @param id - Id to cancel.\n   */\n\n\n  Async.prototype.clearTimeout = function (id) {\n    if (this._timeoutIds && this._timeoutIds[id]) {\n      clearTimeout(id);\n      delete this._timeoutIds[id];\n    }\n  };\n  /**\n   * SetImmediate override, which will auto cancel the immediate during dispose.\n   * @param callback - Callback to execute.\n   * @param targetElement - Optional target element to use for identifying the correct window.\n   * @returns The setTimeout id.\n   */\n\n\n  Async.prototype.setImmediate = function (callback, targetElement) {\n    var _this = this;\n\n    var immediateId = 0;\n    var win = getWindow(targetElement);\n\n    if (!this._isDisposed) {\n      if (!this._immediateIds) {\n        this._immediateIds = {};\n      }\n\n      var setImmediateCallback = function () {\n        // Time to execute the timeout, enqueue it as a foreground task to be executed.\n        try {\n          // Now delete the record and call the callback.\n          if (_this._immediateIds) {\n            delete _this._immediateIds[immediateId];\n          }\n\n          callback.apply(_this._parent);\n        } catch (e) {\n          _this._logError(e);\n        }\n      };\n\n      immediateId = win.setTimeout(setImmediateCallback, 0);\n      this._immediateIds[immediateId] = true;\n    }\n\n    return immediateId;\n  };\n  /**\n   * Clears the immediate.\n   * @param id - Id to cancel.\n   * @param targetElement - Optional target element to use for identifying the correct window.\n   */\n\n\n  Async.prototype.clearImmediate = function (id, targetElement) {\n    var win = getWindow(targetElement);\n\n    if (this._immediateIds && this._immediateIds[id]) {\n      win.clearTimeout(id);\n      delete this._immediateIds[id];\n    }\n  };\n  /**\n   * SetInterval override, which will auto cancel the timeout during dispose.\n   * @param callback - Callback to execute.\n   * @param duration - Duration in milliseconds.\n   * @returns The setTimeout id.\n   */\n\n\n  Async.prototype.setInterval = function (callback, duration) {\n    var _this = this;\n\n    var intervalId = 0;\n\n    if (!this._isDisposed) {\n      if (!this._intervalIds) {\n        this._intervalIds = {};\n      }\n\n      intervalId = setInterval(function () {\n        // Time to execute the interval callback, enqueue it as a foreground task to be executed.\n        try {\n          callback.apply(_this._parent);\n        } catch (e) {\n          _this._logError(e);\n        }\n      }, duration);\n      this._intervalIds[intervalId] = true;\n    }\n\n    return intervalId;\n  };\n  /**\n   * Clears the interval.\n   * @param id - Id to cancel.\n   */\n\n\n  Async.prototype.clearInterval = function (id) {\n    if (this._intervalIds && this._intervalIds[id]) {\n      clearInterval(id);\n      delete this._intervalIds[id];\n    }\n  };\n  /**\n   * Creates a function that, when executed, will only call the func function at most once per\n   * every wait milliseconds. Provide an options object to indicate that func should be invoked\n   * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled\n   * function will return the result of the last func call.\n   *\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\n   * the timeout only if the throttled function is invoked more than once during the wait timeout.\n   *\n   * @param func - The function to throttle.\n   * @param wait - The number of milliseconds to throttle executions to. Defaults to 0.\n   * @param options - The options object.\n   * @returns The new throttled function.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  Async.prototype.throttle = function (func, wait, options) {\n    var _this = this;\n\n    if (this._isDisposed) {\n      return this._noop;\n    }\n\n    var waitMS = wait || 0;\n    var leading = true;\n    var trailing = true;\n    var lastExecuteTime = 0;\n    var lastResult; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var lastArgs;\n    var timeoutId = null;\n\n    if (options && typeof options.leading === 'boolean') {\n      leading = options.leading;\n    }\n\n    if (options && typeof options.trailing === 'boolean') {\n      trailing = options.trailing;\n    }\n\n    var callback = function (userCall) {\n      var now = Date.now();\n      var delta = now - lastExecuteTime;\n      var waitLength = leading ? waitMS - delta : waitMS;\n\n      if (delta >= waitMS && (!userCall || leading)) {\n        lastExecuteTime = now;\n\n        if (timeoutId) {\n          _this.clearTimeout(timeoutId);\n\n          timeoutId = null;\n        }\n\n        lastResult = func.apply(_this._parent, lastArgs);\n      } else if (timeoutId === null && trailing) {\n        timeoutId = _this.setTimeout(callback, waitLength);\n      }\n\n      return lastResult;\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var resultFunction = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      lastArgs = args;\n      return callback(true);\n    };\n\n    return resultFunction;\n  };\n  /**\n   * Creates a function that will delay the execution of func until after wait milliseconds have\n   * elapsed since the last time it was invoked. Provide an options object to indicate that func\n   * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls\n   * to the debounced function will return the result of the last func call.\n   *\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\n   * the timeout only if the debounced function is invoked more than once during the wait\n   * timeout.\n   *\n   * @param func - The function to debounce.\n   * @param wait - The number of milliseconds to delay.\n   * @param options - The options object.\n   * @returns The new debounced function.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  Async.prototype.debounce = function (func, wait, options) {\n    var _this = this;\n\n    if (this._isDisposed) {\n      var noOpFunction = function () {\n        /** Do nothing */\n      };\n\n      noOpFunction.cancel = function () {\n        return;\n      };\n\n      noOpFunction.flush = function () {\n        return null;\n      };\n\n      noOpFunction.pending = function () {\n        return false;\n      };\n\n      return noOpFunction;\n    }\n\n    var waitMS = wait || 0;\n    var leading = false;\n    var trailing = true;\n    var maxWait = null;\n    var lastCallTime = 0;\n    var lastExecuteTime = Date.now();\n    var lastResult; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var lastArgs;\n    var timeoutId = null;\n\n    if (options && typeof options.leading === 'boolean') {\n      leading = options.leading;\n    }\n\n    if (options && typeof options.trailing === 'boolean') {\n      trailing = options.trailing;\n    }\n\n    if (options && typeof options.maxWait === 'number' && !isNaN(options.maxWait)) {\n      maxWait = options.maxWait;\n    }\n\n    var markExecuted = function (time) {\n      if (timeoutId) {\n        _this.clearTimeout(timeoutId);\n\n        timeoutId = null;\n      }\n\n      lastExecuteTime = time;\n    };\n\n    var invokeFunction = function (time) {\n      markExecuted(time);\n      lastResult = func.apply(_this._parent, lastArgs);\n    };\n\n    var callback = function (userCall) {\n      var now = Date.now();\n      var executeImmediately = false;\n\n      if (userCall) {\n        if (leading && now - lastCallTime >= waitMS) {\n          executeImmediately = true;\n        }\n\n        lastCallTime = now;\n      }\n\n      var delta = now - lastCallTime;\n      var waitLength = waitMS - delta;\n      var maxWaitDelta = now - lastExecuteTime;\n      var maxWaitExpired = false;\n\n      if (maxWait !== null) {\n        // maxWait only matters when there is a pending callback\n        if (maxWaitDelta >= maxWait && timeoutId) {\n          maxWaitExpired = true;\n        } else {\n          waitLength = Math.min(waitLength, maxWait - maxWaitDelta);\n        }\n      }\n\n      if (delta >= waitMS || maxWaitExpired || executeImmediately) {\n        invokeFunction(now);\n      } else if ((timeoutId === null || !userCall) && trailing) {\n        timeoutId = _this.setTimeout(callback, waitLength);\n      }\n\n      return lastResult;\n    };\n\n    var pending = function () {\n      return !!timeoutId;\n    };\n\n    var cancel = function () {\n      if (pending()) {\n        // Mark the debounced function as having executed\n        markExecuted(Date.now());\n      }\n    };\n\n    var flush = function () {\n      if (pending()) {\n        invokeFunction(Date.now());\n      }\n\n      return lastResult;\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var resultFunction = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      lastArgs = args;\n      return callback(true);\n    };\n\n    resultFunction.cancel = cancel;\n    resultFunction.flush = flush;\n    resultFunction.pending = pending;\n    return resultFunction;\n  };\n\n  Async.prototype.requestAnimationFrame = function (callback, targetElement) {\n    var _this = this;\n\n    var animationFrameId = 0;\n    var win = getWindow(targetElement);\n\n    if (!this._isDisposed) {\n      if (!this._animationFrameIds) {\n        this._animationFrameIds = {};\n      }\n\n      var animationFrameCallback = function () {\n        try {\n          // Now delete the record and call the callback.\n          if (_this._animationFrameIds) {\n            delete _this._animationFrameIds[animationFrameId];\n          }\n\n          callback.apply(_this._parent);\n        } catch (e) {\n          _this._logError(e);\n        }\n      };\n\n      animationFrameId = win.requestAnimationFrame ? win.requestAnimationFrame(animationFrameCallback) : win.setTimeout(animationFrameCallback, 0);\n      this._animationFrameIds[animationFrameId] = true;\n    }\n\n    return animationFrameId;\n  };\n\n  Async.prototype.cancelAnimationFrame = function (id, targetElement) {\n    var win = getWindow(targetElement);\n\n    if (this._animationFrameIds && this._animationFrameIds[id]) {\n      win.cancelAnimationFrame ? win.cancelAnimationFrame(id) : win.clearTimeout(id);\n      delete this._animationFrameIds[id];\n    }\n  }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  Async.prototype._logError = function (e) {\n    if (this._onErrorHandler) {\n      this._onErrorHandler(e);\n    }\n  };\n\n  return Async;\n}();\n\nexport { Async };","map":{"version":3,"sources":["Async.ts"],"names":[],"mappings":"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","sourcesContent":["import { getWindow } from './dom/getWindow';\n\ndeclare function setTimeout(cb: Function, delay: number): number;\ndeclare function setInterval(cb: Function, delay: number): number;\n\n/**\n * Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled.\n * This Async helper class solves these issues by tying async code to the lifetime of a disposable object.\n *\n * Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a\n * new instance of the class and remember to call dispose() during your code's dispose handler.\n *\n * @public\n */\nexport class Async {\n  private _timeoutIds: { [id: number]: boolean } | null = null;\n  private _immediateIds: { [id: number]: boolean } | null = null;\n  private _intervalIds: { [id: number]: boolean } | null = null;\n  private _animationFrameIds: { [id: number]: boolean } | null = null;\n  private _isDisposed: boolean;\n  private _parent: object | null;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _onErrorHandler: ((e: any) => void) | undefined;\n  private _noop: () => void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(parent?: object, onError?: (e: any) => void) {\n    this._isDisposed = false;\n    this._parent = parent || null;\n    this._onErrorHandler = onError;\n    this._noop = () => {\n      /* do nothing */\n    };\n  }\n\n  /**\n   * Dispose function, clears all async operations.\n   */\n  public dispose(): void {\n    let id;\n\n    this._isDisposed = true;\n    this._parent = null;\n\n    // Clear timeouts.\n    if (this._timeoutIds) {\n      for (id in this._timeoutIds) {\n        if (this._timeoutIds.hasOwnProperty(id)) {\n          this.clearTimeout(parseInt(id, 10));\n        }\n      }\n\n      this._timeoutIds = null;\n    }\n\n    // Clear immediates.\n    if (this._immediateIds) {\n      for (id in this._immediateIds) {\n        if (this._immediateIds.hasOwnProperty(id)) {\n          this.clearImmediate(parseInt(id, 10));\n        }\n      }\n\n      this._immediateIds = null;\n    }\n\n    // Clear intervals.\n    if (this._intervalIds) {\n      for (id in this._intervalIds) {\n        if (this._intervalIds.hasOwnProperty(id)) {\n          this.clearInterval(parseInt(id, 10));\n        }\n      }\n      this._intervalIds = null;\n    }\n\n    // Clear animation frames.\n    if (this._animationFrameIds) {\n      for (id in this._animationFrameIds) {\n        if (this._animationFrameIds.hasOwnProperty(id)) {\n          this.cancelAnimationFrame(parseInt(id, 10));\n        }\n      }\n\n      this._animationFrameIds = null;\n    }\n  }\n\n  /**\n   * SetTimeout override, which will auto cancel the timeout during dispose.\n   * @param callback - Callback to execute.\n   * @param duration - Duration in milliseconds.\n   * @returns The setTimeout id.\n   */\n  public setTimeout(callback: () => void, duration: number): number {\n    let timeoutId = 0;\n\n    if (!this._isDisposed) {\n      if (!this._timeoutIds) {\n        this._timeoutIds = {};\n      }\n\n      timeoutId = setTimeout(() => {\n        // Time to execute the timeout, enqueue it as a foreground task to be executed.\n\n        try {\n          // Now delete the record and call the callback.\n          if (this._timeoutIds) {\n            delete this._timeoutIds[timeoutId];\n          }\n          callback.apply(this._parent);\n        } catch (e) {\n          if (this._onErrorHandler) {\n            this._onErrorHandler(e);\n          }\n        }\n      }, duration);\n\n      this._timeoutIds[timeoutId] = true;\n    }\n\n    return timeoutId;\n  }\n\n  /**\n   * Clears the timeout.\n   * @param id - Id to cancel.\n   */\n  public clearTimeout(id: number): void {\n    if (this._timeoutIds && this._timeoutIds[id]) {\n      clearTimeout(id);\n      delete this._timeoutIds[id];\n    }\n  }\n\n  /**\n   * SetImmediate override, which will auto cancel the immediate during dispose.\n   * @param callback - Callback to execute.\n   * @param targetElement - Optional target element to use for identifying the correct window.\n   * @returns The setTimeout id.\n   */\n  public setImmediate(callback: () => void, targetElement?: Element | null): number {\n    let immediateId = 0;\n    const win = getWindow(targetElement)!;\n\n    if (!this._isDisposed) {\n      if (!this._immediateIds) {\n        this._immediateIds = {};\n      }\n\n      let setImmediateCallback = () => {\n        // Time to execute the timeout, enqueue it as a foreground task to be executed.\n\n        try {\n          // Now delete the record and call the callback.\n          if (this._immediateIds) {\n            delete this._immediateIds[immediateId];\n          }\n          callback.apply(this._parent);\n        } catch (e) {\n          this._logError(e);\n        }\n      };\n\n      immediateId = win.setTimeout(setImmediateCallback, 0);\n\n      this._immediateIds[immediateId] = true;\n    }\n\n    return immediateId;\n  }\n\n  /**\n   * Clears the immediate.\n   * @param id - Id to cancel.\n   * @param targetElement - Optional target element to use for identifying the correct window.\n   */\n  public clearImmediate(id: number, targetElement?: Element | null): void {\n    const win = getWindow(targetElement)!;\n\n    if (this._immediateIds && this._immediateIds[id]) {\n      win.clearTimeout(id);\n      delete this._immediateIds[id];\n    }\n  }\n\n  /**\n   * SetInterval override, which will auto cancel the timeout during dispose.\n   * @param callback - Callback to execute.\n   * @param duration - Duration in milliseconds.\n   * @returns The setTimeout id.\n   */\n  public setInterval(callback: () => void, duration: number): number {\n    let intervalId = 0;\n\n    if (!this._isDisposed) {\n      if (!this._intervalIds) {\n        this._intervalIds = {};\n      }\n\n      intervalId = setInterval(() => {\n        // Time to execute the interval callback, enqueue it as a foreground task to be executed.\n        try {\n          callback.apply(this._parent);\n        } catch (e) {\n          this._logError(e);\n        }\n      }, duration);\n\n      this._intervalIds[intervalId] = true;\n    }\n\n    return intervalId;\n  }\n\n  /**\n   * Clears the interval.\n   * @param id - Id to cancel.\n   */\n  public clearInterval(id: number): void {\n    if (this._intervalIds && this._intervalIds[id]) {\n      clearInterval(id);\n      delete this._intervalIds[id];\n    }\n  }\n\n  /**\n   * Creates a function that, when executed, will only call the func function at most once per\n   * every wait milliseconds. Provide an options object to indicate that func should be invoked\n   * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled\n   * function will return the result of the last func call.\n   *\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\n   * the timeout only if the throttled function is invoked more than once during the wait timeout.\n   *\n   * @param func - The function to throttle.\n   * @param wait - The number of milliseconds to throttle executions to. Defaults to 0.\n   * @param options - The options object.\n   * @returns The new throttled function.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public throttle<T extends (...args: any[]) => any>(\n    func: T,\n    wait?: number,\n    options?: {\n      leading?: boolean;\n      trailing?: boolean;\n    },\n  ): T {\n    if (this._isDisposed) {\n      return this._noop as T;\n    }\n\n    let waitMS = wait || 0;\n    let leading = true;\n    let trailing = true;\n    let lastExecuteTime = 0;\n    let lastResult: T;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let lastArgs: any[];\n    let timeoutId: number | null = null;\n\n    if (options && typeof options.leading === 'boolean') {\n      leading = options.leading;\n    }\n\n    if (options && typeof options.trailing === 'boolean') {\n      trailing = options.trailing;\n    }\n\n    let callback = (userCall?: boolean) => {\n      let now = Date.now();\n      let delta = now - lastExecuteTime;\n      let waitLength = leading ? waitMS - delta : waitMS;\n      if (delta >= waitMS && (!userCall || leading)) {\n        lastExecuteTime = now;\n        if (timeoutId) {\n          this.clearTimeout(timeoutId);\n          timeoutId = null;\n        }\n        lastResult = func.apply(this._parent, lastArgs);\n      } else if (timeoutId === null && trailing) {\n        timeoutId = this.setTimeout(callback, waitLength);\n      }\n\n      return lastResult;\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let resultFunction = ((...args: any[]): any => {\n      lastArgs = args;\n      return callback(true);\n    }) as T;\n\n    return resultFunction;\n  }\n\n  /**\n   * Creates a function that will delay the execution of func until after wait milliseconds have\n   * elapsed since the last time it was invoked. Provide an options object to indicate that func\n   * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls\n   * to the debounced function will return the result of the last func call.\n   *\n   * Note: If leading and trailing options are true func will be called on the trailing edge of\n   * the timeout only if the debounced function is invoked more than once during the wait\n   * timeout.\n   *\n   * @param func - The function to debounce.\n   * @param wait - The number of milliseconds to delay.\n   * @param options - The options object.\n   * @returns The new debounced function.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public debounce<T extends (...args: any[]) => any>(\n    func: T,\n    wait?: number,\n    options?: {\n      leading?: boolean;\n      maxWait?: number;\n      trailing?: boolean;\n    },\n  ): ICancelable<T> & T {\n    if (this._isDisposed) {\n      let noOpFunction = (() => {\n        /** Do nothing */\n      }) as ICancelable<T> & T;\n\n      noOpFunction.cancel = () => {\n        return;\n      };\n      noOpFunction.flush = ((() => null) as unknown) as () => ReturnType<T>;\n      noOpFunction.pending = () => false;\n\n      return noOpFunction;\n    }\n\n    let waitMS = wait || 0;\n    let leading = false;\n    let trailing = true;\n    let maxWait: number | null = null;\n    let lastCallTime = 0;\n    let lastExecuteTime = Date.now();\n    let lastResult: ReturnType<T>;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let lastArgs: any[];\n    let timeoutId: number | null = null;\n\n    if (options && typeof options.leading === 'boolean') {\n      leading = options.leading;\n    }\n\n    if (options && typeof options.trailing === 'boolean') {\n      trailing = options.trailing;\n    }\n\n    if (options && typeof options.maxWait === 'number' && !isNaN(options.maxWait)) {\n      maxWait = options.maxWait;\n    }\n\n    let markExecuted = (time: number) => {\n      if (timeoutId) {\n        this.clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n      lastExecuteTime = time;\n    };\n\n    let invokeFunction = (time: number) => {\n      markExecuted(time);\n      lastResult = func.apply(this._parent, lastArgs);\n    };\n\n    let callback = (userCall?: boolean) => {\n      let now = Date.now();\n      let executeImmediately = false;\n      if (userCall) {\n        if (leading && now - lastCallTime >= waitMS) {\n          executeImmediately = true;\n        }\n        lastCallTime = now;\n      }\n      let delta = now - lastCallTime;\n      let waitLength = waitMS - delta;\n      let maxWaitDelta = now - lastExecuteTime;\n      let maxWaitExpired = false;\n\n      if (maxWait !== null) {\n        // maxWait only matters when there is a pending callback\n        if (maxWaitDelta >= maxWait && timeoutId) {\n          maxWaitExpired = true;\n        } else {\n          waitLength = Math.min(waitLength, maxWait - maxWaitDelta);\n        }\n      }\n\n      if (delta >= waitMS || maxWaitExpired || executeImmediately) {\n        invokeFunction(now);\n      } else if ((timeoutId === null || !userCall) && trailing) {\n        timeoutId = this.setTimeout(callback, waitLength);\n      }\n\n      return lastResult;\n    };\n\n    let pending = (): boolean => {\n      return !!timeoutId;\n    };\n\n    let cancel = (): void => {\n      if (pending()) {\n        // Mark the debounced function as having executed\n        markExecuted(Date.now());\n      }\n    };\n\n    let flush = () => {\n      if (pending()) {\n        invokeFunction(Date.now());\n      }\n\n      return lastResult;\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let resultFunction = ((...args: any[]) => {\n      lastArgs = args;\n      return callback(true);\n    }) as ICancelable<T> & T;\n\n    resultFunction.cancel = cancel;\n    resultFunction.flush = flush;\n    resultFunction.pending = pending;\n\n    return resultFunction;\n  }\n\n  public requestAnimationFrame(callback: () => void, targetElement?: Element | null): number {\n    let animationFrameId = 0;\n    const win = getWindow(targetElement)!;\n\n    if (!this._isDisposed) {\n      if (!this._animationFrameIds) {\n        this._animationFrameIds = {};\n      }\n\n      let animationFrameCallback = () => {\n        try {\n          // Now delete the record and call the callback.\n          if (this._animationFrameIds) {\n            delete this._animationFrameIds[animationFrameId];\n          }\n\n          callback.apply(this._parent);\n        } catch (e) {\n          this._logError(e);\n        }\n      };\n\n      animationFrameId = win.requestAnimationFrame\n        ? win.requestAnimationFrame(animationFrameCallback)\n        : win.setTimeout(animationFrameCallback, 0);\n\n      this._animationFrameIds[animationFrameId] = true;\n    }\n\n    return animationFrameId;\n  }\n\n  public cancelAnimationFrame(id: number, targetElement?: Element | null): void {\n    const win = getWindow(targetElement)!;\n\n    if (this._animationFrameIds && this._animationFrameIds[id]) {\n      win.cancelAnimationFrame ? win.cancelAnimationFrame(id) : win.clearTimeout(id);\n      delete this._animationFrameIds[id];\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected _logError(e: any): void {\n    if (this._onErrorHandler) {\n      this._onErrorHandler(e);\n    }\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ICancelable<T extends (...args: any[]) => any> = {\n  flush: () => ReturnType<T>;\n  cancel: () => void;\n  pending: () => boolean;\n};\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}