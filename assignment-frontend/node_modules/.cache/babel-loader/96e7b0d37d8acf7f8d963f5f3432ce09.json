{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { KeyCodes, getNativeProps, inputProperties, isIE11, Async, initializeComponentRef } from '../../Utilities';\nvar SELECTION_FORWARD = 'forward';\nvar SELECTION_BACKWARD = 'backward';\n/**\n * {@docCategory Autofill}\n */\n\nvar Autofill =\n/** @class */\nfunction (_super) {\n  __extends(Autofill, _super);\n\n  function Autofill(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._inputElement = React.createRef();\n    _this._autoFillEnabled = true;\n    _this._isComposing = false; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and langauges like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n    _this._onCompositionStart = function (ev) {\n      _this._isComposing = true;\n      _this._autoFillEnabled = false;\n    }; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n\n    _this._onCompositionUpdate = function () {\n      if (isIE11()) {\n        _this._updateValue(_this._getCurrentInputValue(), true);\n      }\n    }; // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and langauges like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n\n\n    _this._onCompositionEnd = function (ev) {\n      var inputValue = _this._getCurrentInputValue();\n\n      _this._tryEnableAutofill(inputValue, _this.value, false, true);\n\n      _this._isComposing = false; // Due to timing, this needs to be async, otherwise no text will be selected.\n\n      _this._async.setTimeout(function () {\n        // it's technically possible that the value of _isComposing is reset during this timeout,\n        // so explicitly trigger this with composing=true here, since it is supposed to be the\n        // update for composition end\n        _this._updateValue(_this._getCurrentInputValue(), false);\n      }, 0);\n    };\n\n    _this._onClick = function () {\n      if (_this._value && _this._value !== '' && _this._autoFillEnabled) {\n        _this._autoFillEnabled = false;\n      }\n    };\n\n    _this._onKeyDown = function (ev) {\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      } // If the event is actively being composed, then don't alert autofill.\n      // Right now typing does not have isComposing, once that has been fixed any should be removed.\n\n\n      if (!ev.nativeEvent.isComposing) {\n        switch (ev.which) {\n          case KeyCodes.backspace:\n            _this._autoFillEnabled = false;\n            break;\n\n          case KeyCodes.left:\n          case KeyCodes.right:\n            if (_this._autoFillEnabled) {\n              _this._value = _this.state.displayValue;\n              _this._autoFillEnabled = false;\n            }\n\n            break;\n\n          default:\n            if (!_this._autoFillEnabled) {\n              if (_this.props.enableAutofillOnKeyPress.indexOf(ev.which) !== -1) {\n                _this._autoFillEnabled = true;\n              }\n            }\n\n            break;\n        }\n      }\n    };\n\n    _this._onInputChanged = function (ev) {\n      var value = _this._getCurrentInputValue(ev);\n\n      if (!_this._isComposing) {\n        _this._tryEnableAutofill(value, _this._value, ev.nativeEvent.isComposing);\n      } // If it is not IE11 and currently composing, update the value\n\n\n      if (!(isIE11() && _this._isComposing)) {\n        var nativeEventComposing = ev.nativeEvent.isComposing;\n        var isComposing = nativeEventComposing === undefined ? _this._isComposing : nativeEventComposing;\n\n        _this._updateValue(value, isComposing);\n      }\n    };\n\n    _this._onChanged = function () {\n      // Swallow this event, we don't care about it\n      // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n      return;\n    };\n    /**\n     * Updates the current input value as well as getting a new display value.\n     * @param newValue - The new value from the input\n     */\n\n\n    _this._updateValue = function (newValue, composing) {\n      // Only proceed if the value is nonempty and is different from the old value\n      // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n      if (!newValue && newValue === _this._value) {\n        return;\n      }\n\n      _this._value = _this.props.onInputChange ? _this.props.onInputChange(newValue, composing) : newValue;\n\n      _this.setState({\n        displayValue: _this._getDisplayValue(_this._value, _this.props.suggestedDisplayValue)\n      }, function () {\n        return _this._notifyInputChange(_this._value, composing);\n      });\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._value = props.defaultVisibleValue || '';\n    _this.state = {\n      displayValue: props.defaultVisibleValue || ''\n    };\n    return _this;\n  }\n\n  Object.defineProperty(Autofill.prototype, \"cursorLocation\", {\n    get: function () {\n      if (this._inputElement.current) {\n        var inputElement = this._inputElement.current;\n\n        if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n          return inputElement.selectionEnd;\n        } else {\n          return inputElement.selectionStart;\n        }\n      } else {\n        return -1;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"isValueSelected\", {\n    get: function () {\n      return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"value\", {\n    get: function () {\n      return this._value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionStart\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionEnd\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"inputElement\", {\n    get: function () {\n      return this._inputElement.current;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Autofill.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    if (this.props.updateValueInWillReceiveProps) {\n      var updatedInputValue = this.props.updateValueInWillReceiveProps(); // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n\n      if (updatedInputValue !== null && updatedInputValue !== this._value) {\n        this._value = updatedInputValue;\n      }\n    }\n\n    var newDisplayValue = this._getDisplayValue(this._value, nextProps.suggestedDisplayValue);\n\n    if (typeof newDisplayValue === 'string') {\n      this.setState({\n        displayValue: newDisplayValue\n      });\n    }\n  };\n\n  Autofill.prototype.componentDidUpdate = function () {\n    var value = this._value;\n    var _a = this.props,\n        suggestedDisplayValue = _a.suggestedDisplayValue,\n        shouldSelectFullInputValueInComponentDidUpdate = _a.shouldSelectFullInputValueInComponentDidUpdate,\n        preventValueSelection = _a.preventValueSelection;\n    var differenceIndex = 0;\n\n    if (preventValueSelection) {\n      return;\n    }\n\n    if (this._autoFillEnabled && value && suggestedDisplayValue && this._doesTextStartWith(suggestedDisplayValue, value)) {\n      var shouldSelectFullRange = false;\n\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n\n      if (shouldSelectFullRange && this._inputElement.current) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (differenceIndex < value.length && value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()) {\n          differenceIndex++;\n        }\n\n        if (differenceIndex > 0 && this._inputElement.current) {\n          this._inputElement.current.setSelectionRange(differenceIndex, suggestedDisplayValue.length, SELECTION_BACKWARD);\n        }\n      }\n    }\n  };\n\n  Autofill.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n\n  Autofill.prototype.render = function () {\n    var displayValue = this.state.displayValue;\n    var nativeProps = getNativeProps(this.props, inputProperties);\n    return React.createElement(\"input\", __assign({\n      autoCapitalize: \"off\",\n      autoComplete: \"off\",\n      \"aria-autocomplete\": 'both'\n    }, nativeProps, {\n      ref: this._inputElement,\n      value: displayValue,\n      onCompositionStart: this._onCompositionStart,\n      onCompositionUpdate: this._onCompositionUpdate,\n      onCompositionEnd: this._onCompositionEnd,\n      // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n      onChange: this._onChanged,\n      onInput: this._onInputChanged,\n      onKeyDown: this._onKeyDown,\n      onClick: this.props.onClick ? this.props.onClick : this._onClick,\n      \"data-lpignore\": true\n    }));\n  };\n\n  Autofill.prototype.focus = function () {\n    this._inputElement.current && this._inputElement.current.focus();\n  };\n\n  Autofill.prototype.clear = function () {\n    this._autoFillEnabled = true;\n\n    this._updateValue('', false);\n\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  };\n\n  Autofill.prototype._getCurrentInputValue = function (ev) {\n    if (ev && ev.target && ev.target.value) {\n      return ev.target.value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  };\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n\n\n  Autofill.prototype._tryEnableAutofill = function (newValue, oldValue, isComposing, isComposed) {\n    if (!isComposing && newValue && this._inputElement.current && this._inputElement.current.selectionStart === newValue.length && !this._autoFillEnabled && (newValue.length > oldValue.length || isComposed)) {\n      this._autoFillEnabled = true;\n    }\n  };\n\n  Autofill.prototype._notifyInputChange = function (newValue, composing) {\n    if (this.props.onInputValueChange) {\n      this.props.onInputValueChange(newValue, composing);\n    }\n  };\n  /**\n   * Returns a string that should be used as the display value.\n   * It evaluates this based on whether or not the suggested value starts with the input value\n   * and whether or not autofill is enabled.\n   * @param inputValue - the value that the input currently has.\n   * @param suggestedDisplayValue - the possible full value\n   */\n\n\n  Autofill.prototype._getDisplayValue = function (inputValue, suggestedDisplayValue) {\n    var displayValue = inputValue;\n\n    if (suggestedDisplayValue && inputValue && this._doesTextStartWith(suggestedDisplayValue, displayValue) && this._autoFillEnabled) {\n      displayValue = suggestedDisplayValue;\n    }\n\n    return displayValue;\n  };\n\n  Autofill.prototype._doesTextStartWith = function (text, startWith) {\n    if (!text || !startWith) {\n      return false;\n    }\n\n    return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n  };\n\n  Autofill.defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up]\n  };\n  return Autofill;\n}(React.Component);\n\nexport { Autofill };\n/**\n *  @deprecated do not use.\n * {@docCategory Autofill}\n */\n\nvar BaseAutoFill =\n/** @class */\nfunction (_super) {\n  __extends(BaseAutoFill, _super);\n\n  function BaseAutoFill() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return BaseAutoFill;\n}(Autofill);\n\nexport { BaseAutoFill };","map":{"version":3,"sources":["components/Autofill/Autofill.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { IAutofillProps, IAutofill } from './Autofill.types';\nimport { KeyCodes, getNativeProps, inputProperties, isIE11, Async, initializeComponentRef } from '../../Utilities';\n\nexport interface IAutofillState {\n  displayValue?: string;\n}\n\nconst SELECTION_FORWARD = 'forward';\nconst SELECTION_BACKWARD = 'backward';\n\n/**\n * {@docCategory Autofill}\n */\nexport class Autofill extends React.Component<IAutofillProps, IAutofillState> implements IAutofill {\n  public static defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up] as KeyCodes[],\n  };\n\n  private _inputElement = React.createRef<HTMLInputElement>();\n  private _autoFillEnabled = true;\n  private _value: string;\n  private _isComposing: boolean = false;\n  private _async: Async;\n\n  constructor(props: IAutofillProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n\n    this._value = props.defaultVisibleValue || '';\n    this.state = {\n      displayValue: props.defaultVisibleValue || '',\n    };\n  }\n\n  public get cursorLocation(): number | null {\n    if (this._inputElement.current) {\n      const inputElement = this._inputElement.current;\n      if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n        return inputElement.selectionEnd;\n      } else {\n        return inputElement.selectionStart;\n      }\n    } else {\n      return -1;\n    }\n  }\n\n  public get isValueSelected(): boolean {\n    return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n  }\n\n  public get value(): string {\n    return this._value;\n  }\n\n  public get selectionStart(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n  }\n\n  public get selectionEnd(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n  }\n\n  public get inputElement(): HTMLInputElement | null {\n    return this._inputElement.current;\n  }\n\n  public UNSAFE_componentWillReceiveProps(nextProps: IAutofillProps): void {\n    if (this.props.updateValueInWillReceiveProps) {\n      const updatedInputValue = this.props.updateValueInWillReceiveProps();\n      // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n      if (updatedInputValue !== null && updatedInputValue !== this._value) {\n        this._value = updatedInputValue;\n      }\n    }\n\n    const newDisplayValue = this._getDisplayValue(this._value, nextProps.suggestedDisplayValue);\n\n    if (typeof newDisplayValue === 'string') {\n      this.setState({ displayValue: newDisplayValue });\n    }\n  }\n\n  public componentDidUpdate() {\n    const value = this._value;\n    const { suggestedDisplayValue, shouldSelectFullInputValueInComponentDidUpdate, preventValueSelection } = this.props;\n    let differenceIndex = 0;\n\n    if (preventValueSelection) {\n      return;\n    }\n\n    if (\n      this._autoFillEnabled &&\n      value &&\n      suggestedDisplayValue &&\n      this._doesTextStartWith(suggestedDisplayValue, value)\n    ) {\n      let shouldSelectFullRange = false;\n\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n\n      if (shouldSelectFullRange && this._inputElement.current) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (\n          differenceIndex < value.length &&\n          value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()\n        ) {\n          differenceIndex++;\n        }\n        if (differenceIndex > 0 && this._inputElement.current) {\n          this._inputElement.current.setSelectionRange(\n            differenceIndex,\n            suggestedDisplayValue.length,\n            SELECTION_BACKWARD,\n          );\n        }\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const { displayValue } = this.state;\n\n    const nativeProps = getNativeProps<React.InputHTMLAttributes<HTMLInputElement>>(this.props, inputProperties);\n    return (\n      <input\n        autoCapitalize=\"off\"\n        autoComplete=\"off\"\n        aria-autocomplete={'both'}\n        {...nativeProps}\n        ref={this._inputElement}\n        value={displayValue}\n        onCompositionStart={this._onCompositionStart}\n        onCompositionUpdate={this._onCompositionUpdate}\n        onCompositionEnd={this._onCompositionEnd}\n        // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n        onChange={this._onChanged}\n        onInput={this._onInputChanged}\n        onKeyDown={this._onKeyDown}\n        onClick={this.props.onClick ? this.props.onClick : this._onClick}\n        data-lpignore={true}\n      />\n    );\n  }\n\n  public focus() {\n    this._inputElement.current && this._inputElement.current.focus();\n  }\n\n  public clear() {\n    this._autoFillEnabled = true;\n    this._updateValue('', false);\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  }\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and langauges like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionStart = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    this._isComposing = true;\n    this._autoFillEnabled = false;\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionUpdate = () => {\n    if (isIE11()) {\n      this._updateValue(this._getCurrentInputValue(), true);\n    }\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and langauges like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionEnd = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    const inputValue = this._getCurrentInputValue();\n    this._tryEnableAutofill(inputValue, this.value, false, true);\n    this._isComposing = false;\n    // Due to timing, this needs to be async, otherwise no text will be selected.\n    this._async.setTimeout(() => {\n      // it's technically possible that the value of _isComposing is reset during this timeout,\n      // so explicitly trigger this with composing=true here, since it is supposed to be the\n      // update for composition end\n      this._updateValue(this._getCurrentInputValue(), false);\n    }, 0);\n  };\n\n  private _onClick = () => {\n    if (this._value && this._value !== '' && this._autoFillEnabled) {\n      this._autoFillEnabled = false;\n    }\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLInputElement>) => {\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // If the event is actively being composed, then don't alert autofill.\n    // Right now typing does not have isComposing, once that has been fixed any should be removed.\n    if (!(ev.nativeEvent as any).isComposing) {\n      switch (ev.which) {\n        case KeyCodes.backspace:\n          this._autoFillEnabled = false;\n          break;\n        case KeyCodes.left:\n        case KeyCodes.right:\n          if (this._autoFillEnabled) {\n            this._value = this.state.displayValue!;\n            this._autoFillEnabled = false;\n          }\n          break;\n        default:\n          if (!this._autoFillEnabled) {\n            if (this.props.enableAutofillOnKeyPress!.indexOf(ev.which) !== -1) {\n              this._autoFillEnabled = true;\n            }\n          }\n          break;\n      }\n    }\n  };\n\n  private _onInputChanged = (ev: React.FormEvent<HTMLElement>) => {\n    const value: string = this._getCurrentInputValue(ev);\n\n    if (!this._isComposing) {\n      this._tryEnableAutofill(value, this._value, (ev.nativeEvent as any).isComposing);\n    }\n\n    // If it is not IE11 and currently composing, update the value\n    if (!(isIE11() && this._isComposing)) {\n      const nativeEventComposing = (ev.nativeEvent as any).isComposing;\n      const isComposing = nativeEventComposing === undefined ? this._isComposing : nativeEventComposing;\n      this._updateValue(value, isComposing);\n    }\n  };\n\n  private _onChanged = (): void => {\n    // Swallow this event, we don't care about it\n    // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n    return;\n  };\n\n  private _getCurrentInputValue(ev?: React.FormEvent<HTMLElement>): string {\n    if (ev && ev.target && (ev.target as any).value) {\n      return (ev.target as any).value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n  private _tryEnableAutofill(newValue: string, oldValue: string, isComposing?: boolean, isComposed?: boolean): void {\n    if (\n      !isComposing &&\n      newValue &&\n      this._inputElement.current &&\n      this._inputElement.current.selectionStart === newValue.length &&\n      !this._autoFillEnabled &&\n      (newValue.length > oldValue.length || isComposed)\n    ) {\n      this._autoFillEnabled = true;\n    }\n  }\n\n  private _notifyInputChange(newValue: string, composing: boolean): void {\n    if (this.props.onInputValueChange) {\n      this.props.onInputValueChange(newValue, composing);\n    }\n  }\n\n  /**\n   * Updates the current input value as well as getting a new display value.\n   * @param newValue - The new value from the input\n   */\n  private _updateValue = (newValue: string, composing: boolean) => {\n    // Only proceed if the value is nonempty and is different from the old value\n    // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n    if (!newValue && newValue === this._value) {\n      return;\n    }\n    this._value = this.props.onInputChange ? this.props.onInputChange(newValue, composing) : newValue;\n    this.setState(\n      {\n        displayValue: this._getDisplayValue(this._value, this.props.suggestedDisplayValue),\n      },\n      () => this._notifyInputChange(this._value, composing),\n    );\n  };\n\n  /**\n   * Returns a string that should be used as the display value.\n   * It evaluates this based on whether or not the suggested value starts with the input value\n   * and whether or not autofill is enabled.\n   * @param inputValue - the value that the input currently has.\n   * @param suggestedDisplayValue - the possible full value\n   */\n  private _getDisplayValue(inputValue: string, suggestedDisplayValue?: string): string {\n    let displayValue = inputValue;\n    if (\n      suggestedDisplayValue &&\n      inputValue &&\n      this._doesTextStartWith(suggestedDisplayValue, displayValue) &&\n      this._autoFillEnabled\n    ) {\n      displayValue = suggestedDisplayValue;\n    }\n    return displayValue;\n  }\n\n  private _doesTextStartWith(text: string, startWith: string): boolean {\n    if (!text || !startWith) {\n      return false;\n    }\n    return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n  }\n}\n\n/**\n *  @deprecated do not use.\n * {@docCategory Autofill}\n */\nexport class BaseAutoFill extends Autofill {}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}