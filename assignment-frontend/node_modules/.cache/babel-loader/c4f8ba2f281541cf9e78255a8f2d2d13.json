{"ast":null,"code":"import { MAX_COLOR_RGB } from './consts';\nimport { assign } from '../../Utilities';\nimport { clamp } from './clamp';\nimport { getColorFromRGBA } from './getColorFromRGBA';\nimport { hsv2hsl } from './hsv2hsl';\nimport { hsv2rgb } from './hsv2rgb'; // Soften: to get closer to the background color's luminance\n// (softening with a white background would be lightening, with black it'd be darkening)\n// Strongen: opposite of soften\n// Luminance multiplier constants for generating shades of a given color\n\nvar WhiteShadeTableBG = [0.027, 0.043, 0.082, 0.145, 0.184, 0.216, 0.349, 0.537]; // white bg\n\nvar BlackTintTableBG = [0.537, 0.45, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043]; // black bg\n\nvar WhiteShadeTable = [0.537, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043, 0.027]; // white fg\n\nvar BlackTintTable = [0.537, 0.45, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043]; // black fg\n\nvar LumTintTable = [0.88, 0.77, 0.66, 0.55, 0.44, 0.33, 0.22, 0.11]; // light (strongen all)\n\nvar LumShadeTable = [0.11, 0.22, 0.33, 0.44, 0.55, 0.66, 0.77, 0.88]; // dark (soften all)\n\nvar ColorTintTable = [0.96, 0.84, 0.7, 0.4, 0.12]; // default soften\n\nvar ColorShadeTable = [0.1, 0.24, 0.44]; // default strongen\n// If the given shade's luminance is below/above these values, we'll swap to using the White/Black tables above\n\nvar LowLuminanceThreshold = 0.2;\nvar HighLuminanceThreshold = 0.8;\n/** Shades of a given color, from softest to strongest. */\n\nexport var Shade;\n\n(function (Shade) {\n  Shade[Shade[\"Unshaded\"] = 0] = \"Unshaded\";\n  Shade[Shade[\"Shade1\"] = 1] = \"Shade1\";\n  Shade[Shade[\"Shade2\"] = 2] = \"Shade2\";\n  Shade[Shade[\"Shade3\"] = 3] = \"Shade3\";\n  Shade[Shade[\"Shade4\"] = 4] = \"Shade4\";\n  Shade[Shade[\"Shade5\"] = 5] = \"Shade5\";\n  Shade[Shade[\"Shade6\"] = 6] = \"Shade6\";\n  Shade[Shade[\"Shade7\"] = 7] = \"Shade7\";\n  Shade[Shade[\"Shade8\"] = 8] = \"Shade8\"; // remember to update isValidShade()!\n})(Shade || (Shade = {}));\n/**\n * Returns true if the argument is a valid Shade value\n * @param shade - The Shade value to validate.\n */\n\n\nexport function isValidShade(shade) {\n  return typeof shade === 'number' && shade >= Shade.Unshaded && shade <= Shade.Shade8;\n}\n\nfunction _isBlack(color) {\n  return color.r === 0 && color.g === 0 && color.b === 0;\n}\n\nfunction _isWhite(color) {\n  return color.r === MAX_COLOR_RGB && color.g === MAX_COLOR_RGB && color.b === MAX_COLOR_RGB;\n}\n\nfunction _darken(hsv, factor) {\n  return {\n    h: hsv.h,\n    s: hsv.s,\n    v: clamp(hsv.v - hsv.v * factor, 100, 0)\n  };\n}\n\nfunction _lighten(hsv, factor) {\n  return {\n    h: hsv.h,\n    s: clamp(hsv.s - hsv.s * factor, 100, 0),\n    v: clamp(hsv.v + (100 - hsv.v) * factor, 100, 0)\n  };\n}\n\nexport function isDark(color) {\n  return hsv2hsl(color.h, color.s, color.v).l < 50;\n}\n/**\n * Given a color and a shade specification, generates the requested shade of the color.\n * Logic:\n * if white\n *  darken via tables defined above\n * if black\n *  lighten\n * if light\n *  strongen\n * if dark\n *  soften\n * else default\n *  soften or strongen depending on shade#\n * @param color - The base color whose shade is to be computed\n * @param shade - The shade of the base color to compute\n * @param isInverted - Default false. Whether the given theme is inverted (reverse strongen/soften logic)\n */\n\nexport function getShade(color, shade, isInverted) {\n  if (isInverted === void 0) {\n    isInverted = false;\n  }\n\n  if (!color) {\n    return null;\n  }\n\n  if (shade === Shade.Unshaded || !isValidShade(shade)) {\n    return color;\n  }\n\n  var hsl = hsv2hsl(color.h, color.s, color.v);\n  var hsv = {\n    h: color.h,\n    s: color.s,\n    v: color.v\n  };\n  var tableIndex = shade - 1;\n  var _soften = _lighten;\n  var _strongen = _darken;\n\n  if (isInverted) {\n    _soften = _darken;\n    _strongen = _lighten;\n  }\n\n  if (_isWhite(color)) {\n    // white\n    hsv = _darken(hsv, WhiteShadeTable[tableIndex]);\n  } else if (_isBlack(color)) {\n    // black\n    hsv = _lighten(hsv, BlackTintTable[tableIndex]);\n  } else if (hsl.l / 100 > HighLuminanceThreshold) {\n    // light\n    hsv = _strongen(hsv, LumShadeTable[tableIndex]);\n  } else if (hsl.l / 100 < LowLuminanceThreshold) {\n    // dark\n    hsv = _soften(hsv, LumTintTable[tableIndex]);\n  } else {\n    // default\n    if (tableIndex < ColorTintTable.length) {\n      hsv = _soften(hsv, ColorTintTable[tableIndex]);\n    } else {\n      hsv = _strongen(hsv, ColorShadeTable[tableIndex - ColorTintTable.length]);\n    }\n  }\n\n  return getColorFromRGBA(assign(hsv2rgb(hsv.h, hsv.s, hsv.v), {\n    a: color.a\n  }));\n} // Background shades/tints are generated differently. The provided color will be guaranteed\n//   to be the darkest or lightest one. If it is <50% luminance, it will always be the darkest,\n//   otherwise it will always be the lightest.\n\nexport function getBackgroundShade(color, shade, isInverted) {\n  if (isInverted === void 0) {\n    isInverted = false;\n  }\n\n  if (!color) {\n    return null;\n  }\n\n  if (shade === Shade.Unshaded || !isValidShade(shade)) {\n    return color;\n  }\n\n  var hsv = {\n    h: color.h,\n    s: color.s,\n    v: color.v\n  };\n  var tableIndex = shade - 1;\n\n  if (!isInverted) {\n    // lightish\n    hsv = _darken(hsv, WhiteShadeTableBG[tableIndex]);\n  } else {\n    // default: if (hsl.l / 100 < .5) { // darkish\n    hsv = _lighten(hsv, BlackTintTableBG[BlackTintTable.length - 1 - tableIndex]);\n  }\n\n  return getColorFromRGBA(assign(hsv2rgb(hsv.h, hsv.s, hsv.v), {\n    a: color.a\n  }));\n}\n/* Calculates the contrast ratio between two colors. Used for verifying\n * color pairs meet minimum accessibility requirements.\n * See: https://www.w3.org/TR/WCAG20/ section 1.4.3\n */\n\nexport function getContrastRatio(color1, color2) {\n  // Formula defined by: http://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html#contrast-ratiodef\n  // relative luminance: http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n\n  /* calculate the intermediate value needed to calculating relative luminance */\n  function _getThing(x) {\n    if (x <= 0.03928) {\n      return x / 12.92;\n    } else {\n      return Math.pow((x + 0.055) / 1.055, 2.4);\n    }\n  }\n\n  var r1 = _getThing(color1.r / MAX_COLOR_RGB);\n\n  var g1 = _getThing(color1.g / MAX_COLOR_RGB);\n\n  var b1 = _getThing(color1.b / MAX_COLOR_RGB);\n\n  var L1 = 0.2126 * r1 + 0.7152 * g1 + 0.0722 * b1; // relative luminance of first color\n\n  L1 += 0.05;\n\n  var r2 = _getThing(color2.r / MAX_COLOR_RGB);\n\n  var g2 = _getThing(color2.g / MAX_COLOR_RGB);\n\n  var b2 = _getThing(color2.b / MAX_COLOR_RGB);\n\n  var L2 = 0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2; // relative luminance of second color\n\n  L2 += 0.05; // return the lighter color divided by darker\n\n  return L1 / L2 > 1 ? L1 / L2 : L2 / L1;\n}","map":{"version":3,"sources":["utilities/color/shades.ts"],"names":[],"mappings":"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","sourcesContent":["// Technically this should be shades and tints, but for simplicity we'll call everything a shade.\n/*\n * This utility module is used with theming. Given a color to shade, whether the theme is inverted\n * (i.e. is a dark color), and the desired shade enum, this will return an appropriate shade of that color.\n */\nimport { IHSV, IColor } from './interfaces';\nimport { MAX_COLOR_RGB } from './consts';\nimport { assign } from '../../Utilities';\nimport { clamp } from './clamp';\nimport { getColorFromRGBA } from './getColorFromRGBA';\nimport { hsv2hsl } from './hsv2hsl';\nimport { hsv2rgb } from './hsv2rgb';\n\n// Soften: to get closer to the background color's luminance\n// (softening with a white background would be lightening, with black it'd be darkening)\n// Strongen: opposite of soften\n\n// Luminance multiplier constants for generating shades of a given color\nconst WhiteShadeTableBG = [0.027, 0.043, 0.082, 0.145, 0.184, 0.216, 0.349, 0.537]; // white bg\nconst BlackTintTableBG = [0.537, 0.45, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043]; // black bg\nconst WhiteShadeTable = [0.537, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043, 0.027]; // white fg\nconst BlackTintTable = [0.537, 0.45, 0.349, 0.216, 0.184, 0.145, 0.082, 0.043]; // black fg\nconst LumTintTable = [0.88, 0.77, 0.66, 0.55, 0.44, 0.33, 0.22, 0.11]; // light (strongen all)\nconst LumShadeTable = [0.11, 0.22, 0.33, 0.44, 0.55, 0.66, 0.77, 0.88]; // dark (soften all)\nconst ColorTintTable = [0.96, 0.84, 0.7, 0.4, 0.12]; // default soften\nconst ColorShadeTable = [0.1, 0.24, 0.44]; // default strongen\n\n// If the given shade's luminance is below/above these values, we'll swap to using the White/Black tables above\nconst LowLuminanceThreshold = 0.2;\nconst HighLuminanceThreshold = 0.8;\n\n/** Shades of a given color, from softest to strongest. */\nexport enum Shade {\n  Unshaded = 0,\n  Shade1 = 1,\n  Shade2 = 2,\n  Shade3 = 3,\n  Shade4 = 4,\n  Shade5 = 5,\n  Shade6 = 6,\n  Shade7 = 7,\n  Shade8 = 8,\n  // remember to update isValidShade()!\n}\n\n/**\n * Returns true if the argument is a valid Shade value\n * @param shade - The Shade value to validate.\n */\nexport function isValidShade(shade?: Shade): boolean {\n  return typeof shade === 'number' && shade >= Shade.Unshaded && shade <= Shade.Shade8;\n}\n\nfunction _isBlack(color: IColor): boolean {\n  return color.r === 0 && color.g === 0 && color.b === 0;\n}\n\nfunction _isWhite(color: IColor): boolean {\n  return color.r === MAX_COLOR_RGB && color.g === MAX_COLOR_RGB && color.b === MAX_COLOR_RGB;\n}\n\nfunction _darken(hsv: IHSV, factor: number): IHSV {\n  return {\n    h: hsv.h,\n    s: hsv.s,\n    v: clamp(hsv.v - hsv.v * factor, 100, 0),\n  };\n}\n\nfunction _lighten(hsv: IHSV, factor: number): IHSV {\n  return {\n    h: hsv.h,\n    s: clamp(hsv.s - hsv.s * factor, 100, 0),\n    v: clamp(hsv.v + (100 - hsv.v) * factor, 100, 0),\n  };\n}\n\nexport function isDark(color: IColor): boolean {\n  return hsv2hsl(color.h, color.s, color.v).l < 50;\n}\n\n/**\n * Given a color and a shade specification, generates the requested shade of the color.\n * Logic:\n * if white\n *  darken via tables defined above\n * if black\n *  lighten\n * if light\n *  strongen\n * if dark\n *  soften\n * else default\n *  soften or strongen depending on shade#\n * @param color - The base color whose shade is to be computed\n * @param shade - The shade of the base color to compute\n * @param isInverted - Default false. Whether the given theme is inverted (reverse strongen/soften logic)\n */\nexport function getShade(color: IColor, shade: Shade, isInverted: boolean = false): IColor | null {\n  if (!color) {\n    return null;\n  }\n\n  if (shade === Shade.Unshaded || !isValidShade(shade)) {\n    return color;\n  }\n\n  const hsl = hsv2hsl(color.h, color.s, color.v);\n  let hsv = { h: color.h, s: color.s, v: color.v };\n  const tableIndex = shade - 1;\n  let _soften = _lighten;\n  let _strongen = _darken;\n  if (isInverted) {\n    _soften = _darken;\n    _strongen = _lighten;\n  }\n  if (_isWhite(color)) {\n    // white\n    hsv = _darken(hsv, WhiteShadeTable[tableIndex]);\n  } else if (_isBlack(color)) {\n    // black\n    hsv = _lighten(hsv, BlackTintTable[tableIndex]);\n  } else if (hsl.l / 100 > HighLuminanceThreshold) {\n    // light\n    hsv = _strongen(hsv, LumShadeTable[tableIndex]);\n  } else if (hsl.l / 100 < LowLuminanceThreshold) {\n    // dark\n    hsv = _soften(hsv, LumTintTable[tableIndex]);\n  } else {\n    // default\n    if (tableIndex < ColorTintTable.length) {\n      hsv = _soften(hsv, ColorTintTable[tableIndex]);\n    } else {\n      hsv = _strongen(hsv, ColorShadeTable[tableIndex - ColorTintTable.length]);\n    }\n  }\n\n  return getColorFromRGBA(assign(hsv2rgb(hsv.h, hsv.s, hsv.v), { a: color.a }));\n}\n\n// Background shades/tints are generated differently. The provided color will be guaranteed\n//   to be the darkest or lightest one. If it is <50% luminance, it will always be the darkest,\n//   otherwise it will always be the lightest.\nexport function getBackgroundShade(color: IColor, shade: Shade, isInverted: boolean = false): IColor | null {\n  if (!color) {\n    return null;\n  }\n\n  if (shade === Shade.Unshaded || !isValidShade(shade)) {\n    return color;\n  }\n\n  let hsv = { h: color.h, s: color.s, v: color.v };\n  const tableIndex = shade - 1;\n  if (!isInverted) {\n    // lightish\n    hsv = _darken(hsv, WhiteShadeTableBG[tableIndex]);\n  } else {\n    // default: if (hsl.l / 100 < .5) { // darkish\n    hsv = _lighten(hsv, BlackTintTableBG[BlackTintTable.length - 1 - tableIndex]);\n  }\n\n  return getColorFromRGBA(assign(hsv2rgb(hsv.h, hsv.s, hsv.v), { a: color.a }));\n}\n\n/* Calculates the contrast ratio between two colors. Used for verifying\n * color pairs meet minimum accessibility requirements.\n * See: https://www.w3.org/TR/WCAG20/ section 1.4.3\n */\nexport function getContrastRatio(color1: IColor, color2: IColor): number {\n  // Formula defined by: http://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html#contrast-ratiodef\n  // relative luminance: http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n\n  /* calculate the intermediate value needed to calculating relative luminance */\n  function _getThing(x: number): number {\n    if (x <= 0.03928) {\n      return x / 12.92;\n    } else {\n      return Math.pow((x + 0.055) / 1.055, 2.4);\n    }\n  }\n\n  const r1 = _getThing(color1.r / MAX_COLOR_RGB);\n  const g1 = _getThing(color1.g / MAX_COLOR_RGB);\n  const b1 = _getThing(color1.b / MAX_COLOR_RGB);\n  let L1 = 0.2126 * r1 + 0.7152 * g1 + 0.0722 * b1; // relative luminance of first color\n  L1 += 0.05;\n\n  const r2 = _getThing(color2.r / MAX_COLOR_RGB);\n  const g2 = _getThing(color2.g / MAX_COLOR_RGB);\n  const b2 = _getThing(color2.b / MAX_COLOR_RGB);\n  let L2 = 0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2; // relative luminance of second color\n  L2 += 0.05;\n\n  // return the lighter color divided by darker\n  return L1 / L2 > 1 ? L1 / L2 : L2 / L1;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}